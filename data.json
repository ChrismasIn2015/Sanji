{
  "blocks": {
    "D2S51gJkH": {
      "blockId": "D2S51gJkH",
      "name": "前端开发",
      "color": "#666666"
    },
    "i9hSICf-d": {
      "blockId": "i9hSICf-d",
      "name": "工作专区",
      "color": "#666666"
    }
  },
  "shelfs": {
    "VYWlh1oUK": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "name": "浏览器基础",
      "books": [
        {
          "blockId": "D2S51gJkH",
          "shelfId": "VYWlh1oUK",
          "bookId": "t8zI6NxlB",
          "name": "13",
          "content": ""
        },
        {
          "blockId": "D2S51gJkH",
          "shelfId": "VYWlh1oUK",
          "bookId": "bp5x-ofOD",
          "name": "啊是啊是",
          "content": ""
        },
        {
          "blockId": "D2S51gJkH",
          "shelfId": "VYWlh1oUK",
          "bookId": "UUgdEYUCg",
          "name": "213",
          "content": ""
        }
      ]
    },
    "Ovrt1kT5d": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "name": "关于JavaScript",
      "books": [
        {
          "blockId": "D2S51gJkH",
          "shelfId": "Ovrt1kT5d",
          "bookId": "-ASbUq8l4",
          "name": "13213",
          "content": ""
        }
      ]
    },
    "zbn-DYDR3": {
      "blockId": "zzyVg8gA_",
      "shelfId": "zbn-DYDR3",
      "name": "阿斯达"
    },
    "f2_y5u4yN": {
      "blockId": "i9hSICf-d",
      "shelfId": "f2_y5u4yN",
      "name": "公司的账号"
    },
    "UKfQP2D2P": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "name": "CSS 相关"
    },
    "l6ztlKkVv": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "name": "Web工程"
    }
  },
  "books": {
    "ojYwL7UG6": {
      "blockId": "zzyVg8gA_",
      "shelfId": "zbn-DYDR3",
      "bookId": "ojYwL7UG6",
      "name": "213",
      "content": ""
    },
    "p1cpxe2o8": {
      "blockId": "i9hSICf-d",
      "shelfId": "f2_y5u4yN",
      "bookId": "p1cpxe2o8",
      "name": "平台账号密码",
      "content": "JIRA<div>&nbsp; &nbsp; huangwenqiang</div><div>&nbsp; &nbsp; hwq1234560.</div><div><br></div><div>Gitlab</div><div>&nbsp; &nbsp;&nbsp;wqao123456</div><div>&nbsp; &nbsp; 974879409</div><div><br></div><div><div>项目设计稿原型：</div><div>&nbsp; &nbsp; 金邻APP：https://ku1nos.axshare.com</div><div>&nbsp; &nbsp; 岛主APP：https://ee6atz.axshare.com</div><div>&nbsp; &nbsp; 蓝湖设计稿：https://lanhuapp.com/url/Ys9wV-87ZWO</div></div>"
    },
    "Mho-rv0VY": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "Mho-rv0VY",
      "name": "浏览器运行原理",
      "content": "<div><b><font color=\"#ff0000\">浏览器URL解析</font></b></div><div>&nbsp; &nbsp; 1.字符串解析</div><div>&nbsp; &nbsp; 2.HTTP Strict Transport Security：强制客户端使用HTTPS请求资源</div><div>&nbsp; &nbsp; 3.其他操作：安全检查、限制访问（996.icu）</div><div>&nbsp; &nbsp; 4.检查资源缓存</div><div><br></div><div><font color=\"#ff0000\"><b>DNS查询（Domain Name System）</b></font></div><div>&nbsp; &nbsp; * DNS服务器 主要用于域名与 IP 地址的相互转换</div><div>&nbsp; &nbsp; 1.查询本地缓存：浏览器/操作系统/路由器/ISP DNS地址缓存（本地首选DNS服务器）</div><div>&nbsp; &nbsp; 2.向\"国内根域名服务器\"查询</div><div><br></div><div><font color=\"#ff0000\"><b>与查询结果的IP地址建立连接</b></font></div><div>&nbsp; &nbsp; 1.数据准备</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 应用层（封装HTTP报文：请求头/&nbsp;请求体）</div>&nbsp; &nbsp; &nbsp; &nbsp; 传输层（封装TCP/UDP首部）<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color=\"#4169e1\"><b>-&nbsp;三次握手</b></font><br><div>&nbsp; &nbsp; &nbsp; &nbsp; 网络层（封装IP首部）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 链路层（封装以太网首部）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 物理层</div><div><br></div><div><font color=\"#ff0000\"><b>服务器处理请求</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.常见服务器装配（运维）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * OS：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Windows</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - linux内核：Cento /&nbsp;Ubuntu</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Unix内核：...垄断着大型企业的关键性应用领域</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务器程序：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Web/HTTP：只需支持HTTP协议（Tomcat，Windows IIS，Apache，Nginx）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 特定应用：支持各种协议并提供服务（<span style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px;\">BEA&nbsp;</span>Weblogic，<span style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px;\">IBM&nbsp;</span>WebSphere）</div><div><br></div><div><b><font color=\"#ff0000\">浏览器端</font></b></div><div>&nbsp; &nbsp; 解压缩gzip资源 /&nbsp;资源缓存 /&nbsp;根据MIME类型解析内容</div><div>&nbsp; &nbsp; <b><font color=\"#ff0000\">1.渲染引擎</font></b></div><div><b><font color=\"#ff0000\">&nbsp; &nbsp; &nbsp; &nbsp; #&nbsp;解析</font></b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; #1 解码/构建 DOM 树</div><div>&nbsp; &nbsp; &nbsp; &nbsp; #2 解析/构建 CSS&nbsp;树</div><div>&nbsp; &nbsp; &nbsp; &nbsp; #3&nbsp;合并DOM/CSS树：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 计算DOM单位 /&nbsp;确定样式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 渲染阻塞：CSS 样式 &gt; Script脚本 &gt; DOM树</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b><font color=\"#ff0000\">#&nbsp;绘制</font></b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; #4&nbsp;布局/绘制DOM结点到渲染层</div><div>&nbsp; &nbsp; &nbsp; &nbsp; #5&nbsp;合并渲染层</div><div>&nbsp; &nbsp; &nbsp; &nbsp; #6&nbsp;布局改变会导致<b><font color=\"#ff0000\">回流</font></b>(成本高)，属性改变会导致<font color=\"#ff0000\"><b>重绘</b></font></div><div>&nbsp; &nbsp; <font color=\"#ff0000\"><b>2.JavaScript引擎</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 编译执行<b style=\"color: rgb(65, 105, 225);\">（由于动态类型特性，相同代码可能由于类型不同/值更改而被重新编译：a=1/a=\"1\"）</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color=\"#4169e1\"><b>1.词法解析</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 得出抽象语法树（AST）并转换成机器指令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color=\"#4169e1\"><b>2.预编译：</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;抽象JS内存环境：全局环境/函数环境/Eval</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;抽象JS内存环境内容：执行上下文</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color=\"#4169e1\"><b>* 创建执行上下文（所谓的变量提升）</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 创建变量内存（变量/函数）&gt;&nbsp;建立作用域链 &gt;&nbsp;确定this指向当前执行上下文</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color=\"#4169e1\"><b>3.执行&nbsp;</b></font></div><div><b style=\"color: rgb(255, 0, 0);\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;事件循环执行顺序</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1. 同步队列（宏任务）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;常规代码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2. ES6/Node（微任务）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Promise.then</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - process.nextTick</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3. 异步队列（宏任务）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 浏览器事件 / 定时器 / HTTP异步请求进程</div><div><br></div><div><b><font color=\"#ff0000\">参考文章</font></b></div><div>&nbsp; &nbsp; 1.你所不知道的 HSTS：Strict Transport Security</div><div>&nbsp; &nbsp; &nbsp; &nbsp; https://www.barretlee.com/blog/2015/10/22/hsts-intro/<br></div></div><div>&nbsp; &nbsp; 2.Web服务器、应用程序服务器、HTTP服务器区别</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://zhuanlan.zhihu.com/p/58917525</div><div>&nbsp; &nbsp; 3.在浏览器输入 URL 回车之后发生了什么（超详细版）</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://zhuanlan.zhihu.com/p/80551769</div>"
    },
    "0z_SNdTrY": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "0z_SNdTrY",
      "name": "JavaScript 创建对象",
      "content": "<div><font color=\"#ff0000\"><b>基础数据&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>1.undefined</b></font><b style=\"color: rgb(65, 105, 225);\">：</b><b style=\"color: rgb(65, 105, 225);\">undefined</b>（变量默认值）</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>2.null</b></font><b style=\"color: rgb(65, 105, 225);\">：object</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>3.数字 123</b></font><b style=\"color: rgb(65, 105, 225);\">：number</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>4.字符串“”</b></font><b style=\"color: rgb(65, 105, 225);\">：string</b></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; 5.true/false：boolean</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp;&nbsp;</b></font>* 本质是内存代表的值保存在栈中</div><div><font color=\"#ff0000\" style=\"\"><b>&nbsp; &nbsp; </b></font>判断类型</div><div>&nbsp; &nbsp; &nbsp; &nbsp; typeof：string</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target instanceof suppose：返回a是否是B构造函数的实例</div><div>&nbsp; &nbsp; &nbsp; &nbsp; parseInt/Float(): 先转换成字符串: 从头逐字符取出有效数字并返回数字</div><div><div><b style=\"color: rgb(65, 105, 225);\"><br></b></div><div><b style=\"\"><font color=\"#ff0000\">创建对象</font></b></div><div>&nbsp; &nbsp; 1.不推荐直接创建&nbsp;<b style=\"color: rgb(255, 0, 0);\">根Object&nbsp;</b>的实例 a = {} / new Object()</div><div>&nbsp; &nbsp; 2.推荐通过原型链特性创建对象实例：声明大写首字母构造函数，在原型区放置公共方法</div><div>&nbsp; &nbsp; * new -&nbsp;划分实例内存 /&nbsp;this指向实例内存 /&nbsp;执行构造函数 /&nbsp;返回新对象指针</div><div>&nbsp; &nbsp; *&nbsp;通常使用&nbsp;for in 遍历对象值键对</div><div><br></div></div><div><div>&nbsp;*&nbsp;对象分类</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 宿主(运行环境)对象 DOM/BOM</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 自定义对象：构造函数实例</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <font color=\"#4169e1\"><b>内建对象</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 通常&nbsp;</b></font>* String Array Number Boolean Date Math RegExp</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color=\"#4169e1\"><b>ES6新增&nbsp;</b></font>* Symbol Set Map Promise</div></div><div><br></div><div><div><font color=\"#ff0000\"><b>原型/构造链</b></font><br></div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>1.原型链&nbsp;</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font>* JS没有公共类的概念，为了实现对象的继承功能</div><div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b><font color=\"#4169e1\">实例&nbsp;</font></b>__proto__ =&nbsp;<font color=\"#4169e1\"><b>根Object实例</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b style=\"color: rgb(65, 105, 225);\">构造函数内存&nbsp;</b>prototype =&nbsp;<b style=\"color: rgb(65, 105, 225);\">根Object实例</b></div></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b style=\"color: rgb(65, 105, 225);\">根Object实例&nbsp;</b>__proto__ =&nbsp;<font color=\"#ff0000\"><b>所有对象根Object构造函数</b></font></div><div><br></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>2.构造链</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; 实例</b></font><font color=\"#4169e1\"><b>&nbsp;</b></font>constructor =<font color=\"#4169e1\"><b>&nbsp;构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b><font color=\"#4169e1\"><b>&nbsp;</b></font>constructor =&nbsp;<b style=\"color: rgb(65, 105, 225);\">Function</b><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b><b style=\"color: rgb(65, 105, 225);\">Function</b><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b><b style=\"color: rgb(65, 105, 225);\">&nbsp;</b>constructor =&nbsp;<b style=\"color: rgb(65, 105, 225);\">Function</b><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b><b style=\"color: rgb(65, 105, 225);\">根Object实例&nbsp;</b>constructor =&nbsp;<font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div></div></div><div><b style=\"color: rgb(65, 105, 225);\"><br></b></div><div><br></div>"
    },
    "VHe__CRq-": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "VHe__CRq-",
      "name": "内建对象",
      "content": "<div><font color=\"#ff0000\" style=\"font-weight: bold;\">*&nbsp;String&nbsp;</font><font color=\"#4169e1\" style=\"\"><b>Symbol</b></font><font style=\"\"><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp;Array&nbsp;</font><font color=\"#4169e1\" style=\"\"><b>Set</b></font><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp;</font></font>Number Boolean Date Math RegExp</div><div><font color=\"#4169e1\"><b><font style=\"\">* </font>Map Promise</b></font><br></div><div><font color=\"#4169e1\"><b>------------------------------------------------------------------------------------</b></font></div><div><b style=\"color: rgb(255, 0, 0);\">String</b><br></div><div><div>&nbsp; &nbsp; 合并：concat()</div><div>&nbsp; &nbsp; 截取</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>slice(statr, end之前)</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>substring(statr, end之前)</div><div>&nbsp; &nbsp; 首个下标：indexOf()/lastIndexOf()</div><div>&nbsp; &nbsp; 指定下标：charAt()</div><div>&nbsp; &nbsp; #</div><div>&nbsp; &nbsp; 新字符串：String(ins): String</div><div>&nbsp; &nbsp; 新字符串：Object.toString(): 返回新字符串, undefined/null 报错</div><div>&nbsp; &nbsp; 带分隔符的数组<span style=\"white-space: pre;\">\t</span>split(分隔符)</div><div><span style=\"white-space: pre;\">\t</span>#</div><div>&nbsp; &nbsp; match()<span style=\"white-space: pre;\">\t</span>找到一个或多个正则表达式的匹配。</div><div>&nbsp; &nbsp; replace()<span style=\"white-space: pre;\">\t</span>替换与正则表达式匹配的子串。</div><div>&nbsp; &nbsp; search()<span style=\"white-space: pre;\">\t</span>检索与正则表达式相匹配的值。</div></div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Symbol</b></font></div><div><div><div><span style=\"white-space: pre;\">\t</span>* 标识唯一的值 - 解决：字符串不具有唯一性</div><div><span style=\"white-space: pre;\">\t</span>应用1.常量声明 const NAME = Symbol('name')</div><div><span style=\"white-space: pre;\">\t</span>应用2.键声明</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Symbol.for('tar'):全局搜索/若无则新建</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Symbol.keyFor('tar'):全局键搜索</div></div><div><br></div><div><div>&nbsp; &nbsp; Object - key只能是 Symbol/String</div><div><span style=\"white-space: pre;\">\t</span>增加1/修改/查询 obj.key = new</div><div><span style=\"white-space: pre;\">\t</span>增加2 Object.assign(target, source) // 潜拷贝/拷贝了引用</div><div><span style=\"white-space: pre;\">\t</span>删除 delete obj.key</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>数组 Object.keys(obj)</div><div><span style=\"white-space: pre;\">\t</span>键数组 Object.keys(obj)</div><div><span style=\"white-space: pre;\">\t</span>值数组 Object.values(obj)</div><div><span style=\"white-space: pre;\">\t</span>值键对二维数组 Object.entries(obj)</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span># 由于不同的浏览器引擎采用的规范可能不同，所以输出的顺序也就不一样</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>for(let e in obj){ console.log(obj[e]) }</div><div>&nbsp; &nbsp; 迭代器</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Symbol.iterator</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span># 判断对象为空 JSON.stringfy()==={} || Object.keys(obj).length===0</div></div></div><div><br></div><b style=\"color: rgb(255, 0, 0);\">Array</b><div><div>&nbsp; &nbsp; shift()<span style=\"white-space: pre;\">\t</span>删除并返回数组的第一个元素</div><div>&nbsp; &nbsp; pop()<span style=\"white-space: pre;\">\t</span>删除并返回数组的最后一个元素</div><div>&nbsp; &nbsp; push()<span style=\"white-space: pre;\">\t</span>向数组的末尾添加一个或更多元素，并返回新的长度</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 合并：A.concat(B)</div><div>&nbsp; &nbsp; 截取 slice(start, end之前)</div><div>&nbsp; &nbsp; 替换 splice(start, 删除num个数, '新元素')</div><div>&nbsp; &nbsp; 带分隔符的字符串：join(分隔符)</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 排序：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; reverse()<span style=\"white-space: pre;\">\t</span>颠倒数组中元素的顺序</div><div>&nbsp; &nbsp; &nbsp; &nbsp; sort(compare) 默认排序顺序是根据字符串UniCode码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 需要传参 function compare(start,end){ return start-end // 升序 }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 对象排序</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function compare(e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return function(start,end){ return start[e]-end[e] }}</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>arr.forEach(function(item,index,thisArr){ console.log(item) })</div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Set</b></font></div><div><div><span style=\"white-space: pre;\">\t</span>新建 new Set(Array/String) // 数组去重</div><div><span style=\"white-space: pre;\">\t</span>增加 set.add(value)</div><div><span style=\"white-space: pre;\">\t</span>长度 size</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>数组 let arr = [...set]</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>并集 new Set([...a, ...b])</div><div><span style=\"white-space: pre;\">\t</span>交集 new Set([...a].filter(x =&gt; b.has(x)))</div><div><span style=\"white-space: pre;\">\t</span>差集 new Set([...a].filter(x =&gt; !b.has(x)))</div></div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Map</b></font></div><div><div><span style=\"white-space: pre;\">\t</span>新建 new Map(二维数组)</div><div><span style=\"white-space: pre;\">\t</span>增加 map.set(key,value)</div><div><span style=\"white-space: pre;\">\t</span>删除 map.delete(key)</div><div><span style=\"white-space: pre;\">\t</span>克隆/合并 new Map(oldMap)</div><div><span style=\"white-space: pre;\">\t</span>长度 size</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>键数组 map.keys(map)</div><div><span style=\"white-space: pre;\">\t</span>值数组 map.values(map)</div><div><span style=\"white-space: pre;\">\t</span>值键对二维数组 Array.from(map)</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span># 按插入顺序输出</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>for(let [key, value] of map){}</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>forEach( function(value,key){}, map)</div></div></div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Promise</b></font></div>"
    },
    "KqmE746O6": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "bookId": "KqmE746O6",
      "name": "常用",
      "content": "<div><div><b><font color=\"#ff0000\">常用样式</font></b></div><div><span style=\"white-space: pre;\">\t</span>行内块元素</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; display:inline-block</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; 水平对齐 vertical-align: top</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; 间隙 font-size: 0</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 背景透明:</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;opacity：0~1：所有&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rgba(x,y,z,0~1)：单独</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 行内换行</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 换行符无效 / 多个空格会被合并为一个 / 句子自动换行 / 单词超出边界</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; word-wrap: break-word</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 行内裁剪:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; white-space: nowrap;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text-overflow: ellipsis;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overflow: hidden;</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; 背景图像</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1. 设置背景图: background-image: url(../img/a.jpg)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2. 控制xy重复: background-repeat: repeat-x/y / no repeat</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3. 铺满屏幕：background-size:cover/num%</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4. 固定不动：background-attachment: fixed;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>Overflow</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visible<span style=\"white-space: pre;\">\t</span>默认值。内容不会被修剪，会呈现在元素框之外。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hidden<span style=\"white-space: pre;\">\t</span>内容会被修剪，并且其余内容是不可见的。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scroll<span style=\"white-space: pre;\">\t</span>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto<span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</div></div><div><br></div><div><font color=\"#ff0000\"><b>选择器</b></font></div><div><span style=\"white-space: pre;\">\t</span>1.优先级: 行内&gt; #ID选择器 &gt; .类+伪类选择器/属性选择器 &gt; 元素选择器 &gt; *通用 &gt; 继承</div><div><span style=\"white-space: pre;\">\t</span>2.语法:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 多选择器: A，B，C</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 前/后/后所有：a -+~ b</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 仅仅子：A &gt; a</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.伪类</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :link 未访问&nbsp;:visited 已访问&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :active&nbsp;点击&nbsp;:hover 鼠标放入 :focus 文本框输入时 :selection 文本鼠标选中时候</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ::before/after 文字前/后&amp;标签之间 { content:\"\" }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p:first-child p:nth-child(index):任意位置子元素&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p:first-of-type:第一个p</div><div><br></div><div><br></div><div><br></div><div>transform</div><div>&nbsp; &nbsp; 平移：transform: translate(X,Y)</div><div>&nbsp; &nbsp; 旋转：transform-origin:x y：旋转基点</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform: rotate(30deg)</div><div>&nbsp; &nbsp; 放缩：transform: scale(X,Y);//倍数</div><div>&nbsp; &nbsp; 3D旋转：transform: rotateX/Y(120deg)</div><div>&nbsp; &nbsp;&nbsp;</div><div>*********************************************************************</div><div>transition</div><div>&nbsp; &nbsp; 1.为指定属性(时长)添加过渡效果：transition: width 2s,height 1s...</div><div>&nbsp; &nbsp; 2.指定属性绑定事件监听：div:hover {width...height...}</div><div>&nbsp; &nbsp; # transition: all 1s + css组合</div><div>&nbsp; &nbsp;&nbsp;</div><div>*********************************************************************</div><div>复杂</div><div>&nbsp; &nbsp; 1.animation:name 1s 时间函数 开始时间 次数();</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>ease:慢快慢/linear:匀速</div><div>&nbsp; &nbsp; 2.@keyframes name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 0% {background:red;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 100% {background:green;}}</div><div>支持</div><div><span style=\"white-space: pre;\">\t</span>-webkit- Chrome:IOS/-moz- firefox/</div>"
    },
    "cvuzjh6fr": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "bookId": "cvuzjh6fr",
      "name": "布局",
      "content": "<div><font color=\"#ff0000\"><b>Position定位（默认&nbsp;static&nbsp;且&nbsp;z-index&nbsp;无效</b></font><b style=\"color: rgb(255, 0, 0);\">）</b><br></div><div>&nbsp; &nbsp; 1 文档流:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; relative：相对于原位置移动</div><div>&nbsp; &nbsp; 2 脱离文档流：</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>absolute：相对relative移动,会提升层级</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 脱离文档流而产生的高度塌陷 &amp; 相邻|垂直|内外边距重叠</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以通过添加块元素解决,清除因浮动产生的移动影响</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .clearfix:before,.clearfix:after</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {content:\"\";display:table;clear:both;}</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>float：会产生挤压</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>fixed：相对于可视界面移动,会提升层级</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div><font color=\"#ff0000\"><b>弹性盒子</b></font></div><div><span style=\"white-space: pre;\">\t</span>1.容器设置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex | inline-flex</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.容器属性</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-direction：row | row-reverse | column | column-reverse</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-wrap：nowrap | wrap | wrap-reverse</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-flow:&nbsp; &nbsp;row nowrap</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>横轴对齐&nbsp;</b></font>justify-content:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>flex-start<font color=\"#4169e1\"><b>(默认)</b></font>&nbsp;/ flex-end / center / space-between /&nbsp;space-around</div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>纵轴对齐&nbsp;</b></font>align-items:&nbsp;<div><span style=\"white-space: pre;\">\t\t</span>flex-start / flex-end / center / baseline(<font color=\"#4169e1\"><b>按文字对齐</b></font>) / stretch<font color=\"#4169e1\"><b>(默认：高度占满)</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 多横轴对齐&nbsp;</b></font>align-content:&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp; flex-start / flex-end / center / space-between / space-around / stretch<b style=\"color: rgb(65, 105, 225);\">(默认：高度占满)</b></div><div><span style=\"white-space: pre;\">\t\t</span># 子元素 float/clear/vertical-align 会失效</div><div><span style=\"white-space: pre;\">\t</span><font color=\"#4169e1\"><b>3.容器内容设置</b></font></div><div><span style=\"white-space: pre;\">\t\t</span>1. order: 值越小越靠前/默认 0</div><div><span style=\"white-space: pre;\">\t\t</span>2. flex: (占比) none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</div><div><span style=\"white-space: pre;\">\t\t</span>3. align-self: 单独设置 align-items 个性的对齐</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp; 4. margin-?:auto 会获取剩余所有空白</div><div><br></div><div><b><font color=\"#ff0000\">移动端适配&nbsp;</font></b></div><div>&nbsp; &nbsp; 主要通过媒体查询&nbsp;<font color=\"#4169e1\"><b>@media</b></font>&nbsp;为不同设备设计不同样式<br></div><div>&nbsp; &nbsp; 通常需要用meta定义了浏览器宽度 = 设备宽度</div><div>&nbsp; &nbsp; &lt;meta name='viewport' content= 'width=device-width, initial-scale=1.0'&gt;</div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; 百分比布局</b></font></div><div><span style=\"white-space: pre;\">\t</span>- 为不同设备编写不同的CSS样式文件</div><div><span style=\"white-space: pre;\">\t</span>- 宽度默认 100%; - 但是字体可能会模糊</div><div><b><font color=\"#4169e1\">&nbsp; &nbsp; Rem布局</font></b></div><div><span style=\"white-space: pre;\">\t</span># 像素设备比 -DPR -表示1个css像素对应（覆盖）的物理像素个数</div><div><span style=\"white-space: pre;\">\t</span># HTML 默认font-size:16px / 下面动态设置HTML字体</div><div><br></div><div><div><font color=\"#ff0000\"><b>//动态设置页面根字体</b></font></div><div>(function(doc, win) {</div><div>&nbsp; //1.找到HTML页面根结点</div><div>&nbsp; let html = doc.getElementsByTagName(\"html\")[0],</div><div>&nbsp; &nbsp; //2.设置全局事件 = 屏幕发生改变事件</div><div>&nbsp; &nbsp; reEvt = \"orientationchange\" in win ? \"orientationchange\" : \"resize\", //转屏/缩放</div><div>&nbsp; &nbsp; //3.设置回调函数</div><div>&nbsp; &nbsp; reFontSize = function() {</div><div>&nbsp; &nbsp; &nbsp; var clientW = doc.documentElement.clientWidth || doc.body.clientWidth; //当前屏幕宽度</div><div>&nbsp; &nbsp; &nbsp; if (!clientW) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; // 设计稿/字体 = 1920px/16px = 屏幕宽/1rem</div><div>&nbsp; &nbsp; &nbsp; let rem = (clientW * 15) / 1920;</div><div>&nbsp; &nbsp; &nbsp; rem = rem &lt; 12 ? 12 : rem;</div><div>&nbsp; &nbsp; &nbsp; html.style.fontSize = rem + \"px\";</div><div>&nbsp; &nbsp; };</div><div>&nbsp; //5.全局添加事件监听(全局事件/回调)</div><div>&nbsp; win.addEventListener(reEvt, reFontSize);</div><div>&nbsp; //6.DOMContentLoaded-&gt;dom加载完就执行,onload要dom/css/js都加载完才执行</div><div>&nbsp; doc.addEventListener(\"DOMContentLoaded\", reFontSize);</div><div>})(document, window);</div></div><div><div><font color=\"#ff0000\"><b><br></b></font></div><div><font color=\"#ff0000\"><b>常用的居中方式</b></font></div><div>&nbsp; &nbsp; 1 水平居中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; margin:0 auto&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (行内)text-align:center</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; justify-content: center;</div><div>&nbsp; &nbsp; 2 垂直居中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (单行内)line-height</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>(多行)display:table-cell; vertical-align: middle;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; align-items: center;</div><div>&nbsp; &nbsp; 3 同时对齐</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ab+re定位：trbl:0; margin:auto;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; top/left：50%; transform(-50%,-50%)/margin-l/r:-50%;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; justify-content: center; align-items: center;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;<font color=\"#4169e1\"><b>&nbsp;(弹性盒)display: flex; margin:auto;</b></font></div></div>"
    },
    "0IlRbC42H": {
      "blockId": "D2S51gJkH",
      "shelfId": "hOBITMJvI",
      "bookId": "0IlRbC42H",
      "name": "网站开发",
      "content": ""
    },
    "vpouL20lY": {
      "blockId": "D2S51gJkH",
      "shelfId": "hOBITMJvI",
      "bookId": "vpouL20lY",
      "name": "移动端开发",
      "content": ""
    },
    "2MTuHMBRu": {
      "blockId": "D2S51gJkH",
      "shelfId": "hOBITMJvI",
      "bookId": "2MTuHMBRu",
      "name": "客户端",
      "content": ""
    },
    "C15wxTq5Q": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "C15wxTq5Q",
      "name": "应用生态圈",
      "content": "<div><font color=\"#ff0000\"><b>1.传统网站开发</b></font><br></div><div><br></div><div><div>&nbsp; &nbsp; 通常是一套代码进行样式适配，再部署到 PC / Mobile&nbsp;不同平台，最后通过浏览器软件进行访问 &nbsp;&nbsp;</div><div><br><div><font color=\"#ff0000\"><b>2.移动端开发</b></font></div><div><br></div><div>&nbsp; &nbsp; Native APP (原生APP)</div><div>&nbsp; &nbsp; - Android：Java / IOS：Object-C/Swift&nbsp;等</div><div><br></div><div>&nbsp; &nbsp; Hybrid APP (混合开发)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 是一种用Native技术来搭建本地Web环境，内容主要通过Web技术来提供的移动应用</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;主要开发技术</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Uni-App：自研Wxs技术降低视图层与语言引擎通信耗损</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - React-Native：JavaScript引擎，不同平台需要不同UI</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Flutter：Dart引擎，是纯粹的渲染引擎，简单、高性能，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 但由于Dart语法使得维护性/代码可读性很差，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不支持动态热更新，不同平台需要不同UI</div></div><div><br></div><div><font color=\"#ff0000\"><b>3.客户端开发</b></font></div><div>&nbsp; &nbsp; Electron（@github）原来叫 Atom Shell</div></div><div><br></div><div><font color=\"#ff0000\"><b>参考文章</b></font></div><div>&nbsp; &nbsp; Flutter、React-Native、Uni-App比较：https://ask.dcloud.net.cn/article/36083</div>"
    },
    "fNzP1CyH1": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "fNzP1CyH1",
      "name": "流程管理",
      "content": "<div><font color=\"#ff0000\"><b>Git</b></font></div><div><div>1.在代码托管区创建远程仓库</div><div>&nbsp; &nbsp; - 局域网: GitLab</div><div>&nbsp; &nbsp; - 外网: Github/码云</div><div>&nbsp; &nbsp;&nbsp;</div><div>2.获取</div><div><span style=\"white-space: pre;\">\t</span>- 创建本地仓库</div><div><span style=\"white-space: pre;\">\t\t</span>$ git init</div><div><span style=\"white-space: pre;\">\t</span>- 通过远程仓库提供的 URL 克隆代码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - HTTPS: 需要手动输入服务器账号密码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - SSH: 需要本地生成/服务器设置SSH keys</div><div><span style=\"white-space: pre;\">\t\t</span>$ git clone [url]</div><div>&nbsp; &nbsp; - 查看这个项目对应的远程仓库</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git remote -v</div><div><span style=\"white-space: pre;\">\t</span>- 获取最新代码</div><div><span style=\"white-space: pre;\">\t\t</span>$ git pull</div><div><span style=\"white-space: pre;\">\t\t</span>- git fetch: 获取远程代码</div><div><span style=\"white-space: pre;\">\t\t</span>- git merge: 和本地库合并</div><div><span style=\"white-space: pre;\">\t</span></div><div>3.本地更改</div><div><span style=\"white-space: pre;\">\t</span>- 工作区 → 暂存区</div><div>&nbsp; &nbsp; $ git add readme.txt</div><div>&nbsp; &nbsp; - 暂存区 → 本地库</div><div>&nbsp; &nbsp; $ git commit -m \"description\"</div><div>&nbsp; &nbsp;&nbsp;</div><div>4.查看本地版本</div><div><span style=\"white-space: pre;\">\t</span>- 查看工作区及暂存区的状态</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git status</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on branch master</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no commits yet</div><div><span style=\"white-space: pre;\">\t</span>- 想知道历史提交 /空格翻页/b向上/q退出</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log -pretty=oneline 或 git reflog // 获取索引值</div><div>&nbsp; &nbsp; - 本地回退版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 通过对 HEAD 指针来决定本地版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reflog // 获取索引值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reset --hard 'key' // 设置 HEAD 指针</div><div>&nbsp; &nbsp; - 比较</div><div>&nbsp; &nbsp; &nbsp; &nbsp; git 以ROW为比较单位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git diff [(或)文件名/版本] // 查看明细</div><div><div>&nbsp; &nbsp; &nbsp; 生成本地 SSH keys 用于提供远程仓库访问权限</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.生成本地SSH目录</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ ssh-keygen -t rsa -C '邮箱/账号'</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.查看生成的SSH keys</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ cat id_rsa.pub</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.在托管服务器上设置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 添加 SSH keys&nbsp;</div><div>&nbsp; &nbsp; # 外包<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git fork 关联复制</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ pull request 分支发起请求</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ merge 同意请求并合并</div><div>配置签名<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 提交时用于标识开发人员身份/与服务器账号密码无关</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 项目级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.email</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 系统级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.name \"Your Name\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.email \"email@example.com\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 这些信息会保存到 .git/config 中</div></div></div><div><br></div><div><br></div>"
    },
    "UUfHdT497": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "UUfHdT497",
      "name": "JavaScript 发展",
      "content": "<div><font color=\"#ff0000\"><b>编程语言分层</b></font></div><div>&nbsp; &nbsp; * 二进制指令 - CPU执行计算<font color=\"#ff0000\"><b><br></b></font></div><div>&nbsp; &nbsp; *&nbsp;汇编语言（第二代计算机语言）-二进制指令的文本形式</div><div>&nbsp; &nbsp; *&nbsp;高级语言</div><div><br></div><font color=\"#ff0000\"><b>JavaScript发展</b></font><div>&nbsp; &nbsp; 1995.&nbsp;JavaScript（Ecma Script）诞生，使用<font color=\"#4169e1\"><b>解释器</b></font>逐行编译代码</div><div>&nbsp; &nbsp; 2008. 浏览器性能竞争：Google开发V8添加<font color=\"#4169e1\"><b>及时编译器</b></font>（JITs：Just in Time）&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * NodeJS，Electron&nbsp;运行环境成为可能</div><div>&nbsp; &nbsp; 2013.&nbsp;诞生强类型语言提升性能，二次转译为 JavaScript：TypeScript (MS)，Dart (Google)</div><div>&nbsp; &nbsp; 2013. 添加JavaScript语法拓展：Asm.js (Mozilla)</div><div>&nbsp; &nbsp; 2017. 将所有强类型语言编译为&nbsp;WebAssembly（MS，Google，Mozilla，Apple）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 业务逻辑调试困难 / 无法操作DOM</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;适合数据密集型计算</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * \"web领域的汇编语言\"</div><div><br><div><b><font color=\"#ff0000\">参考文章</font></b></div><div>&nbsp; &nbsp; 1.几张图让你看懂 WebAssembly</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://www.jianshu.com/p/bff8aa23fe4d</div></div><div>&nbsp; &nbsp; 2.如何评论浏览器最新的 WebAssembly 字节码技术？</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://www.zhihu.com/question/31415286</div>"
    },
    "aQ5C6KYdW": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "aQ5C6KYdW",
      "name": "DOM",
      "content": "<div>基本常识</div><div><span style=\"white-space: pre;\">\t</span>页面以结点Node为基本组成单位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; → 文档结点(document)：9&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; → 元素结点(标签)：1</div><div>&nbsp; &nbsp; &nbsp; &nbsp; → Attribute属性结点：2</div><div>&nbsp; &nbsp; &nbsp; &nbsp; → TextNode文字结点：3</div><div>&nbsp; &nbsp; document.element可以直接调用结点的基本属性</div><div>&nbsp; &nbsp; document.element.nodeName/nodeType/nodeValue:元素基本值</div><div>&nbsp; &nbsp; # innerHTML返回串中含标签/innerText不含标签</div><div>增加结点</div><div><span style=\"white-space: pre;\">\t</span>createElement(\"\")</div><div><span style=\"white-space: pre;\">\t</span>appendChild</div><div><span style=\"white-space: pre;\">\t</span>insertBefore(新，旧)</div><div>&nbsp; &nbsp; 删除：e.parentNode.removeChild(e)：需要找出父元素</div><div>&nbsp; &nbsp; 修改：replaceChild</div><div>任意结点</div><div><span style=\"white-space: pre;\">\t</span>getElementById()</div><div><span style=\"white-space: pre;\">\t</span>getElementsByName/ClassName/TagName()：集合</div><div><span style=\"white-space: pre;\">\t</span># 必须在document下进行查找(TagName除外)</div><div>&nbsp; &nbsp; querySelector(“css字符串”)：只会返回第一个符合结点</div><div>&nbsp; &nbsp; querySelectorAll(“css字符串”)：返回数组</div><div>&nbsp; &nbsp; 父节点：parentNode</div><div>&nbsp; &nbsp; 子结点：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; first/last/parentElementChild</div><div>&nbsp; &nbsp; &nbsp; &nbsp; previous/nextElementSibling</div><div>&nbsp; &nbsp; &nbsp; &nbsp; children：集合</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hasChildNodes()</div><div>&nbsp; &nbsp; # 以下查询有可能返回字符结点(如空白字符)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; first/last/parentChild</div><div>&nbsp; &nbsp; &nbsp; &nbsp; previous/nextSibling</div><div>&nbsp; &nbsp; &nbsp; &nbsp; childNodes</div><div>&nbsp; &nbsp;&nbsp;</div><div><div>***********************************************************************************</div><div>结点具有事件属性</div><div><span style=\"white-space: pre;\">\t</span>&nbsp;# onclick / onscroll / onmouseover / onmousewheel(wheelDelta:滚动方向 )</div><div><span style=\"white-space: pre;\">\t</span>&nbsp;# 可以为DOM事件设置监听函数</div><div><span style=\"white-space: pre;\">\t</span>&nbsp;<span style=\"white-space: pre;\">\t</span>1. e.click = function(event){}</div><div><span style=\"white-space: pre;\">\t</span>&nbsp;<span style=\"white-space: pre;\">\t</span>2. dom.addEventListener(\"click\",fun,是否在捕获阶段触发//0)</div><div><span style=\"white-space: pre;\">\t</span>&nbsp;# 默认存在event参数保存所有事件信息，如：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. event.clientX/Y(鼠标可视坐标)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. event.pageX/Y(鼠标页面实际坐标)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. event.target = 触发事件的DOM结点</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>***********************************************************************************</div><div>事件冒泡</div><div><span style=\"white-space: pre;\">\t</span>子元素的事件触发，也会导致所有祖先元素绑定的相同事件触发</div><div><span style=\"white-space: pre;\">\t</span>取消：在子元素的事件对象中.cancelBubble = true;</div><div>事件委派：</div><div><span style=\"white-space: pre;\">\t</span># 利用事件冒泡,只绑定一次监听函数</div><div>&nbsp; &nbsp; 1.在共同父元素上设置响应函数</div><div>&nbsp; &nbsp; - 由于子元素和父元素有共同的响应事件，所以不用循环为子元素绑定监听函数</div><div>&nbsp; &nbsp; 2.if(event.target.class==\"目标\"){监听函数}</div><div><br></div><div>// 样式</div><div><div>获取目前样式</div><div><span style=\"white-space: pre;\">\t</span>1.</div><div><span style=\"white-space: pre;\">\t\t</span>Window.getComputedStyle(node,null) : obj : 只读</div><div><span style=\"white-space: pre;\">\t\t</span>e.currentStyle.样式//仅仅IE支持</div><div>&nbsp; &nbsp; 2.</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>实际宽高</div><div>&nbsp; &nbsp; &nbsp; &nbsp; e.clientWidth/Height（ content+padding ）</div><div>&nbsp; &nbsp; 3.</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>相对于视觉父元素的量</div><div>&nbsp; &nbsp; &nbsp; &nbsp; e.offsetParent：视觉父元素对象</div><div>&nbsp; &nbsp; &nbsp; &nbsp; e.offsetWidth/Height/Left/Top（ box ）</div><div>&nbsp; &nbsp; 4.</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>可滚动的实际宽高</div><div>&nbsp; &nbsp; &nbsp; &nbsp; scrollWidth/Height/Left/Top：获取滚动条滚动的距离</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span># scrollHeight-scrollTop=clientHeight：滚动到底了</div><div>批量修改样式</div><div><span style=\"white-space: pre;\">\t</span>.style.cssText = {display:bolck;...}</div></div></div>"
    },
    "4gU3wNHJx": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "4gU3wNHJx",
      "name": "BOM",
      "content": "<div><br></div><div><div>***********************************************************************************</div><div>BOM</div><div>&nbsp; &nbsp; 1.window：窗口/网页全局对象</div><div>&nbsp; &nbsp; &nbsp; window.定时器&nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; setTimeout(expression,time)：单次延迟执行</div><div>&nbsp; &nbsp; &nbsp; &nbsp; setInterval(expression,time)：永续延迟执行</div><div>&nbsp; &nbsp; &nbsp; &nbsp; clearTimeout/Interval(name)：清除定时器</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 通过变量的返回数字来区分定时器</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 多次调用定时器函数=多个定时器同时在启动（所以在开启前关闭）</div></div>"
    },
    "0E0vp5ETT": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "0E0vp5ETT",
      "name": "ES6 与 黑魔法",
      "content": "<div><font color=\"#ff0000\"><b>ES6</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>&nbsp;1.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 用 var 声明的变量，在全局范围内有效</div><div>&nbsp; &nbsp; &nbsp; &nbsp; let 声明的变量</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 只在 let 命令所在的代码块内有效</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 不存在预处理:会产生报错</div><div>&nbsp; &nbsp; &nbsp; &nbsp; const 声明一个只读的常量，一旦声明，常量的值就不能改变。</div><div>&nbsp; &nbsp; 2.箭头函数</div><div>&nbsp; &nbsp; 3.export import&nbsp;模块化&nbsp;严格模式</div><div><font color=\"#ff0000\"><b>黑魔法</b></font></div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>闭包产生</b></font></div><div><span style=\"white-space: pre;\">\t</span>1.有嵌套的内部函数</div><div><span style=\"white-space: pre;\">\t</span>2.内部函数调用了外部函数的变量</div><div><span style=\"white-space: pre;\">\t</span>3.内部函数被外部变量引用</div><div><span style=\"white-space: pre;\">\t</span>3.外部变量执行，即内部函数执行(闭包产生)</div><div><span style=\"white-space: pre;\">\t</span># 闭包就是外部函数执行结束前，调用的变量集合</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 闭包不被销毁的根本原因是</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 外部变量没被销毁=内部函数没被销毁=外部函数没被销毁</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 外部变量是在内部函数预加载时被引用的 = 闭包产生</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 预加载的原因是因为内存执行</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>闭包用途</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.匿名函数自调用,把相关数据暴露给window.模块名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.可以根据模块名直接使用相关数据</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function foo() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>var x = 3;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function a(){return x++;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>return a;</div><div><span style=\"white-space: pre;\">\t\t</span>}</div><div><span style=\"white-space: pre;\">\t\t</span>var m = foo();</div><div><span style=\"white-space: pre;\">\t\t</span># 全局引用foo(已经执行)/导致函数a不消失/导致变量x不消失</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>函数防抖</b></font></div><div><span style=\"white-space: pre;\">\t</span>短时间内连续触发事件，回调只能执行最后一次。</div><div><span style=\"white-space: pre;\">\t</span>const debounce = (func, wait) =&gt; {</div><div><span style=\"white-space: pre;\">\t\t</span>let timer;</div><div><span style=\"white-space: pre;\">\t\t</span>return () =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clearTimeout(timer);//触发事件会先清空计时器,再重新启动</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timer = setTimeout(func, wait);};};//所以只有wait秒后才执行回调</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>函数节流</b></font></div><div><span style=\"white-space: pre;\">\t</span>事件触发后,执行回调，一定时间后才能继续触发</div><div><span style=\"white-space: pre;\">\t</span>const throttle = (func, wait) =&gt; {</div><div><span style=\"white-space: pre;\">\t\t</span>let timer;</div><div><span style=\"white-space: pre;\">\t\t</span>return () =&gt; {</div><div><span style=\"white-space: pre;\">\t\t\t</span>if (timer) {return;}//连续触发事件判断计时器是否执行</div><div><span style=\"white-space: pre;\">\t\t\t</span>timer = setTimeout(()=&gt;{</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>func();</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>timer = null;</div><div><span style=\"white-space: pre;\">\t\t\t</span>}, wait);};};//wait秒后执行回调</div></div>"
    },
    "0k47pV1-i": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "0k47pV1-i",
      "name": "部署与发布",
      "content": "<div><font color=\"#ff0000\"><b>Webpack</b></font></div>浏览器的限制<div>&nbsp; &nbsp; # 介绍</div><div>&nbsp; &nbsp; 目前的浏览器(内嵌渲染引擎/JS引擎)只支持 HTML/CSS/JavaScript 为基础的页面</div><div>&nbsp; &nbsp; - JS引擎有语法标准(ECMAScript)，而高级语法需要转译</div><div>&nbsp; &nbsp; * 模块化需求</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>原生HTML通过直接引用CSS/图片/JS代码形式无法适应大规模开发</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>于是通过模块化把一个复杂的系统分解到多个模块以方便编码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.CommonJS规范 - require同步加载/modules.exports暴露接口</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.AMD规范 - 需要第三方库requireJS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.ES6 / import/export 目前无法直接运行在大部分 JavaScript 运行环境下</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>目前的模块化方案都需要工具转译为 HTML/CSS/JavaScript</div><div>&nbsp; &nbsp; * 框架语法需要转译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; React JSX 语法需要转译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Vue 组件系统包含大量新语法 需要转译</div><div>&nbsp; &nbsp; * 新语言需要转译</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>TypeScript/SCSS 无法直接执行</div><div><br></div><div>使用说明</div><div><br></div><div><div># 介绍</div><div>&nbsp; &nbsp; 不断出现的 模块化/新语言/新框架 需求</div><div>&nbsp; &nbsp; 我们需要构建工具，在编写完代码后生成能在线上运行的代码</div><div><br></div><div># 目标</div><div>&nbsp; &nbsp; 模块合并：通过构建功能一次HTTP请求完所有需要的图片/等资源(bundle.js)</div><div>&nbsp; &nbsp; 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</div><div>&nbsp; &nbsp; 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</div><div>&nbsp; &nbsp; 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</div><div>&nbsp; &nbsp; 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</div><div>&nbsp; &nbsp; 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</div><div>&nbsp; &nbsp; 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</div><div><br></div><div># /dist/index.html( &lt;= bundle script) # Step 3 后不需要</div><div># /src/index.js</div><div># webpack-config.js</div><div># package.json</div><div><span style=\"white-space: pre;\">\t</span>\"start\": \"webpack-dev-server --open\"</div><div><span style=\"white-space: pre;\">\t</span>\"build\": \"webpack\" 或 \"webpack --config webpack-config.js\"</div></div><div><br></div><div>webpack.config.js</div><div><br></div><div><div>const path = require(\"path\");</div><div>const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); # Step 3</div><div>const CleanWebpackPlugin = require(\"clean-webpack-plugin\"); # Step 4</div><div><br></div><div>module.exports = {</div><div>&nbsp; &nbsp; # Step 1 基础功能 ======================================================</div><div>&nbsp; &nbsp; # 补充</div><div>&nbsp; &nbsp; mode: \"development\", // * 打包模式</div><div>&nbsp; &nbsp; devtool: \"inline-source-map\", // * 错误定位</div><div>&nbsp; &nbsp; # 打包路径</div><div>&nbsp; &nbsp; entry: \"./src/index.js\",</div><div>&nbsp; &nbsp; output: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; filename: \"bundle.js\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; path: path.resolve(__dirname, \"dist\")</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # Step 5 服务器模式：能够重新进行build加载（刷新了页面）</div><div>&nbsp; &nbsp; devServer: {</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>contentBase: { \"./dist\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; port: 8080,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hot: true, // * 局部刷新时需要开起</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # 打包内容</div><div>&nbsp; &nbsp; module: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; rules: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Step 2 加载样式/图片 ==========================================</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的样式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的图片</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - url-loader 依赖于 file-loader 用于图片优化/base64</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - base64 &lt;= options.limit(bit) &lt;=&nbsp; Img // 8192bit = 1024b = 1kb</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.(png|svg|jpg|gif)$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"file-loader\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"url-loader\", options: { limit: 8192 } }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><span style=\"white-space: pre;\">\t\t</span>]</div><div><span style=\"white-space: pre;\">\t</span>},</div><div>&nbsp; &nbsp; # 外部插件</div><div>&nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 3 自动生成 dist/Html 入口文件 ==================================</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new HtmlWebpackPlugin({</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: \"MyLib\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; template: \"./src/packTemplate.html\" // 导出的模板</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // favicon: \"path/to/yourfile.ico\" // Link图标</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 4 打包前清空 dist 目录 =========================================</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new CleanWebpackPlugin()</div><div>&nbsp; &nbsp; ]</div><div>};</div></div>"
    },
    "0TZERsWiP": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "0TZERsWiP",
      "name": "Js包依赖管理",
      "content": "<div><font color=\"#ff0000\"><b>NPM&nbsp;包管理</b></font></div><div>NPM<div>&nbsp; &nbsp; 淘宝镜像</div><div><span style=\"white-space: pre;\">\t</span>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ npm config edit&nbsp;registry=https://registry.npm.taobao.org/</div><div><br></div><div>初始化包管理文件</div><div><span style=\"white-space: pre;\">\t</span>$ npm init -y // 产生 package.json</div><div><span style=\"white-space: pre;\">\t</span></div><div>搜索模块</div><div><span style=\"white-space: pre;\">\t</span>$ npm search</div><div><span style=\"white-space: pre;\">\t</span></div><div>安装</div><div><span style=\"white-space: pre;\">\t</span>$ npm install moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -g moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到全局，不会在项目node_modules目录中保存模块包。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save-dev moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入devDependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>删除包</div><div><span style=\"white-space: pre;\">\t</span>$ npm uninstall/remove name</div><div><span style=\"white-space: pre;\">\t</span></div><div>当导入一个包时：require('vue')</div><div>&nbsp; &nbsp; 1.找到对应的 node_modules</div><div>&nbsp; &nbsp; 2.找到require的包文件夹</div><div>&nbsp; &nbsp; 3.根据package.json找到需要的JS库文件</div></div>"
    },
    "vr6hpJCmS": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "vr6hpJCmS",
      "name": "IDE编辑器",
      "content": "<div>prettier.config.js<br></div><div>{</div><div>&nbsp; &nbsp; // ***************** 必备 *****************</div><div>&nbsp; &nbsp; // 自动格式化</div><div>&nbsp; &nbsp; \"editor.formatOnSave\": true,</div><div><br></div><div>&nbsp; &nbsp; // Tab缩进为4个空格</div><div>&nbsp; &nbsp; \"prettier.tabWidth\": 4,</div><div><br></div><div>&nbsp; &nbsp; // 统一使用单引号</div><div>&nbsp; &nbsp; \"prettier.singleQuote\": true,</div><div><br></div><div>&nbsp; &nbsp; // ***************** 其他 *****************</div><div>&nbsp; &nbsp; // 是否自动添加分号</div><div>&nbsp; &nbsp; \"prettier.semi\": false,</div><div><br></div><div>&nbsp; &nbsp; // { / }两侧必须有空格</div><div>&nbsp; &nbsp; \"prettier.bracketSpacing\": true,</div><div><br></div><div>&nbsp; &nbsp; // 单参数箭头函数 总是带()</div><div>&nbsp; &nbsp; \"prettier.arrowParens\": \"always\",</div><div><br></div><div>&nbsp; &nbsp; // vue 模板/样式的缩进</div><div>&nbsp; &nbsp; \"prettier.vueIndentScriptAndStyle\": true</div><div>}</div><div><br></div>"
    },
    "abKIu8mOZ": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "abKIu8mOZ",
      "name": "VUE",
      "content": "生命周期<div>&nbsp; &nbsp; beforeCreate =&gt; 初始化事件/生命周期</div><div><span style=\"white-space: pre;\">\t\t</span>created&nbsp;</div><div><span style=\"white-space: pre;\">\t\t\t</span>=&gt; 根据el:#app调用 vm.$mount(\"#app\")</div><div><span style=\"white-space: pre;\">\t\t\t</span>=&gt; 根据template编译到 vm.render 中</div><div><span style=\"white-space: pre;\">\t\t</span>beforeMount =&gt; vm.$el = DOM</div><div><span style=\"white-space: pre;\">\t\t</span>mounted =&gt; beforeUpdate &lt;=&gt; update =&gt; vm.$destroy()</div><div><span style=\"white-space: pre;\">\t\t</span>destroyed</div><div><br></div><div>VUE实例</div><div><div>***********************************************************************************</div><div>组件是可以复用的 Vue 实例</div><div><span style=\"white-space: pre;\">\t</span>1. 组件控制模板字符串\"&lt;templete&gt;\"/单vue文件</div><div><span style=\"white-space: pre;\">\t</span>2. 注册</div><div><span style=\"white-space: pre;\">\t\t</span>全局: Vue.component('component', {..详见基础..})</div><div><span style=\"white-space: pre;\">\t\t</span>局部: components: { 'component': {..详见基础..} } （常用）</div><div><span style=\"white-space: pre;\">\t</span>3. 动态组件</div><div><span style=\"white-space: pre;\">\t\t</span>3.1 &lt;component :is=\"currentTabComponent\"&gt;&lt;/component&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>3.2 ('component', {</div><div><span style=\"white-space: pre;\">\t\t\t</span>render: (createElement) =&gt; { return createElement(...) }</div><div><span style=\"white-space: pre;\">\t\t</span>})</div><div><span style=\"white-space: pre;\">\t</span># createElement(</div><div><span style=\"white-space: pre;\">\t\t</span>'HTML/Component-Name', // 必填</div><div><span style=\"white-space: pre;\">\t\t</span>{ data / computed / methods&nbsp; }, // 可选</div><div><span style=\"white-space: pre;\">\t\t</span>['String', 'createElement(...)'] // 可选</div><div><span style=\"white-space: pre;\">\t</span>)</div><div><span style=\"white-space: pre;\">\t</span></div><div># 通常使用HTML语言来创建模板语法</div><div># 函数式模板-render函数通过传入函数,返回一个createElement函数的调用结果,创建虚拟DOM</div><div>var vm = new Vue({</div><div>&nbsp; &nbsp; el:\"#app\",</div><div>&nbsp; &nbsp; render:function(cE){</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>return cE('tag',tag属性集合{ class:..,style:..,});</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; # 返回一个虚拟DOM树替换VM</div><div>&nbsp; &nbsp; # 简写:render: c =&gt; c(...);</div><div>})</div><div><br></div><div>***********************************************************************************</div><div># 使用父组件</div><div>&nbsp; &nbsp; 1.数据</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>父: &lt;name-x :中间变量=父数据&gt;</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>子: props:[\"中间变量\"]</div><div>&nbsp; &nbsp; 2.方法</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 父: &lt;name-x v-on:\"中间变量\"=父方法&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 子: &lt;template v-on:click=\"子方法\"&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; this.$emit(\"中间变量\"，参数1...)</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div># 使用子组件数据</div><div><span style=\"white-space: pre;\">\t</span>数据/方法</div><div><span style=\"white-space: pre;\">\t\t</span>父: &lt;name-x ref='name'&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$refs.name.fun/data</div><div><span style=\"white-space: pre;\">\t\t</span></div><div># 兄弟组件：</div><div><span style=\"white-space: pre;\">\t</span>创建一个新Vue的实例，让各个兄弟共用同一个事件机制</div><div><span style=\"white-space: pre;\">\t</span>创建空模板：export default new Vue()</div><div><span style=\"white-space: pre;\">\t</span>注册: mounted() =&gt; emptyVue.$on(\"中间变量\",(参数)=&gt;{回调})}//注册事件</div><div><span style=\"white-space: pre;\">\t</span>触发: emptyVue.$emit(\"中间变量\"，参数...)</div></div><div><br></div><div><br></div><div><div># 路由能根据路径的不同而在VM机中展示不同的组件</div><div>1.导入&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>npm i vue-router</div><div>2.创建路由对象</div><div><span style=\"white-space: pre;\">\t</span>Vue.use(VueRouter);</div><div><span style=\"white-space: pre;\">\t</span>var rou = new VueRouter({</div><div><span style=\"white-space: pre;\">\t\t</span>routes:[</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则1<span style=\"white-space: pre;\">\t</span>{</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>path:'/'',redirect:\"/index\",component:组件,</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>children:[{path:'a1', component:目标组件}, ...]},</div><div><span style=\"white-space: pre;\">\t\t\t\t</span># children会被渲染到/index的router-view中</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则2<span style=\"white-space: pre;\">\t</span>{path:'/', component:?},</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则3<span style=\"white-space: pre;\">\t</span>{path:'/', component:?}]})</div><div>3.APP注册: router:路由对象,</div><div>4.使用路由</div><div><span style=\"white-space: pre;\">\t</span>JS访问:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>&lt;router-link :to=\"{ name:'user', params:{userId: 123} }\"&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.push({ name:'user', params:{userId: 123} });</div><div><span style=\"white-space: pre;\">\t</span>获得参数:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.query.id/name</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.params.id/name</div><div><span style=\"white-space: pre;\">\t\t</span>this.$route.params.name //当前路由</div><div>***********************************************************************************</div></div><div><br></div><div><div>npm install vuex --save</div><div>1.创建仓库入口 /store/index.js</div><div><span style=\"white-space: pre;\">\t</span>Vue.use(Vuex)</div><div><span style=\"white-space: pre;\">\t</span>export default Vuex.Store({ modules: {} })</div><div>2.</div></div><div><br></div><div><div>安装 Node.exe</div><div>全局安装</div><div><span style=\"white-space: pre;\">\t</span>vue i @vue/cli -g</div><div><span style=\"white-space: pre;\">\t</span>依赖 @vue/cli-service 进行配置/拓展</div><div>传统生成项目</div><div><span style=\"white-space: pre;\">\t</span>1.vue create name</div><div><span style=\"white-space: pre;\">\t</span>2.public/index.html 文件是一个会被 html-webpack-plugin 处理的模板</div><div><span style=\"white-space: pre;\">\t</span></div><div><span style=\"white-space: pre;\">\t</span># 调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象：</div><div><span style=\"white-space: pre;\">\t</span>// vue.config.js</div><div>&nbsp; &nbsp; module.exports = {</div><div>&nbsp; &nbsp; &nbsp; configureWebpack: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new MyAwesomeWebpackPlugin()]}}</div><div>项目本地测试</div><div><span style=\"white-space: pre;\">\t</span>npm run serve (vue-cli-service serve)</div><div><span style=\"white-space: pre;\">\t</span>命令会启动一个开发服务器 (基于 webpack-dev-server)&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>可以使用 vue.config.js 里的 devServer 字段配置开发服务器。</div><div>项目打包</div><div><span style=\"white-space: pre;\">\t</span>npm run serve (vue-cli-service build)</div><div><span style=\"white-space: pre;\">\t</span>会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，</div></div>"
    }
  }
}