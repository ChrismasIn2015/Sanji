{
  "blocks": {
    "DCgJdlX5R": {
      "blockId": "DCgJdlX5R",
      "name": "客户端",
      "color": "#666666"
    },
    "uuzRN_3cX": {
      "blockId": "uuzRN_3cX",
      "name": "服务端",
      "color": "#666666"
    },
    "U2EWIATls": {
      "blockId": "U2EWIATls",
      "name": "计算机通用",
      "color": "#666666"
    },
    "YxnegsTMH": {
      "blockId": "YxnegsTMH",
      "name": "人文社科",
      "color": "#666666"
    }
  },
  "shelfs": {
    "VYWlh1oUK": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "name": "Web原理",
      "books": [
        {
          "blockId": "D2S51gJkH",
          "shelfId": "VYWlh1oUK",
          "bookId": "t8zI6NxlB",
          "name": "13",
          "content": ""
        },
        {
          "blockId": "D2S51gJkH",
          "shelfId": "VYWlh1oUK",
          "bookId": "bp5x-ofOD",
          "name": "啊是啊是",
          "content": ""
        },
        {
          "blockId": "D2S51gJkH",
          "shelfId": "VYWlh1oUK",
          "bookId": "UUgdEYUCg",
          "name": "213",
          "content": ""
        }
      ]
    },
    "zbn-DYDR3": {
      "blockId": "zzyVg8gA_",
      "shelfId": "zbn-DYDR3",
      "name": "阿斯达"
    },
    "f2_y5u4yN": {
      "blockId": "i9hSICf-d",
      "shelfId": "f2_y5u4yN",
      "name": "公司的账号"
    },
    "EpjNpojH6": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "name": "计算机体系 & 工具"
    },
    "OrVbgLEFn": {
      "blockId": "D2S51gJkH",
      "shelfId": "OrVbgLEFn",
      "name": "经济 & 政治 & 数学"
    },
    "nP7h_-tlw": {
      "blockId": "D2S51gJkH",
      "shelfId": "nP7h_-tlw",
      "name": "阅读 & 写作"
    },
    "qoV8Oj9OL": {
      "blockId": "CvCnS_7t1",
      "shelfId": "qoV8Oj9OL",
      "name": "2020 - 04"
    },
    "9Phd5zy_B": {
      "blockId": "CvCnS_7t1",
      "shelfId": "9Phd5zy_B",
      "name": "2020 - 05"
    },
    "BkZCq7kSs": {
      "blockId": "CvCnS_7t1",
      "shelfId": "BkZCq7kSs",
      "name": "2020 - 06"
    },
    "BZ9Pwkewy": {
      "blockId": "CvCnS_7t1",
      "shelfId": "BZ9Pwkewy",
      "name": "2020 - 07"
    },
    "wPO5Vpz-M": {
      "blockId": "CvCnS_7t1",
      "shelfId": "wPO5Vpz-M",
      "name": "2020 - 08"
    },
    "Smv3SrJoU": {
      "blockId": "CvCnS_7t1",
      "shelfId": "Smv3SrJoU",
      "name": "2020 - 10"
    },
    "Ee2OOINnh": {
      "blockId": "CvCnS_7t1",
      "shelfId": "Ee2OOINnh",
      "name": "2020 - 11"
    },
    "UzdctfWmT": {
      "blockId": "CvCnS_7t1",
      "shelfId": "UzdctfWmT",
      "name": "2020 - 12"
    },
    "mmbc6CSOP": {
      "blockId": "CvCnS_7t1",
      "shelfId": "mmbc6CSOP",
      "name": "事件记录"
    },
    "g7ISl8mtw": {
      "blockId": "Q7eHmettS",
      "shelfId": "g7ISl8mtw",
      "name": "321"
    },
    "JD79QGCCZ": {
      "blockId": "_tJYlRfe1",
      "shelfId": "JD79QGCCZ",
      "name": "123"
    },
    "cAPSALi3a": {
      "blockId": "WckgEzTFu",
      "shelfId": "cAPSALi3a",
      "name": "123"
    },
    "D-CDKmCae": {
      "blockId": "DCgJdlX5R",
      "shelfId": "D-CDKmCae",
      "name": "浏览器"
    },
    "2bQM1u5VX": {
      "blockId": "DCgJdlX5R",
      "shelfId": "2bQM1u5VX",
      "name": "JavaScript"
    },
    "v1x8EzKB6": {
      "blockId": "DCgJdlX5R",
      "shelfId": "v1x8EzKB6",
      "name": "应用生态圈"
    },
    "At1V2rMjl": {
      "blockId": "uuzRN_3cX",
      "shelfId": "At1V2rMjl",
      "name": "处理程序"
    },
    "Voh8g7nW6": {
      "blockId": "U2EWIATls",
      "shelfId": "Voh8g7nW6",
      "name": "组成原理"
    },
    "rWmTUaczK": {
      "blockId": "U2EWIATls",
      "shelfId": "rWmTUaczK",
      "name": "操作系统"
    },
    "ntUIPXagV": {
      "blockId": "U2EWIATls",
      "shelfId": "ntUIPXagV",
      "name": "协议与网络"
    },
    "AvNgmhcbf": {
      "blockId": "U2EWIATls",
      "shelfId": "AvNgmhcbf",
      "name": "数据结构"
    },
    "9Exg2gPYK": {
      "blockId": "U2EWIATls",
      "shelfId": "9Exg2gPYK",
      "name": "算法应用"
    },
    "SdTAGDIMM": {
      "blockId": "U2EWIATls",
      "shelfId": "SdTAGDIMM",
      "name": "软件设计模式"
    },
    "8ehQoNmob": {
      "blockId": "DCgJdlX5R",
      "shelfId": "8ehQoNmob",
      "name": "工具链"
    },
    "q6_9Db-FR": {
      "blockId": "YxnegsTMH",
      "shelfId": "q6_9Db-FR",
      "name": "政治学"
    },
    "Ho01HabXF": {
      "blockId": "YxnegsTMH",
      "shelfId": "Ho01HabXF",
      "name": "经济学"
    },
    "23a3PBcDa": {
      "blockId": "YxnegsTMH",
      "shelfId": "23a3PBcDa",
      "name": "数学"
    },
    "MMuN17Zro": {
      "blockId": "YxnegsTMH",
      "shelfId": "MMuN17Zro",
      "name": "人生经验"
    },
    "YKdKtabb9": {
      "blockId": "DCgJdlX5R",
      "shelfId": "YKdKtabb9",
      "name": "工作"
    }
  },
  "books": {
    "ojYwL7UG6": {
      "blockId": "zzyVg8gA_",
      "shelfId": "zbn-DYDR3",
      "bookId": "ojYwL7UG6",
      "name": "213",
      "content": ""
    },
    "p1cpxe2o8": {
      "blockId": "i9hSICf-d",
      "shelfId": "f2_y5u4yN",
      "bookId": "p1cpxe2o8",
      "name": "平台账号密码",
      "content": "JIRA<div>&nbsp; &nbsp; huangwenqiang</div><div>&nbsp; &nbsp; hwq1234560.</div><div><br></div><div>Gitlab</div><div>&nbsp; &nbsp;&nbsp;wqao123456</div><div>&nbsp; &nbsp; 974879409</div><div><br></div><div><div>项目设计稿原型：</div><div>&nbsp; &nbsp; 金邻APP：https://ku1nos.axshare.com</div><div>&nbsp; &nbsp; 岛主APP：https://ee6atz.axshare.com</div><div>&nbsp; &nbsp; 蓝湖设计稿：https://lanhuapp.com/url/Ys9wV-87ZWO</div></div>"
    },
    "Mho-rv0VY": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "Mho-rv0VY",
      "name": "浏览器请求过程",
      "content": "<div><b><font color=\"#ff0000\">浏览器URL解析</font></b></div><div>&nbsp; &nbsp; 1.字符串解析</div><div>&nbsp; &nbsp; 2.HTTP Strict Transport Security：强制客户端使用HTTPS请求资源</div><div>&nbsp; &nbsp; 3.其他操作：安全检查、限制访问（996.icu）</div><div>&nbsp; &nbsp; 4.检查资源缓存</div><div><br></div><div><font color=\"#ff0000\"><b>DNS查询（Domain Name System）</b></font></div><div>&nbsp; &nbsp; * DNS服务器 主要用于域名与 IP 地址的相互转换</div><div>&nbsp; &nbsp; 1.查询本地缓存：浏览器/操作系统/路由器/ISP DNS地址缓存（本地首选DNS服务器）</div><div>&nbsp; &nbsp; 2.向\"国内根域名服务器\"查询</div><div><br></div><div><font color=\"#ff0000\"><b>与查询结果的IP地址建立连接</b></font></div><div>&nbsp; &nbsp; 应用层（封装<font color=\"#ff0000\"><b>HTTP：80</b></font>报文：请求头/&nbsp;请求体）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - <font color=\"#4169e1\"><b>GET / POST</b></font>(新增修改权) /&nbsp;<font color=\"#4169e1\"><b>PUT</b></font>(修改权) / <font color=\"#4169e1\"><b>DELETE</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; - OPTIONS&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 获取目的资源所支持的通信方式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 跨域请求中，其是浏览器自发起的预检请求，以检测实际请求是否可以被浏览器接受。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - <font color=\"#4169e1\" style=\"\"><b>HTTPS：443</b></font><br></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </b></font>基于HTTP添加<font color=\"#ff0000\"><b>&nbsp;</b></font>SSL（Secure Sockets Layer）协议用于数据加密</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务器需要付费申请CA证书（公钥）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;三次握手后，浏览器请求证书信息（私钥），协商安全等级，建立秘钥会话</div><div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp; &nbsp; &nbsp; &nbsp; </font><font color=\"#4169e1\"><b>AJAX</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font>XMLHttpRequest</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 自封装了Fetch方法</div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</font><font color=\"#4169e1\"><b>同源策略</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font>同源策略是浏览器的安全限制，从一个源加载的文档或者脚本默认不能访问另一个源的资源</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 通过<font color=\"#4169e1\"><b>CORS</b></font>(Cross-Origin Resources Sharing)，浏览器允许向其他源服务器发送资源请求。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;目前基本上主流的浏览器都支持CORS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务端需要在响应头中设置 Access-Control-Allow-Origin 就可以开启 CORS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;可以通过代理服务器（如Nginx）转发请求/响应来规避跨域问题</div></div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;<font color=\"#4169e1\"><b>身份认证方式</b></font><div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务器可以设置浏览器保存&nbsp;<font color=\"#4169e1\"><b>Cookie</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务器生产保存&nbsp;<font color=\"#4169e1\"><b>Session</b></font>（内存开销，扩展迁移不易），浏览器临时使用&nbsp;<font color=\"#4169e1\"><b>Session&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务端根据秘钥生成<font color=\"#4169e1\"><b>Token</b></font>，浏览器保存token，服务端只需要通过秘钥<font color=\"#4169e1\"><b>验证</b></font><b style=\"color: rgb(65, 105, 225);\">Token</b><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b style=\"color: rgb(65, 105, 225);\">-&nbsp;三次握手：</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </b>1.Client 发送连接请求报文</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.Serve 接受连接回复ACK报文，并分配计算资源</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.Client 接受报文再次发送ACK报文（TCP连接建立）</div><div><div>&nbsp; &nbsp; 网络层（封装IP首部）</div><div>&nbsp; &nbsp; 链路层（封装以太网首部）</div><div>&nbsp; &nbsp; 物理层</div><div><br></div><div><font color=\"#ff0000\"><b>服务器处理请求</b></font></div><div><br></div><div><b><font color=\"#ff0000\">浏览器端渲染页面</font></b></div><div><br></div><div><b><font color=\"#ff0000\">参考文章</font></b></div><div>&nbsp; &nbsp; 1.你所不知道的 HSTS：Strict Transport Security</div><div>&nbsp; &nbsp; &nbsp; &nbsp; https://www.barretlee.com/blog/2015/10/22/hsts-intro/<br></div></div><div>&nbsp; &nbsp; 2.Web服务器、应用程序服务器、HTTP服务器区别</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://zhuanlan.zhihu.com/p/58917525</div><div>&nbsp; &nbsp; 3.在浏览器输入 URL 回车之后发生了什么（超详细版）</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://zhuanlan.zhihu.com/p/80551769</div><div>&nbsp; &nbsp;&nbsp;一个HTTP打趴80%面试者</div><div>&nbsp; &nbsp; https://zhuanlan.zhihu.com/p/70949908</div></div></div>"
    },
    "VHe__CRq-": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "VHe__CRq-",
      "name": "内建对象",
      "content": "<div><font color=\"#ff0000\" style=\"font-weight: bold;\">*&nbsp;String&nbsp;</font><font color=\"#4169e1\" style=\"\"><b>Symbol</b></font><font style=\"\"><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp;Array&nbsp;</font><font color=\"#4169e1\" style=\"\"><b>Set</b></font><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp;</font></font>Number Boolean Date Math RegExp</div><div><font color=\"#4169e1\"><b><font style=\"\">* </font>Map Promise</b></font><br></div><div><font color=\"#4169e1\"><b>------------------------------------------------------------------------------------</b></font></div><div><b style=\"color: rgb(255, 0, 0);\">String</b><br></div><div><div>&nbsp; &nbsp; 合并：concat()</div><div>&nbsp; &nbsp; 截取</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>slice(statr, end之前)</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>substring(statr, end之前)</div><div>&nbsp; &nbsp; 首个下标：indexOf()/lastIndexOf()</div><div>&nbsp; &nbsp; 指定下标：charAt()</div><div>&nbsp; &nbsp; #</div><div>&nbsp; &nbsp; 新字符串：String(ins): String</div><div>&nbsp; &nbsp; 新字符串：Object.toString(): 返回新字符串, undefined/null 报错</div><div>&nbsp; &nbsp; 带分隔符的数组<span style=\"white-space: pre;\">\t</span>split(分隔符)</div><div><span style=\"white-space: pre;\">\t</span>#</div><div>&nbsp; &nbsp; match()<span style=\"white-space: pre;\">\t</span>找到一个或多个正则表达式的匹配。</div><div>&nbsp; &nbsp; replace()<span style=\"white-space: pre;\">\t</span>替换与正则表达式匹配的子串。</div><div>&nbsp; &nbsp; search()<span style=\"white-space: pre;\">\t</span>检索与正则表达式相匹配的值。</div></div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Symbol</b></font></div><div><div><div><span style=\"white-space: pre;\">\t</span>* 标识唯一的值 - 解决：字符串不具有唯一性</div><div><span style=\"white-space: pre;\">\t</span>应用1.常量声明 const NAME = Symbol('name')</div><div><span style=\"white-space: pre;\">\t</span>应用2.键声明</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Symbol.for('tar'):全局搜索/若无则新建</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Symbol.keyFor('tar'):全局键搜索</div></div><div><br></div><div><div>&nbsp; &nbsp; Object - key只能是 Symbol/String</div><div><span style=\"white-space: pre;\">\t</span>增加1/修改/查询 obj.key = new</div><div><span style=\"white-space: pre;\">\t</span>增加2 Object.assign(target, source) // 潜拷贝/拷贝了引用</div><div><span style=\"white-space: pre;\">\t</span>删除 delete obj.key</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>数组 Object.keys(obj)</div><div><span style=\"white-space: pre;\">\t</span>键数组 Object.keys(obj)</div><div><span style=\"white-space: pre;\">\t</span>值数组 Object.values(obj)</div><div><span style=\"white-space: pre;\">\t</span>值键对二维数组 Object.entries(obj)</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span># 由于不同的浏览器引擎采用的规范可能不同，所以输出的顺序也就不一样</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>for(let e in obj){ console.log(obj[e]) }</div><div>&nbsp; &nbsp; 迭代器</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Symbol.iterator</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span># 判断对象为空 JSON.stringfy()==={} || Object.keys(obj).length===0</div></div></div><div><br></div><b style=\"color: rgb(255, 0, 0);\">Array</b><div><div>&nbsp; &nbsp; shift()<span style=\"white-space: pre;\">\t</span>删除并返回数组的第一个元素</div><div>&nbsp; &nbsp; pop()<span style=\"white-space: pre;\">\t</span>删除并返回数组的最后一个元素</div><div>&nbsp; &nbsp; push()<span style=\"white-space: pre;\">\t</span>向数组的末尾添加一个或更多元素，并返回新的长度</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 合并：A.concat(B)</div><div>&nbsp; &nbsp; 截取 slice(start, end之前)</div><div>&nbsp; &nbsp; 替换 splice(start, 删除num个数, '新元素')</div><div>&nbsp; &nbsp; 带分隔符的字符串：join(分隔符)</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 排序：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; reverse()<span style=\"white-space: pre;\">\t</span>颠倒数组中元素的顺序</div><div>&nbsp; &nbsp; &nbsp; &nbsp; sort(compare) 默认排序顺序是根据字符串UniCode码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 需要传参 function compare(start,end){ return start-end // 升序 }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 对象排序</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function compare(e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return function(start,end){ return start[e]-end[e] }}</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>arr.forEach(function(item,index,thisArr){ console.log(item) })</div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Set</b></font></div><div><div><span style=\"white-space: pre;\">\t</span>新建 new Set(Array/String) // 数组去重</div><div><span style=\"white-space: pre;\">\t</span>增加 set.add(value)</div><div><span style=\"white-space: pre;\">\t</span>长度 size</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>数组 let arr = [...set]</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>并集 new Set([...a, ...b])</div><div><span style=\"white-space: pre;\">\t</span>交集 new Set([...a].filter(x =&gt; b.has(x)))</div><div><span style=\"white-space: pre;\">\t</span>差集 new Set([...a].filter(x =&gt; !b.has(x)))</div></div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Map</b></font></div><div><div><span style=\"white-space: pre;\">\t</span>新建 new Map(二维数组)</div><div><span style=\"white-space: pre;\">\t</span>增加 map.set(key,value)</div><div><span style=\"white-space: pre;\">\t</span>删除 map.delete(key)</div><div><span style=\"white-space: pre;\">\t</span>克隆/合并 new Map(oldMap)</div><div><span style=\"white-space: pre;\">\t</span>长度 size</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>键数组 map.keys(map)</div><div><span style=\"white-space: pre;\">\t</span>值数组 map.values(map)</div><div><span style=\"white-space: pre;\">\t</span>值键对二维数组 Array.from(map)</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span># 按插入顺序输出</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>for(let [key, value] of map){}</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>forEach( function(value,key){}, map)</div></div></div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Promise</b></font></div>"
    },
    "KqmE746O6": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "bookId": "KqmE746O6",
      "name": "常用",
      "content": "<div><div><b><font color=\"#ff0000\">常用样式</font></b></div><div><span style=\"white-space: pre;\">\t</span>行内块元素</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; display:inline-block</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; 水平对齐 vertical-align: top</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; 间隙 font-size: 0</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 背景透明:</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;opacity：0~1：所有&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rgba(x,y,z,0~1)：单独</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <font color=\"#4169e1\"><b>行内换行</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 换行符无效 / 多个空格会被合并为一个 / 句子自动换行 / 单词超出边界</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; word-wrap: break-word</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 行内裁剪:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; white-space: nowrap;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text-overflow: ellipsis;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overflow: hidden;</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; 背景图像</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1. 设置背景图: background-image: url(../img/a.jpg)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2. 控制xy重复: background-repeat: repeat-x/y / no repeat</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3. 铺满屏幕：background-size:cover/num%</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4. 固定不动：background-attachment: fixed;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>Overflow</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visible<span style=\"white-space: pre;\">\t</span>默认值。内容不会被修剪，会呈现在元素框之外。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hidden<span style=\"white-space: pre;\">\t</span>内容会被修剪，并且其余内容是不可见的。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scroll<span style=\"white-space: pre;\">\t</span>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto<span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</div></div><div><br></div><div><font color=\"#ff0000\"><b>选择器</b></font></div><div><span style=\"white-space: pre;\">\t</span>1.优先级: 行内&gt; #ID选择器 &gt; .类+伪类选择器/属性选择器 &gt; 元素选择器 &gt; *通用 &gt; 继承</div><div><span style=\"white-space: pre;\">\t</span>2.语法:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 多选择器: A，B，C</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 前/后/后所有：a -+~ b</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 仅仅子：A &gt; a</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.伪类</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :link 未访问&nbsp;:visited 已访问&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :active&nbsp;点击&nbsp;:hover 鼠标放入 :focus 文本框输入时 :selection 文本鼠标选中时候</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ::before/after 文字前/后&amp;标签之间 { content:\"\" }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p:first-child p:nth-child(index):任意位置子元素&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p:first-of-type:第一个p</div><div><br></div><div><br></div><div><br></div><div>transform</div><div>&nbsp; &nbsp; 平移：transform: translate(X,Y)</div><div>&nbsp; &nbsp; 旋转：transform-origin:x y：旋转基点</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform: rotate(30deg)</div><div>&nbsp; &nbsp; 放缩：transform: scale(X,Y);//倍数</div><div>&nbsp; &nbsp; 3D旋转：transform: rotateX/Y(120deg)</div><div>&nbsp; &nbsp;&nbsp;</div><div>*********************************************************************</div><div>transition</div><div>&nbsp; &nbsp; 1.为指定属性(时长)添加过渡效果：transition: width 2s,height 1s...</div><div>&nbsp; &nbsp; 2.指定属性绑定事件监听：div:hover {width...height...}</div><div>&nbsp; &nbsp; # transition: all 1s + css组合</div><div>&nbsp; &nbsp;&nbsp;</div><div>*********************************************************************</div><div>复杂</div><div>&nbsp; &nbsp; 1.animation:name 1s 时间函数 开始时间 次数();</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>ease:慢快慢/linear:匀速</div><div>&nbsp; &nbsp; 2.@keyframes name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 0% {background:red;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 100% {background:green;}}</div><div>支持</div><div><span style=\"white-space: pre;\">\t</span>-webkit- Chrome:IOS/-moz- firefox/</div>"
    },
    "cvuzjh6fr": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "bookId": "cvuzjh6fr",
      "name": "布局",
      "content": "<div><font color=\"#ff0000\"><b>Position定位（默认&nbsp;static&nbsp;且&nbsp;z-index&nbsp;无效</b></font><b style=\"color: rgb(255, 0, 0);\">）</b><br></div><div>&nbsp; &nbsp; 1 文档流:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; relative：相对于原位置移动</div><div>&nbsp; &nbsp; 2 脱离文档流：</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>absolute：相对relative移动,会提升层级</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 脱离文档流而产生的高度塌陷 &amp; 相邻|垂直|内外边距重叠</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以通过添加块元素解决,清除因浮动产生的移动影响</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .clearfix:before,.clearfix:after</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {content:\"\";display:table;clear:both;}</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>float：会产生挤压</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>fixed：相对于可视界面移动,会提升层级</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div><font color=\"#ff0000\"><b>弹性盒子</b></font></div><div><span style=\"white-space: pre;\">\t</span>1.容器设置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex | inline-flex</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.容器属性</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-direction：row | row-reverse | column | column-reverse</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-wrap：nowrap | wrap | wrap-reverse</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-flow:&nbsp; &nbsp;row nowrap</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>横轴对齐&nbsp;</b></font>justify-content:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>flex-start<font color=\"#4169e1\"><b>(默认)</b></font>&nbsp;/ flex-end / center / space-between /&nbsp;space-around</div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>纵轴对齐&nbsp;</b></font>align-items:&nbsp;<div><span style=\"white-space: pre;\">\t\t</span>flex-start / flex-end / center / baseline(<font color=\"#4169e1\"><b>按文字对齐</b></font>) / stretch<font color=\"#4169e1\"><b>(默认：高度占满)</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 多横轴对齐&nbsp;</b></font>align-content:&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp; flex-start / flex-end / center / space-between / space-around / stretch<b style=\"color: rgb(65, 105, 225);\">(默认：高度占满)</b></div><div><span style=\"white-space: pre;\">\t\t</span># 子元素 float/clear/vertical-align 会失效</div><div><span style=\"white-space: pre;\">\t</span><font color=\"#4169e1\"><b>3.容器内容设置</b></font></div><div><span style=\"white-space: pre;\">\t\t</span>1. order: 值越小越靠前/默认 0</div><div><span style=\"white-space: pre;\">\t\t</span>2. flex: (占比) none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</div><div><span style=\"white-space: pre;\">\t\t</span>3. align-self: 单独设置 align-items 个性的对齐</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp; 4. margin-?:auto 会获取剩余所有空白</div><div><br></div><div><b><font color=\"#ff0000\">移动端适配&nbsp;</font></b></div><div>&nbsp; &nbsp; 主要通过媒体查询&nbsp;<font color=\"#4169e1\"><b>@media</b></font>&nbsp;为不同设备设计不同样式<br></div><div>&nbsp; &nbsp; 通常需要用meta定义了浏览器宽度 = 设备宽度</div><div>&nbsp; &nbsp; &lt;meta name='viewport' content= 'width=device-width, initial-scale=1.0'&gt;</div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; 百分比布局</b></font></div><div><span style=\"white-space: pre;\">\t</span>- 为不同设备编写不同的CSS样式文件</div><div><span style=\"white-space: pre;\">\t</span>- 宽度默认 100%; - 但是字体可能会模糊</div><div><b><font color=\"#4169e1\">&nbsp; &nbsp; Rem布局</font></b></div><div><span style=\"white-space: pre;\">\t</span># 像素设备比 -DPR -表示1个css像素对应（覆盖）的物理像素个数</div><div><span style=\"white-space: pre;\">\t</span># HTML 默认font-size:16px / 下面动态设置HTML字体</div><div><br></div><div><div><font color=\"#ff0000\"><b>//动态设置页面根字体</b></font></div><div>(function(doc, win) {</div><div>&nbsp; //1.找到HTML页面根结点</div><div>&nbsp; let html = doc.getElementsByTagName(\"html\")[0],</div><div>&nbsp; &nbsp; //2.设置全局事件 = 屏幕发生改变事件</div><div>&nbsp; &nbsp; reEvt = \"orientationchange\" in win ? \"orientationchange\" : \"resize\", //转屏/缩放</div><div>&nbsp; &nbsp; //3.设置回调函数</div><div>&nbsp; &nbsp; reFontSize = function() {</div><div>&nbsp; &nbsp; &nbsp; var clientW = doc.documentElement.clientWidth || doc.body.clientWidth; //当前屏幕宽度</div><div>&nbsp; &nbsp; &nbsp; if (!clientW) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; // 设计稿/字体 = 1920px/16px = 屏幕宽/1rem</div><div>&nbsp; &nbsp; &nbsp; let rem = (clientW * 15) / 1920;</div><div>&nbsp; &nbsp; &nbsp; rem = rem &lt; 12 ? 12 : rem;</div><div>&nbsp; &nbsp; &nbsp; html.style.fontSize = rem + \"px\";</div><div>&nbsp; &nbsp; };</div><div>&nbsp; //5.全局添加事件监听(全局事件/回调)</div><div>&nbsp; win.addEventListener(reEvt, reFontSize);</div><div>&nbsp; //6.DOMContentLoaded-&gt;dom加载完就执行,onload要dom/css/js都加载完才执行</div><div>&nbsp; doc.addEventListener(\"DOMContentLoaded\", reFontSize);</div><div>})(document, window);</div></div><div><div><font color=\"#ff0000\"><b><br></b></font></div><div><font color=\"#ff0000\"><b>常用的居中方式</b></font></div><div>&nbsp; &nbsp; 1 水平居中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; margin:0 auto&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (行内)text-align:center</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; justify-content: center;</div><div>&nbsp; &nbsp; 2 垂直居中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (单行内)line-height</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>(多行)display:table-cell; vertical-align: middle;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; align-items: center;</div><div>&nbsp; &nbsp; 3 同时对齐</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ab+re定位：trbl:0; margin:auto;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; top/left：50%; transform(-50%,-50%)/margin-l/r:-50%;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; justify-content: center; align-items: center;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;<font color=\"#4169e1\"><b>&nbsp;(弹性盒)display: flex; margin:auto;</b></font></div></div>"
    },
    "0IlRbC42H": {
      "blockId": "D2S51gJkH",
      "shelfId": "hOBITMJvI",
      "bookId": "0IlRbC42H",
      "name": "网站开发",
      "content": ""
    },
    "vpouL20lY": {
      "blockId": "D2S51gJkH",
      "shelfId": "hOBITMJvI",
      "bookId": "vpouL20lY",
      "name": "移动端开发",
      "content": ""
    },
    "2MTuHMBRu": {
      "blockId": "D2S51gJkH",
      "shelfId": "hOBITMJvI",
      "bookId": "2MTuHMBRu",
      "name": "客户端",
      "content": ""
    },
    "C15wxTq5Q": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "C15wxTq5Q",
      "name": "应用生态圈",
      "content": "<div><font color=\"#ff0000\"><b>1.传统网站开发</b></font><br></div><div><br></div><div><div>&nbsp; &nbsp; 通常是一套代码进行样式适配，再部署到 PC / Mobile&nbsp;不同平台，最后通过浏览器软件进行访问 &nbsp;&nbsp;</div><div><br><div><font color=\"#ff0000\"><b>2.移动端开发</b></font></div><div><br></div><div>&nbsp; &nbsp; Native APP (原生APP)</div><div>&nbsp; &nbsp; - Android：Java / IOS：Object-C/Swift&nbsp;等</div><div><br></div><div>&nbsp; &nbsp; Hybrid APP (混合开发)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 是一种用Native技术来搭建本地Web环境，内容主要通过Web技术来提供的移动应用</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;主要开发技术</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Uni-App：自研Wxs技术降低视图层与语言引擎通信耗损</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - React-Native：JavaScript引擎，不同平台需要不同UI</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Flutter：Dart引擎，是纯粹的渲染引擎，简单、高性能，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 但由于Dart语法使得维护性/代码可读性很差，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不支持动态热更新，不同平台需要不同UI</div></div><div><br></div><div><font color=\"#ff0000\"><b>3.客户端开发</b></font></div><div>&nbsp; &nbsp; Electron（@github）原来叫 Atom Shell</div></div><div><br></div><div><font color=\"#ff0000\"><b>参考文章</b></font></div><div>&nbsp; &nbsp; Flutter、React-Native、Uni-App比较：https://ask.dcloud.net.cn/article/36083</div>"
    },
    "0E0vp5ETT": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "0E0vp5ETT",
      "name": "ES6 与 黑魔法",
      "content": "<div><font color=\"#ff0000\"><b>ES6</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>&nbsp;1.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 用 var 声明的变量，在全局范围内有效</div><div>&nbsp; &nbsp; &nbsp; &nbsp; let 声明的变量</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 只在 let 命令所在的代码块内有效</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 不存在预处理:会产生报错</div><div>&nbsp; &nbsp; &nbsp; &nbsp; const 声明一个只读的常量，一旦声明，常量的值就不能改变。</div><div>&nbsp; &nbsp; 2.箭头函数</div><div>&nbsp; &nbsp; 3.export import&nbsp;模块化&nbsp;严格模式</div><div><br></div><div><font color=\"#ff0000\"><b>黑魔法</b></font></div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>闭包产生</b></font></div><div><span style=\"white-space: pre;\">\t</span>1.有嵌套的内部函数</div><div><span style=\"white-space: pre;\">\t</span>2.内部函数调用了外部函数的变量</div><div><span style=\"white-space: pre;\">\t</span>3.内部函数被外部变量引用</div><div><span style=\"white-space: pre;\">\t</span>3.外部变量执行，即内部函数执行(闭包产生)</div><div><span style=\"white-space: pre;\">\t</span># 闭包就是外部函数执行结束前，调用的变量集合</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 闭包不被销毁的根本原因是</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 外部变量没被销毁=内部函数没被销毁=外部函数没被销毁</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 外部变量是在内部函数预加载时被引用的 = 闭包产生</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 预加载的原因是因为内存执行</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>闭包用途</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.匿名函数自调用,把相关数据暴露给window.模块名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.可以根据模块名直接使用相关数据</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function foo() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>var x = 3;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function a(){return x++;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>return a;</div><div><span style=\"white-space: pre;\">\t\t</span>}</div><div><span style=\"white-space: pre;\">\t\t</span>var m = foo();</div><div><span style=\"white-space: pre;\">\t\t</span># 全局引用foo(已经执行)/导致函数a不消失/导致变量x不消失</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>函数防抖</b></font></div><div><span style=\"white-space: pre;\">\t</span>短时间内连续触发事件，回调只能执行最后一次。</div><div><span style=\"white-space: pre;\">\t</span>const debounce = (func, wait) =&gt; {</div><div><span style=\"white-space: pre;\">\t\t</span>let timer;</div><div><span style=\"white-space: pre;\">\t\t</span>return () =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clearTimeout(timer);//触发事件会先清空计时器,再重新启动</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timer = setTimeout(func, wait);};};//所以只有wait秒后才执行回调</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>函数节流</b></font></div><div><span style=\"white-space: pre;\">\t</span>事件触发后,执行回调，一定时间后才能继续触发</div><div><span style=\"white-space: pre;\">\t</span>const throttle = (func, wait) =&gt; {</div><div><span style=\"white-space: pre;\">\t\t</span>let timer;</div><div><span style=\"white-space: pre;\">\t\t</span>return () =&gt; {</div><div><span style=\"white-space: pre;\">\t\t\t</span>if (timer) {return;}//连续触发事件判断计时器是否执行</div><div><span style=\"white-space: pre;\">\t\t\t</span>timer = setTimeout(()=&gt;{</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>func();</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>timer = null;</div><div><span style=\"white-space: pre;\">\t\t\t</span>}, wait);};};//wait秒后执行回调</div></div>"
    },
    "1RuCkBR9n": {
      "blockId": "i9hSICf-d",
      "shelfId": "yh3_WkVTX",
      "bookId": "1RuCkBR9n",
      "name": "政治学",
      "content": ""
    },
    "6EFwwNv4k": {
      "blockId": "i9hSICf-d",
      "shelfId": "yh3_WkVTX",
      "bookId": "6EFwwNv4k",
      "name": "高等数学",
      "content": ""
    },
    "-FgvDAmIt": {
      "blockId": "i9hSICf-d",
      "shelfId": "yh3_WkVTX",
      "bookId": "-FgvDAmIt",
      "name": "线性代数",
      "content": ""
    },
    "rRm3lRpnw": {
      "blockId": "i9hSICf-d",
      "shelfId": "yh3_WkVTX",
      "bookId": "rRm3lRpnw",
      "name": "计算机组成原理",
      "content": ""
    },
    "1VfoIBILF": {
      "blockId": "i9hSICf-d",
      "shelfId": "yh3_WkVTX",
      "bookId": "1VfoIBILF",
      "name": "数据结构与算法",
      "content": ""
    },
    "88cPLJE47": {
      "blockId": "i9hSICf-d",
      "shelfId": "yh3_WkVTX",
      "bookId": "88cPLJE47",
      "name": "计算机网络",
      "content": ""
    },
    "QWhDBor0S": {
      "blockId": "i9hSICf-d",
      "shelfId": "yh3_WkVTX",
      "bookId": "QWhDBor0S",
      "name": "操作系统",
      "content": ""
    },
    "F26qigpbB": {
      "blockId": "D2S51gJkH",
      "shelfId": "EQ6DOslPu",
      "bookId": "F26qigpbB",
      "name": "数学分析(计算)",
      "content": ""
    },
    "N-vWQ1XzF": {
      "blockId": "D2S51gJkH",
      "shelfId": "EQ6DOslPu",
      "bookId": "N-vWQ1XzF",
      "name": "线性代数",
      "content": ""
    },
    "NOmTANnM7": {
      "blockId": "D2S51gJkH",
      "shelfId": "EQ6DOslPu",
      "bookId": "NOmTANnM7",
      "name": "统计学",
      "content": ""
    },
    "QAJuezBx7": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "QAJuezBx7",
      "name": "服务器部署",
      "content": "<div>0.常用工具</div><div>&nbsp; &nbsp;&nbsp;Xftp / Xshell</div><div>1.常见服务器装配（运维）</div><div>&nbsp; &nbsp; * OS：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Windows</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - linux内核：Cento /&nbsp;Ubuntu</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Unix内核：...垄断着大型企业的关键性应用领域</div><div>&nbsp; &nbsp; *&nbsp;服务器程序：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Web/HTTP：只需支持HTTP协议（Tomcat，Windows IIS，Apache，Nginx）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 特定应用：支持各种协议并提供服务（<span style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px;\">BEA&nbsp;</span>Weblogic，<span style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px;\">IBM&nbsp;</span>WebSphere）</div>"
    },
    "bX3_6yxdn": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "bookId": "bX3_6yxdn",
      "name": "计算机组成原理",
      "content": "1.计算机发展史<div>&nbsp; &nbsp; * 人力计算：computer 过去指专门从事计算大数字的从业人员（让优秀的人浪费时间算数简直侮辱尊严）</div><div>&nbsp; &nbsp; * 查询计算：变量表 计算统计并记录出常用的数字</div><div>&nbsp; &nbsp; * 机器计算： 通用计算机概念：希望机器能可编程地，自动完成一系列计算操作</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 巨大/计算速度缓慢 “继电器01”的计算机诞生</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 更快的“三级真空管01”计算机诞生</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 现代化的迷你的“晶体管 - <font color=\"#4169e1\"><b>半导体</b></font>材料”计算机诞生</div><div><br></div><div>2.计算机数学：<font color=\"#4169e1\"><b>布尔代数</b></font></div><div>&nbsp; &nbsp; * 通过电路逻辑，来实现计算机的二进制计数，8位（bit）电路能代表2^8个值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 由于常用则另称<font color=\"#4169e1\"><b>（1byte）字节</b></font>，1024byte 表示 1kb</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 浮点数：1*正负 + 8*值存位 + 23*有效数位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 文字：1967 ASCII，1992 Unicode&nbsp;</div><div><br></div><div>3.机器计算：使用逻辑门电路来将“输入逻辑”转换为“输出逻辑”</div><div>&nbsp; &nbsp; * <font color=\"#ff0000\"><b>ALU</b></font>：计算机的核心计算组件</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 计算单元：输出值逻辑 / 逻辑单元：输出判断逻辑</div><div>&nbsp; &nbsp; * 存储计算结果</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - <font color=\"#ff0000\"><b>寄存器</b></font>：临时保存计算结果</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 多个寄存器实现的较大数字的存储，即 <font color=\"#ff0000\"><b>RAM（随时访问任何位置的数值）</b></font></div><div>&nbsp; &nbsp; * <font color=\"#ff0000\"><b>CPU</b></font>&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Center Processor Unit</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 通过不同寄存器&nbsp;<font color=\"#4169e1\"><b>读取 - 解码 - 执行&nbsp;</b></font>已设置好的指令（实现与ALU的计算 或者 与RAM的读写）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 通过“时钟”精准触发电信号/Hz，不断执行上述<font color=\"#4169e1\"><b>指令循环</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; * 更快的计算</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 现代CPU有专门电路来处理图形、视频等</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 更快地操作数据：通过 <font color=\"#ff0000\"><b>Cache</b></font> 缓存存储常用指令、值等</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 并行处理 <font color=\"#4169e1\"><b>指令循环&nbsp;</b></font>指令循环，最终使得在固定时间内执行最多的指令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 多核处理器：一个CPU中有多个独立处理单元共享数据，合作运算</div><div><br></div><div>4.编程</div><div>&nbsp; &nbsp; * 可编程的计算：存储程序式计算机（冯·诺依曼结构）</div><div>&nbsp; &nbsp; * 输入输出设备</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 早期的卡片IO - 插线式IO - 语言式IO</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - CPU汇编语言 + <font color=\"#ff0000\"><b>汇编器</b></font>&nbsp;= 机器码（二进制）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - <font color=\"#ff0000\"><b>编译器+高级语言</b></font>&nbsp;= 机器码 或者 汇编语言</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 1960 BASIC - 1970 C - 1980 C++ - 1990 Python/Ruby/Java - 2000 C#/Go</div><div>&nbsp; &nbsp; &nbsp;* 高级语言特性</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 变量 / 流程 / 函数 / 对象（都是为了更少的代码，及更高效的软件工程）</div><div><br></div><div>5.操作系统</div><div>&nbsp; &nbsp; - 商用 unix</div><div>&nbsp; &nbsp; - 个人 windows</div>"
    },
    "z3wQ7yD2W": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "bookId": "z3wQ7yD2W",
      "name": "数据结构",
      "content": "<div>字符串</div><div><br></div>数组（列表/向量）：连续地按顺序存储（不易插入）<div>链表（不易查找）</div><div>&nbsp; &nbsp; - 栈</div><div>&nbsp; &nbsp; - 队列</div><div><br></div><div>树（一般只需要知道根结点）</div><div>图</div>"
    },
    "WCkUirgKr": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "bookId": "WCkUirgKr",
      "name": "算法",
      "content": "<div><font color=\"#4169e1\"><b>计数与进制</b></font></div><div>&nbsp; &nbsp; 十进制：1024 = 10^3(1) + 10^2(0) +&nbsp;10^1(2) +&nbsp;1(4)</div><div>&nbsp; &nbsp; 二进制：1024 = 2^3(1) + 2^2(0) + 2^1(2)+ 1(4)</div><div><br></div><div><font color=\"#4169e1\"><b>函数防抖 debounce</b></font></div><div>&nbsp; &nbsp; <b>短时间内连续触发事件，回调只执行最后一次，多次触发会导致重新计时</b></div><div>&nbsp; &nbsp; const debounce = (func, wait) =&gt; {</div><div><span style=\"white-space: pre;\">\t</span>let timer;</div><div><span style=\"white-space: pre;\">\t</span>return () =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clearTimeout(timer);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timer = setTimeout(func, wait);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; };</div><div>&nbsp; &nbsp; };</div><div><br></div><div><font color=\"#4169e1\"><b>函数节流&nbsp;throttle</b></font></div><div>&nbsp; &nbsp; <b>事件触发后,执行回调，一定时间后才能继续触发</b></div><div>&nbsp; &nbsp; const throttle = (func, wait) =&gt; {</div><div><span style=\"white-space: pre;\">\t</span>let timer;</div><div><span style=\"white-space: pre;\">\t</span>return () =&gt; {</div><div><span style=\"white-space: pre;\">\t\t</span>if (timer) {return;}//连续触发事件判断计时器是否执行</div><div><span style=\"white-space: pre;\">\t\t</span>timer = setTimeout(()=&gt;{</div><div><span style=\"white-space: pre;\">\t\t\t</span>func();</div><div><span style=\"white-space: pre;\">\t\t\t</span>timer = null;</div><div><span style=\"white-space: pre;\">\t\t</span>}, wait);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; };</div><div>&nbsp; &nbsp; };</div>"
    },
    "8rtY2uyPH": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "bookId": "8rtY2uyPH",
      "name": "计算机网络",
      "content": "局域网 LAN 概念&nbsp;<div>&nbsp; &nbsp; - 以太网技术：一条以太网线连接多台计算机（MAC地址）</div><div>广域网 WAN 概念</div><div>&nbsp; &nbsp; - 服务商 ISP 管理</div><div>&nbsp; &nbsp; - 数据包传输协议（IP）根据IP地址负责找到正确的计算机</div><div>&nbsp; &nbsp; - 更多应用协议（UDP/TCP）负责送到正确的程序</div>"
    },
    "Jfy5VUGYK": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "bookId": "Jfy5VUGYK",
      "name": "操作系统",
      "content": ""
    },
    "RU7BW4wn7": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "bookId": "RU7BW4wn7",
      "name": "设计模式",
      "content": "<div><font color=\"#ff0000\"><b>* 原则</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font><font color=\"#4169e1\"><b>单一职责原则</b></font> * 一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; </b></font><font color=\"#4169e1\"><b>开闭原则</b></font> *&nbsp;在程序需要进行拓展的时候，不能去修改原有的代码</div><div>&nbsp; &nbsp; 里氏代换原则 *&nbsp;任何基类可以出现的地方，子类一定可以出现</div><div>&nbsp; &nbsp; 依赖倒转原则 *&nbsp;针对接口编程，依赖于抽象而不依赖于具体（啥玩意？）</div><div>&nbsp; &nbsp; 接口隔离原则 *&nbsp;使用多个隔离的接口，比使用单个接口要好</div><div>&nbsp; &nbsp; 最少知道原则 *&nbsp;一个实体应当尽量少地与其他实体之间发生相互作用</div><div>&nbsp; &nbsp; 合成复用原则 *&nbsp;尽量使用合成/聚合的方式，而不是使用继承</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>面向对象的三大原则</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;封装：隐藏对象的属性，仅对外公开行为</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;继承：抽取共有特征和方法形成高一层的super类</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;多态：同一个处理手段可以用来处理多种不同的情况</div><div><br></div><font color=\"#ff0000\"><b>1.创建型</b></font><div><div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>单例模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 保证一个类仅有一个 Singleton&nbsp;实例，并提供一个访问它的全局访问点。</div></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>原型模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;通过拷贝原型对象创建新的相同 Prototype 对象</div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>工厂模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * Factory（日志生成器）=&gt; Production（错误日志）</div><div>&nbsp; &nbsp;&nbsp;<b style=\"color: rgb(65, 105, 225);\">抽象工厂模式</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * AbstructFactory（皮肤器）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ** AFactory（皮肤色生成器）=&gt; AProduction（皮肤色）</div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ** BFactory（皮肤材质生成器）=&gt; BProduction（皮肤材质）</div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>建造者模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * Builder（点餐机）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ** AFactory（汉堡生成器）=&gt; AProduction（汉堡）</div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ** BFactory（可乐生成器）=&gt; BProduction（可乐）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt; Production（套餐：可乐+汉堡）</div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">2.结构型</b></div><div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>适配器模式&nbsp;</b></font></div></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 视频播放器</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ** Adapter（内嵌振动器）=&gt;&nbsp;实现了振动功能的视频播放器</div><div>&nbsp; &nbsp; <font color=\"#ff0000\"><b>桥接模式 ？</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;对于两个独立变化的维度&nbsp;似乎和抽象工厂模式高度相似</div><div>&nbsp; &nbsp; <font color=\"#4169e1\" style=\"\"><b>过滤器模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * Filter（考试筛选）=&gt; Target（及格的孩子）</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>组合模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;Node（结点）=&gt; Tree（树）</div><div>&nbsp; &nbsp; <font color=\"#4169e1\" style=\"\"><b>装饰器模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * A（牛奶）=&gt; * DecoratorA（牛奶带糖）</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>外观模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;其实就是“封装”，不暴露实现细节只提供实现方法</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>享元模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 第一次查询创建对象，后续查询返回相同对象（已缓存）</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>代理模式</b></font></div>&nbsp; &nbsp; &nbsp; &nbsp; * =&gt; Target（火车票）<div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;Proxy（代售点） =&gt; Target（火车票）</div><div><b style=\"color: rgb(255, 0, 0);\">3.行为型</b></div><div><div>&nbsp; &nbsp; 责任链模式</div></div><div>&nbsp; &nbsp; 命令模式</div><div>&nbsp; &nbsp; 解释器模式</div><div>&nbsp; &nbsp; 迭代器模式</div><div>&nbsp; &nbsp; 中介模式</div><div>&nbsp; &nbsp; 备忘录模式</div><div>&nbsp; &nbsp; 观察者模式</div><div>&nbsp; &nbsp; 状态模式</div><div>&nbsp; &nbsp; 空对象模式</div><div>&nbsp; &nbsp; 策略模式</div><div>&nbsp; &nbsp; 模板模式</div><div>&nbsp; &nbsp; 访问者模式</div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">4.J2ee型</b></div><div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>MVC模式</b></font></div></div><div>&nbsp; &nbsp; 业务代表模式</div><div>&nbsp; &nbsp; 组合实体模式</div><div>&nbsp; &nbsp; 数据访问对象模式</div><div>&nbsp; &nbsp; 前端控制器模式</div><div>&nbsp; &nbsp; 拦截过滤器模式</div><div>&nbsp; &nbsp; 服务定位模式</div><div>&nbsp; &nbsp; 传输对象模式</div><div><br></div><div><br></div>"
    },
    "ou1_C-zXU": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "ou1_C-zXU",
      "name": "浏览器 DOM/BOM",
      "content": "<div><div><div><font color=\"#ff0000\"><b>服务器处理请求</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; </b></font>1.常见服务器装配（运维）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * OS：Windows / linux内核：Cento /&nbsp;Ubuntu / Unix内核：商用操作系统</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务器程序：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Web/HTTP：只需支持HTTP协议（Tomcat，Windows IIS，Apache，Nginx）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 特定应用：支持各种协议并提供服务（<span style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px;\">BEA&nbsp;</span>Weblogic，<span style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px;\">IBM&nbsp;</span>WebSphere）</div></div><div><br></div><div><b><font color=\"#ff0000\">浏览器端</font></b></div><div>&nbsp; &nbsp; 解压缩gzip资源 /&nbsp;资源缓存 /&nbsp;根据MIME类型解析内容</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>1.渲染引擎</b></font></div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font><b>#&nbsp;解析</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; #1 解码/构建 DOM 树 / CSS&nbsp;树</div><div>&nbsp; &nbsp; &nbsp; &nbsp; #2&nbsp;合并DOM/CSS树：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 计算DOM单位 /&nbsp;确定样式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 渲染阻塞：CSS 样式 &gt; Script脚本 &gt; DOM树</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b>#&nbsp;绘制</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; #4&nbsp;布局/绘制DOM结点到渲染层，合并渲染层</div><div>&nbsp; &nbsp; &nbsp; &nbsp; #5&nbsp;布局改变会导致<font color=\"#4169e1\" style=\"\"><b>回流</b></font>(成本高)，属性改变会导致<font color=\"#4169e1\" style=\"\"><b>重绘</b></font></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\" style=\"\"><b>2.JavaScript引擎</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 编译执行：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b>1.词法解析</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 得出抽象语法树（AST）并转换成机器指令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>&nbsp;2.预编译：</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;抽象JS内存环境：全局环境/函数环境/Eval</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;抽象JS内存环境内容：执行上下文</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>* 创建执行上下文（所谓的变量提升）</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 创建变量内存（变量/函数）&gt;&nbsp;建立作用域链 &gt;&nbsp;确定this指向当前执行上下文</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>3.执行&nbsp;</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*&nbsp;</b></font><b style=\"color: rgb(65, 105, 225);\">由于动态类型特性，相同代码可能由于类型不同/值更改而被重新编译：a=1/a=\"1\"）</b></div><div><b style=\"color: rgb(255, 0, 0);\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;事件循环执行顺序</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;常规代码 - 同步队列（宏任务）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Promise.then / process.nextTick - ES6/Node（微任务）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;浏览器事件 / 定时器 / HTTP异步请求进程 - 异步队列（异步任务）</div></div><div><br></div><font color=\"#ff0000\"><b>DOM</b></font><div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>基本常识</b></font></div><div><span style=\"white-space: pre;\">\t</span>页面以结点Node为基本组成单位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 文档结点(document)：9&nbsp; / 元素结点(标签)：1</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Attribute属性结点：2 / TextNode文字结点：3</div><div>&nbsp; &nbsp; &nbsp; &nbsp; document.element可以直接调用结点的基本属性</div><div>&nbsp; &nbsp; &nbsp; &nbsp; document.element.nodeName/nodeType/nodeValue:元素基本值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # innerHTML返回串中含标签/innerText不含标签</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>获取结点</b></font></div><div><span style=\"white-space: pre;\">\t</span>getElementById()</div><div><span style=\"white-space: pre;\">\t</span>getElementsByName/ClassName/TagName()：集合</div><div><span style=\"white-space: pre;\">\t</span># 必须在document下进行查找(TagName除外)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; querySelector(“css字符串”)：只会返回第一个符合结点</div><div>&nbsp; &nbsp; &nbsp; &nbsp; querySelectorAll(“css字符串”)：返回数组</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 父节点：parentNode</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 子结点：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first/last/parentElementChild</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; previous/nextElementSibling</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; children：集合</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hasChildNodes()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 以下查询有可能返回字符结点(如空白字符)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first/last/parentChild</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; previous/nextSibling</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childNodes</div><div>&nbsp; &nbsp;<font color=\"#4169e1\"><b> 编辑结点</b></font></div><div><span style=\"white-space: pre;\">\t</span>修改：createElement(\"\") / appendChild / insertBefore(新，旧)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 删除：e.parentNode.removeChild(e)：需要找出父元素</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 样式修改：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Window.getComputedStyle(node,null) : obj : 只读</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.currentStyle.样式//仅仅IE支持</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; .style.cssText = {display:bolck;...}</div><div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; 结点事件属性</b></font></div><div><font color=\"#4169e1\" style=\"font-weight: bold;\">&nbsp; &nbsp; &nbsp; &nbsp; </font><font color=\"#ff0000\"><b>绑定事件</b></font></div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp;- onclick / onscroll / onmouseover / onmousewheel(wheelDelta:滚动方向 )</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp;- 可以为DOM事件设置监听函数</div><div><span style=\"white-space: pre;\">\t</span>&nbsp;<span style=\"white-space: pre;\">\t</span>1. e.onclick = function(event){}</div><div><span style=\"white-space: pre;\">\t</span>&nbsp;<span style=\"white-space: pre;\">\t</span>2. target.addEventListener(\"onclick\",fun,是否在捕获阶段触发//0)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <font color=\"#ff0000\"><b>事件</b></font><b style=\"color: rgb(255, 0, 0);\">捕获/</b><b style=\"color: rgb(255, 0, 0);\">冒泡</b></div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; *&nbsp;捕获：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;需要手动开启</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 从文档的根结点 -&gt;&nbsp;目标结点：沿途触发所有存在的相同事件，建立传播途径</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;冒泡：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 从目标结点 -&gt;&nbsp;文档根结点：沿途触发所有存在的相同事件</div></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 阻止事件传播：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * event.stopPropagation()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * e.preventDefault()</div><span style=\"font-family: 宋体;\"></span><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * event.cancelBubble = true（IE）<div>&nbsp; &nbsp; &nbsp; &nbsp; <font color=\"#ff0000\"><b>事件委派</b></font>：</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; # 利用事件冒泡,只绑定一次监听函数</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.在共同父元素上设置响应函数</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 由于子元素和父元素有共同的响应事件，所以不用循环为子元素绑定监听函数</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.if(event.target.class==\"目标\"){监听函数}</div><div><br></div></div><div><font color=\"#ff0000\"><b>BOM</b></font></div></div><div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>window</b></font>：窗口/网页全局对象</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - <font color=\"#4169e1\"><b>Location：文档URL</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 定时器方法</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * setTimeout/setInterval(expression,time)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * clearTimeout/Interval(timer)</div></div><div><br></div><div><font color=\"#ff0000\"><b>HTML5 API</b></font></div><div><br></div><div><font color=\"#ff0000\"><b>参考文章</b></font></div><div>&nbsp; &nbsp;&nbsp;事件冒泡、事件捕获和事件委托</div><div>&nbsp; &nbsp; https://www.cnblogs.com/Chen-XiaoJun/p/6210987.html</div>"
    },
    "q0qmnV1l4": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "q0qmnV1l4",
      "name": "CSS 常用",
      "content": "<div><div><b><font color=\"#ff0000\">常用样式</font></b></div><div><span style=\"white-space: pre;\">\t</span>行内块元素</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; display:inline-block</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; 水平对齐 vertical-align: top</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; 间隙 font-size: 0</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 背景透明:</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;opacity：0~1：所有&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rgba(x,y,z,0~1)：单独</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>行内换行</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 换行符无效 / 多个空格会被合并为一个 / 句子自动换行 / 单词超出边界</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; word-wrap: break-word</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 行内裁剪:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; white-space: nowrap;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text-overflow: ellipsis;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overflow: hidden;</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; 背景图像</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1. 设置背景图: background-image: url(../img/a.jpg)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2. 控制xy重复: background-repeat: repeat-x/y / no repeat</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3. 铺满屏幕：background-size:cover/num%</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4. 固定不动：background-attachment: fixed;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>Overflow</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visible<span style=\"white-space: pre;\">\t</span>默认值。内容不会被修剪，会呈现在元素框之外。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hidden<span style=\"white-space: pre;\">\t</span>内容会被修剪，并且其余内容是不可见的。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scroll<span style=\"white-space: pre;\">\t</span>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto<span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</div></div><div><br></div><div><font color=\"#ff0000\"><b>选择器</b></font></div><div><span style=\"white-space: pre;\">\t</span>1.优先级: 行内&gt; #ID选择器 &gt; .类+伪类选择器/属性选择器 &gt; 元素选择器 &gt; *通用 &gt; 继承</div><div><span style=\"white-space: pre;\">\t</span>2.语法:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 多选择器: A，B，C</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 前/后/后所有：a -+~ b</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 仅仅子：A &gt; a</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.伪类</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :link 未访问&nbsp;:visited 已访问&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :active&nbsp;点击&nbsp;:hover 鼠标放入 :focus 文本框输入时 :selection 文本鼠标选中时候</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ::before/after 文字前/后&amp;标签之间 { content:\"\" }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p:first-child p:nth-child(index):任意位置子元素&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p:first-of-type:第一个p</div><div><br></div><div><font color=\"#ff0000\"><b>动画</b></font></div><div><font color=\"#4169e1\"><b>transform</b></font></div><div>&nbsp; &nbsp; 平移：transform: translate(X,Y)</div><div>&nbsp; &nbsp; 旋转：transform-origin:x y：旋转基点</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform: rotate(30deg)</div><div>&nbsp; &nbsp; 放缩：transform: scale(X,Y);//倍数</div><div>&nbsp; &nbsp; 3D旋转：transform: rotateX/Y(120deg)</div><div><br></div><div><font color=\"#4169e1\"><b>transition</b></font></div><div>&nbsp; &nbsp; 1.为指定属性(时长)添加过渡效果：transition: width 2s,height 1s...</div><div>&nbsp; &nbsp; 2.指定属性绑定事件监听：div:hover {width...height...}</div><div>&nbsp; &nbsp; # transition: all 1s + css组合</div><div><br></div><div><font color=\"#4169e1\"><b>animation</b></font></div><div>&nbsp; &nbsp; - name 1s 时间函数 开始时间 次数();</div><div>&nbsp; &nbsp; - ease: 慢快慢 / linear:匀速</div><div>&nbsp; &nbsp; - @keyframes name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 0% {background:red;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 100% {background:green;}}</div>"
    },
    "2h5NLczt-": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "2h5NLczt-",
      "name": "CSS 布局",
      "content": "<div><font color=\"#ff0000\"><b>Position定位（默认&nbsp;static&nbsp;且&nbsp;z-index&nbsp;无效</b></font><b style=\"color: rgb(255, 0, 0);\">）</b><br></div><div>&nbsp; &nbsp; 1 文档流:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; relative：相对于原位置移动</div><div>&nbsp; &nbsp; 2 脱离文档流：</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>absolute：相对relative移动,会提升层级</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 脱离文档流而产生的高度塌陷 &amp; 相邻|垂直|内外边距重叠</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以通过添加块元素解决,清除因浮动产生的移动影响</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .clearfix:before,.clearfix:after</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {content:\"\";display:table;clear:both;}</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>float：会产生挤压</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>fixed：相对于可视界面移动,会提升层级</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div><font color=\"#ff0000\"><b>弹性盒子</b></font></div><div><span style=\"white-space: pre;\">\t</span>1.容器设置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex | inline-flex</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.容器属性</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-direction：row | row-reverse | column | column-reverse</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-wrap：nowrap | wrap | wrap-reverse</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-flow:&nbsp; &nbsp;row nowrap</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>横轴对齐&nbsp;</b></font>justify-content:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>flex-start<font color=\"#4169e1\"><b>(默认)</b></font>&nbsp;/ flex-end / center / space-between /&nbsp;space-around</div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>纵轴对齐&nbsp;</b></font>align-items:&nbsp;<div><span style=\"white-space: pre;\">\t\t</span>flex-start / flex-end / center / baseline(<font color=\"#4169e1\"><b>按文字对齐</b></font>) / stretch<font color=\"#4169e1\"><b>(默认：高度占满)</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 多横轴对齐&nbsp;</b></font>align-content:&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp; flex-start / flex-end / center / space-between / space-around / stretch<b style=\"color: rgb(65, 105, 225);\">(默认：高度占满)</b></div><div><span style=\"white-space: pre;\">\t\t</span># 子元素 float/clear/vertical-align 会失效</div><div><span style=\"white-space: pre;\">\t</span><font color=\"#4169e1\"><b>3.容器内容设置</b></font></div><div><span style=\"white-space: pre;\">\t\t</span>1. order: 值越小越靠前/默认 0</div><div><span style=\"white-space: pre;\">\t\t</span>2. flex: (占比) none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</div><div><span style=\"white-space: pre;\">\t\t</span>3. align-self: 单独设置 align-items 个性的对齐</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp; 4. margin-?:auto 会获取剩余所有空白</div><div><br></div><div><b><font color=\"#ff0000\">移动端适配&nbsp;</font></b></div><div>&nbsp; &nbsp; 主要通过媒体查询&nbsp;<font color=\"#4169e1\"><b>@media</b></font>&nbsp;为不同设备设计不同样式<br></div><div>&nbsp; &nbsp; 通常需要用meta定义了浏览器宽度 = 设备宽度</div><div>&nbsp; &nbsp; &lt;meta name='viewport' content= 'width=device-width, initial-scale=1.0'&gt;</div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; 百分比布局</b></font></div><div><span style=\"white-space: pre;\">\t</span>- 为不同设备编写不同的CSS样式文件</div><div><span style=\"white-space: pre;\">\t</span>- 宽度默认 100%; - 但是字体可能会模糊</div><div><b><font color=\"#4169e1\">&nbsp; &nbsp; Rem布局</font></b></div><div><span style=\"white-space: pre;\">\t</span># 像素设备比 -DPR -表示1个css像素对应（覆盖）的物理像素个数</div><div><span style=\"white-space: pre;\">\t</span># HTML 默认font-size:16px / 下面动态设置HTML字体</div><div><br></div><div><div><font color=\"#ff0000\"><b>//动态设置页面根字体</b></font></div><div>(function(doc, win) {</div><div>&nbsp; //1.找到HTML页面根结点</div><div>&nbsp; let html = doc.getElementsByTagName(\"html\")[0],</div><div>&nbsp; &nbsp; //2.设置全局事件 = 屏幕发生改变事件</div><div>&nbsp; &nbsp; reEvt = \"orientationchange\" in win ? \"orientationchange\" : \"resize\", //转屏/缩放</div><div>&nbsp; &nbsp; //3.设置回调函数</div><div>&nbsp; &nbsp; reFontSize = function() {</div><div>&nbsp; &nbsp; &nbsp; var clientW = doc.documentElement.clientWidth || doc.body.clientWidth; //当前屏幕宽度</div><div>&nbsp; &nbsp; &nbsp; if (!clientW) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; // 设计稿/字体 = 1920px/16px = 屏幕宽/1rem</div><div>&nbsp; &nbsp; &nbsp; let rem = (clientW * 15) / 1920;</div><div>&nbsp; &nbsp; &nbsp; rem = rem &lt; 12 ? 12 : rem;</div><div>&nbsp; &nbsp; &nbsp; html.style.fontSize = rem + \"px\";</div><div>&nbsp; &nbsp; };</div><div>&nbsp; //5.全局添加事件监听(全局事件/回调)</div><div>&nbsp; win.addEventListener(reEvt, reFontSize);</div><div>&nbsp; //6.DOMContentLoaded-&gt;dom加载完就执行,onload要dom/css/js都加载完才执行</div><div>&nbsp; doc.addEventListener(\"DOMContentLoaded\", reFontSize);</div><div>})(document, window);</div></div><div><div><font color=\"#ff0000\"><b><br></b></font></div><div><font color=\"#ff0000\"><b>常用的居中方式</b></font></div><div>&nbsp; &nbsp; 1 水平居中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; margin:0 auto&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (行内)text-align:center</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; justify-content: center;</div><div>&nbsp; &nbsp; 2 垂直居中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (单行内)line-height</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>(多行)display:table-cell; vertical-align: middle;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; align-items: center;</div><div>&nbsp; &nbsp; 3 同时对齐</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ab+re定位：trbl:0; margin:auto;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; top/left：50%; transform(-50%,-50%)/margin-l/r:-50%;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; justify-content: center; align-items: center;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;<font color=\"#4169e1\"><b>&nbsp;(弹性盒)display: flex; margin:auto;</b></font></div></div>"
    },
    "A-Agjhwkp": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "A-Agjhwkp",
      "name": "ECMAscript",
      "content": "<div><div><b style=\"color: rgb(255, 0, 0);\">JavaScript发展</b><br></div><div>&nbsp; &nbsp; 1995.&nbsp;JavaScript（Ecma Script）诞生，使用<font color=\"#4169e1\"><b>解释器</b></font>逐行编译代码</div><div>&nbsp; &nbsp; 2008. 浏览器性能竞争：Google开发V8添加<font color=\"#4169e1\"><b>及时编译器</b></font>（JITs：Just in Time）&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * NodeJS，Electron&nbsp;运行环境成为可能</div><div>&nbsp; &nbsp; 2013.&nbsp;诞生强类型语言提升性能，二次转译为 JavaScript：TypeScript (MS)，Dart (Google)</div><div>&nbsp; &nbsp; 2013. 添加JavaScript语法拓展：Asm.js (Mozilla)</div><div>&nbsp; &nbsp; 2017. 将所有强类型语言编译为&nbsp;WebAssembly（MS，Google，Mozilla，Apple）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 业务逻辑调试困难 / 无法操作DOM</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;适合数据密集型计算</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * \"web领域的汇编语言\"</div></div><div><br></div><div><font color=\"#ff0000\"><b>ES6</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; *&nbsp;</b></font>不同版本的引擎支持不同的高级语法</div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp; &nbsp; </font><font style=\"\" color=\"#4169e1\"><b>声</b></font><font color=\"#4169e1\" style=\"\"><b>明变量</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * var 在全局范围内有效</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * let 只在 let 命令所在的代码块内有效 不存在预处理:会产生报错</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * const 声明一个只读的常量，一旦声明，常量的值就不能改变。</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>解构式赋值</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;快速根据 数组及对象&nbsp;中的值进行变量声明</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;let [] / {} = Array/Object</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;<b>剩余运算符 ...args</b></div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>新增内建对象：</b></font>* Symbol / Set / Map</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>箭头函数：()=&gt;{}</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; 模板字符串：`字符串+${变量}`</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; 简洁声明对象/方法：{var} / name(){}</b></font></div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>模块化：</b></font>export import&nbsp;模块化&nbsp;use '<span class=\"marked\">strict</span>' 严格模式</div><div><br><div><b><font color=\"#ff0000\">参考文章</font></b></div><div>&nbsp; &nbsp; 1.几张图让你看懂 WebAssembly</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://www.jianshu.com/p/bff8aa23fe4d</div></div><div>&nbsp; &nbsp; 2.如何评论浏览器最新的 WebAssembly 字节码技术？</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://www.zhihu.com/question/31415286</div>"
    },
    "16fl8BDX1": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "16fl8BDX1",
      "name": "创建对象",
      "content": "<div><font color=\"#ff0000\"><b>基础数据&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>1.undefined</b></font><b style=\"color: rgb(65, 105, 225);\">：</b><b style=\"color: rgb(65, 105, 225);\">undefined</b>（变量默认值）</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>2.null</b></font><b style=\"color: rgb(65, 105, 225);\">：object</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>3.数字 123</b></font><b style=\"color: rgb(65, 105, 225);\">：number</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>4.字符串“”</b></font><b style=\"color: rgb(65, 105, 225);\">：string</b></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; 5.true/false：boolean</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp;&nbsp;</b></font>* 本质是内存代表的值保存在栈中</div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>判断类型</div><div>&nbsp; &nbsp; &nbsp; &nbsp; typeof：string</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target instanceof suppose：返回a是否是B构造函数的实例</div><div>&nbsp; &nbsp; &nbsp; &nbsp; parseInt/Float(): 先转换成字符串: 从头逐字符取出有效数字并返回数字</div><div><div><b style=\"color: rgb(65, 105, 225);\"><br></b></div><div><b><font color=\"#ff0000\">创建对象</font></b></div><div>&nbsp; &nbsp; 1.不推荐直接创建&nbsp;<b style=\"color: rgb(255, 0, 0);\">根Object&nbsp;</b>的实例 a = {} / new Object()</div><div>&nbsp; &nbsp; 2.推荐通过原型链特性创建对象实例：声明大写首字母构造函数，在原型区放置公共方法</div><div>&nbsp; &nbsp; * new -&nbsp;划分实例内存 /&nbsp;this指向实例内存 /&nbsp;执行构造函数 /&nbsp;返回新对象指针</div><div>&nbsp; &nbsp; *&nbsp;通常使用&nbsp;for in 遍历对象值键对</div><div>&nbsp; &nbsp; 3.ES6 class&nbsp;本质是语法糖</div><div>&nbsp; &nbsp; &nbsp; &nbsp; extends / static / constructor / 子类构造方法必须出现 super():&nbsp;</div><span class=\"hl-code\"></span><span class=\"hl-brackets\"></span><div>&nbsp; &nbsp; 4.<font color=\"#ff0000\"><b>Function执行&nbsp;</b></font>的五种场景</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;回调函数(&nbsp;如计时器 )被执行：this&nbsp;指向&nbsp;window，undefined（严格模式）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 对象执行内部方法：this 指向对象本身</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 路人执行他人方法：this&nbsp;指向路人</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 立即调用：function.<font color=\"#ff0000\"><b>apply</b></font>(&nbsp;target,&nbsp;<font color=\"#4169e1\"><b>[arg1, arg2]</b></font>&nbsp;)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 立即调用：function.<font color=\"#ff0000\"><b>call</b></font>(&nbsp;target,&nbsp;<font color=\"#4169e1\"><b>arg1, arg2</b></font>&nbsp;) //&nbsp;apply&nbsp;的语法糖</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 返回新方法：function.<font color=\"#ff0000\"><b>bind</b></font>( target&nbsp;)：</div></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;创建对象实例执行构造方法：this&nbsp;指向实例</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;箭头函数执行：this&nbsp;等同于父作用域的&nbsp;this</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <b>*&nbsp;优先级依次上升</b></div><div><br></div><div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>* 对象分类</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 宿主(运行环境)对象 DOM/BOM</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 自定义对象：构造函数实例</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>内建对象</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 通常&nbsp;</b></font>* String Array Number Boolean Date Math RegExp</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>ES6新增&nbsp;</b></font>* Symbol Set Map Promise</div></div><div><br></div><div><div><font color=\"#ff0000\"><b>原型/构造链</b></font><br></div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>1.原型链&nbsp;</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font>* JS没有公共类的概念，为了实现对象的继承功能</div><div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b><font color=\"#4169e1\">实例&nbsp;</font></b>__proto__ =&nbsp;<font color=\"#4169e1\"><b>根Object实例</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b style=\"color: rgb(65, 105, 225);\">构造函数内存&nbsp;</b>prototype =&nbsp;<b style=\"color: rgb(65, 105, 225);\">根Object实例</b></div></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b style=\"color: rgb(65, 105, 225);\">根Object实例&nbsp;</b>__proto__ =&nbsp;<font color=\"#ff0000\"><b>所有对象根Object构造函数</b></font></div></div><div><div><br></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>2.构造链</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; 实例</b></font><font color=\"#4169e1\"><b>&nbsp;</b></font>constructor =<font color=\"#4169e1\"><b>&nbsp;构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b><font color=\"#4169e1\"><b>&nbsp;</b></font>constructor =&nbsp;<b style=\"color: rgb(65, 105, 225);\">Function</b><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b><b style=\"color: rgb(65, 105, 225);\">Function</b><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b><b style=\"color: rgb(65, 105, 225);\">&nbsp;</b>constructor =&nbsp;<b style=\"color: rgb(65, 105, 225);\">Function</b><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b><b style=\"color: rgb(65, 105, 225);\">根Object实例&nbsp;</b>constructor =&nbsp;<font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div></div></div><div><b style=\"color: rgb(65, 105, 225);\"><br></b></div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>闭包产生</b></font></div><div><font color=\"#4169e1\" style=\"font-weight: bold;\">&nbsp; &nbsp; &nbsp; &nbsp; </font><b># 某个函数与某个引用环境存在引用关系，闭包指这个引用环境中的(自由)变量集合</b></div><div><span style=\"white-space: pre;\">\t</span>1.存在嵌套的外部函数 - 内部函数</div><div><span style=\"white-space: pre;\">\t</span>2.内部函数调用了外部函数的变量</div><div><span style=\"white-space: pre;\">\t</span>3.内部函数被<b>外部变量</b>引用且执行，即内部函数执行(闭包产生)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 外部变量没被销毁=内部函数没被销毁=外部函数没被销毁</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 外部变量是在内部函数预加载时被引用的 = <b>闭包产生</b></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>闭包用途</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.匿名函数自调用,把相关数据暴露给window.模块名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.可以根据模块名直接使用相关数据</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function foo() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>var x = 3;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function a(){return x++;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>return a;</div><div><span style=\"white-space: pre;\">\t\t</span>}</div><div><span style=\"white-space: pre;\">\t\t</span>var m = foo();</div><div><span style=\"white-space: pre;\">\t\t</span># 全局引用foo(已经执行)/导致函数a不消失/导致变量x不消失</div></div>"
    },
    "Mod2Cbc44": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "Mod2Cbc44",
      "name": "内建对象",
      "content": "<div><b style=\"color: rgb(255, 0, 0);\">Object</b><br></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; </b></font>对象的key只能是 Symbol/String</div><div>&nbsp; &nbsp; 数组 Object.keys(obj)</div><div>&nbsp; &nbsp; 键数组 Object.keys(obj)</div><div>&nbsp; &nbsp; 值数组 Object.values(obj)</div><div>&nbsp; &nbsp; 值键对二维数组 Object.entries(obj)</div><div>&nbsp; &nbsp; 遍历：for in&nbsp;循环</div><div>&nbsp; &nbsp; # 判断对象为空 JSON.stringfy()==={} || Object.keys(obj).length===0</div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">String</b><br></div><div><div>&nbsp; &nbsp; 合并：concat()</div><div>&nbsp; &nbsp; 截取：slice(statr, end之前) / substring(statr, end之前)</div><div>&nbsp; &nbsp; 获取下标：indexOf()/lastIndexOf()</div><div>&nbsp; &nbsp; 查询：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; charAt(index)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; match()<span style=\"white-space: pre;\">\t</span>找到一个或多个正则表达式的匹配。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; replace()<span style=\"white-space: pre;\">\t</span>替换与正则表达式匹配的子串。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; search()<span style=\"white-space: pre;\">\t</span>检索与正则表达式相匹配的值。</div><div>&nbsp; &nbsp; 转换为数组：split(分隔符)</div><div>&nbsp; &nbsp; 新字符串：String(ins): String / Object.toString(): 返回新字符串, undefined/null 报错</div></div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Symbol（不是对象，而是基础值）</b></font></div><div><div><div><span style=\"white-space: pre;\">\t</span>* 标识唯一的值 - 解决：字符串不具有唯一性</div><div><span style=\"white-space: pre;\">\t</span>1.单例模式 const NAME = Symbol('name')</div><div><span style=\"white-space: pre;\">\t</span>2.键声明</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Symbol.for('tar'):全局搜索/若无则新建</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Symbol.keyFor('tar'):全局键搜索</div></div></div><div><br></div><b style=\"color: rgb(255, 0, 0);\">Array</b><div><div>&nbsp; &nbsp; push()<span style=\"white-space: pre;\">\t</span>向数组的末尾添加一个或更多元素，并返回新的长度&nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; pop()<span style=\"white-space: pre;\">\t</span>删除并返回数组的最后一个元素<br></div>&nbsp; &nbsp; shift()<span style=\"white-space: pre;\">\t</span>删除并返回数组的第一个元素<div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 合并：A.concat(B)</div><div>&nbsp; &nbsp; 截取 slice(start, end之前)</div><div>&nbsp; &nbsp; 替换 splice(start, 删除num个数, '新元素')</div><div>&nbsp; &nbsp; 带分隔符的字符串：join(分隔符)</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 排序：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; reverse()<span style=\"white-space: pre;\">\t</span>颠倒数组中元素的顺序</div><div>&nbsp; &nbsp; &nbsp; &nbsp; sort(compare) 默认排序顺序是根据字符串UniCode码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 需要传参 function compare(start,end){ return start-end // 升序 }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 对象排序</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function compare(e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return function(start,end){ return start[e]-end[e] }}</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>arr.forEach(function(item,index,thisArr){ console.log(item) })</div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Set</b></font></div><div><div><span style=\"white-space: pre;\">\t</span>新建 new Set( Array/String )：转换为&nbsp;key:number&nbsp;的 Object</div><div><span style=\"white-space: pre;\">\t</span>增加 set.add(value)</div><div><span style=\"white-space: pre;\">\t</span>长度 size</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>数组 let arr = [...mySet] //&nbsp;返回新数组</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>并集 new Set([...a, ...b])</div><div><span style=\"white-space: pre;\">\t</span>交集 new Set([...a].filter(x =&gt; b.has(x)))</div><div><span style=\"white-space: pre;\">\t</span>差集 new Set([...a].filter(x =&gt; !b.has(x)))</div></div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Map</b></font></div><div><span style=\"white-space: pre;\">\t</span>克隆/合并 new Map(oldMap)<div><span style=\"white-space: pre;\">\t</span>新建 new Map(二维数组)</div><div><span style=\"white-space: pre;\">\t</span>增加 map.set(key,value)</div><div><span style=\"white-space: pre;\">\t</span>删除 map.delete(key)</div><div><span style=\"white-space: pre;\">\t</span>长度 size</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span># 按插入顺序输出</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>for of&nbsp;循环 / forEach( (value,key)=&gt;{}, map )</div><div><b style=\"color: rgb(65, 105, 225);\"><br></b></div><div><b style=\"color: rgb(65, 105, 225);\">ES6 Promise</b></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; *&nbsp;</b></font><b style=\"color: rgb(255, 0, 0);\">异步函数链式调用&nbsp;</b><b style=\"color: rgb(255, 0, 0);\">设计架构</b></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; &nbsp; &nbsp; - Promise</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font>清空 then任务队列<b style=\"color: rgb(255, 0, 0);\">（1）</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行传入的同步代码（如果是）<b style=\"color: rgb(255, 0, 0);\">（2）</b></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font><b style=\"color: rgb(65, 105, 225);\">执行</b><b style=\"color: rgb(65, 105, 225);\">传入的异步代码（1）</b></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;* 异步操作</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * resolve（异步操作结果） 执行</b></font></div><div><font color=\"#4169e1\"><b><font style=\"\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </font>-&nbsp;使得传入的结果覆盖此时实例data</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 循环执行此时的 then任务队列</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 以此时的实例data作为参数</b></font></div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;返回结果不为 Promise，resolve&nbsp;执行（常用：6）<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;返回结果为 Promise，resolve&nbsp;执行（6）</b></font><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp; </b><font color=\"#ff0000\"><b>- then</b></font></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </b>1.执行一个新Promise</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;传入任务：往实例的&nbsp;&nbsp;then任务队列&nbsp;中添加任务函数<b style=\"color: rgb(255, 0, 0);\">（3*n）</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b><font color=\"#ff0000\"><b>-&nbsp;其他同步代码</b></font><b style=\"color: rgb(255, 0, 0);\">（5）</b></div></div><div><div>&nbsp; &nbsp; ******************************************************************************</div><div>&nbsp; &nbsp; * function&nbsp;<font color=\"#4169e1\"><b>Promise</b></font>(<font color=\"#ff0000\"><b>asyncFun</b></font>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; var&nbsp;self&nbsp;= this（Promise实例）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; self.asyncQuene= []</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; function&nbsp;resolve(value) {&nbsp;</div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // resolve&nbsp;本身需要为异步函数（计时器实现）</b><b style=\"color: rgb(65, 105, 225);\">(#2)</b></div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //&nbsp;this&nbsp;指向 Promise实例&nbsp;而不是window</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setTimeout(() =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.data = value;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.asyncQuene.forEach(callback =&gt;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; callback(value)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><b style=\"color: rgb(255, 0, 0);\">&nbsp; &nbsp; &nbsp; &nbsp; asyncFun</b>(resolve.bind(self))&nbsp;<b style=\"color: rgb(65, 105, 225);\">(#1)</b></div><div>&nbsp; &nbsp; }</div>&nbsp; &nbsp; ******************************************************************************</div><div><div>&nbsp; &nbsp; *&nbsp;<font color=\"#4169e1\"><b>Promise</b></font>.prototype.<font color=\"#4169e1\"><b>then&nbsp;</b></font>= function(<font color=\"#4169e1\"><b>FunByLastAsync</b></font>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp;<b> *&nbsp;由于&nbsp;Last Promise实例 调用了then方法，这里&nbsp;this&nbsp;指向&nbsp;</b><b>Last Promise实例</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; var self = this</div><div>&nbsp; &nbsp; &nbsp; &nbsp; var <font color=\"#ff0000\"><b>async2 </b></font>= (resolve) =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.asyncQuene.push(function() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var result =&nbsp;<b style=\"color: rgb(65, 105, 225);\">FunByLastAsync</b>(self.data)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>result instanceof </b><font color=\"#4169e1\" style=\"\"><b>Promise </b></font><b>?&nbsp;result.then(resolve) :&nbsp;</b><b>resolve(result)</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; return&nbsp;new Promise(<font color=\"#ff0000\"><b>async2</b></font>)</div><div>&nbsp; &nbsp; }</div>&nbsp; &nbsp; ******************************************************************************</div></div><div><br></div>"
    },
    "4v5GHXlm4": {
      "blockId": "D2S51gJkH",
      "shelfId": "V6rREb5rV",
      "bookId": "4v5GHXlm4",
      "name": "产品概念",
      "content": "<div><font color=\"#ff0000\"><b>产品案例</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>为什么咖啡行业不景气，却遍地都是？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/268169923</div><div><br></div><font color=\"#ff0000\"><b>产品变现</b></font><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>* 有哪些流量巨大但始终无法变现的互联网产品？<font color=\"#ff0000\"><b><br></b></font><div>&nbsp; &nbsp;&nbsp;https://www.zhihu.com/question/26059765/answer/148846396</div></div><div>&nbsp; &nbsp;&nbsp;https://www.zhihu.com/question/26059765/answer/253412153</div><div>&nbsp; &nbsp; 如何看待游戏《贪玩蓝月》的公司创始人被捕？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/329184075/answer/714142046</div><div>&nbsp; &nbsp;&nbsp;茅台酒厂如何防止员工上班时偷喝茅台酒？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/303620398/answer/634047672</div>"
    },
    "w7nDi7pcG": {
      "blockId": "D2S51gJkH",
      "shelfId": "OrVbgLEFn",
      "bookId": "w7nDi7pcG",
      "name": "政治学",
      "content": "<div><font color=\"#ff0000\"><b>政治目标</b></font></div><div><font color=\"#ff0000\"><b><br></b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; </b></font>失去了人口红利的中国会怎样？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/354301326/answer/946847312</div><div>&nbsp; &nbsp;&nbsp;人们研究如甲骨文之类的古文字的意义是什么？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/24164877/answer/735299839</div><div>&nbsp; &nbsp; 美国为什么不侵略邻近且资源丰富的加拿大？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/21685448/answer/426741248</div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font></div><div><font color=\"#ff0000\"><b>各时间政策分析</b></font></div><div><font color=\"#ff0000\"><b><br></b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>* 有哪些行为堪比「1949 年加入国民党」？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/265048690/answer/297995221</div><div>&nbsp; &nbsp; *&nbsp;知乎用户有哪些预言最终被证实了？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/265334984/answer/1098369373</div><div>&nbsp; &nbsp; *“实体经济越来越不行了”这种流行观点是否成立？为什么？</div><div>&nbsp; &nbsp; https://www.zhihu.com/collection/46005262</div><div>&nbsp; &nbsp;<br></div><div><font color=\"#ff0000\"><b>人物立场分析</b></font></div><div><font color=\"#ff0000\"><b><br></b></font></div><div>&nbsp; &nbsp; *&nbsp;沙僧真的是因为打碎了玻璃盏才被赶到下界的吗？</div><div>&nbsp; &nbsp; &nbsp; https://www.zhihu.com/question/371515636/answer/1016244372</div><div>&nbsp; &nbsp; * 生活中有没有特别绿茶的女生？</div><div>&nbsp; &nbsp; &nbsp; https://www.zhihu.com/question/328524632/answer/995660728</div><div>&nbsp; &nbsp;&nbsp;怎样在机关事业单位不被老油条欺负？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/337531740/answer/886984703</div><div>&nbsp; &nbsp;&nbsp;最失败的一次外交活动</div><div>&nbsp; &nbsp; https://zhuanlan.zhihu.com/p/84372675</div><div>&nbsp; &nbsp;&nbsp;英国打过几乎所有国家，为什么没几个国家恨它？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/46770386/answer/797812681</div><div>&nbsp; &nbsp;&nbsp;曹操比刘邦到底差哪儿，为何不能一统天下？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/308017350/answer/626051963</div><div>&nbsp; &nbsp;&nbsp;为何史书少有令人有「跪感」的「烧脑」的权谋反转？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/54826697/answer/678424196</div><div>&nbsp; &nbsp;&nbsp;是不是外国人活得想得很简单？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/308268014/answer/620768338</div><div>&nbsp; &nbsp;&nbsp;</div><div><br></div>"
    },
    "XPc82SKZb": {
      "blockId": "D2S51gJkH",
      "shelfId": "nP7h_-tlw",
      "bookId": "XPc82SKZb",
      "name": "人生经验",
      "content": "<div><font color=\"#4169e1\"><b>*&nbsp;知乎收藏是看不完的，不如单纯的收藏，有时间了再消化并计入笔记系统</b></font></div><div><br></div><div><font color=\"#ff0000\"><b>==================================================技术向</b></font></div><div><div>前言</div>&nbsp; &nbsp; * 一个33岁老程序员的感悟<div>&nbsp; &nbsp; https://zhuanlan.zhihu.com/p/91167083</div><div>&nbsp; &nbsp;&nbsp;前端工程师的深度或者核心竞争力体现在哪里？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/263926959/answer/275947141</div></div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">==================================================生活向</b><br></div>*&nbsp;<span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">搞科研是需要天赋的。说难也不难，就是一种研究思路的问题，先找问题，再搜数据，利用一两个验证方法而已。但是这个思路你现在要是没有，以后也很难有。有句话我觉得说的挺对，有些人为了逃避思考，愿意做任何事。</span><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><br></span></div><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">*&nbsp;</span>我一点都不讨厌我带的学生没有科研能力，我手底下上百个硕士生，不可能个个优秀。再不行，我还有博士生可以用。但是我很讨厌那种明知道自己没有科研能力，还不抓紧时间给自己找后路的学生。你要是觉得自己不想读博，跟我说，我放你去实习。那些不发论文，还不去实习给自己找出路的学生，我是最讨厌。</div><div><br></div><div><p>* 我给你实操的建议。</p><p>&nbsp; &nbsp; 一是行测，从现在起，每天利用吃饭时间看新闻或听新闻，八卦多了会有印象。</p><p>&nbsp; &nbsp; 利用上厕所和通勤时间，顶多再用半小时休闲时间看真题卷和模拟卷，不是做题是看题！</p><p>&nbsp; &nbsp; 看解题思路和背答案！一天熟知20题答案或套路，</p><p>&nbsp; &nbsp; 到考试时，你脑子里大概就有近3000道题答案了。怎么着70多分也能蒙上。</p><p>&nbsp; &nbsp; 二是申论。每天用半小时到一小时看人民日报。</p><p>&nbsp; &nbsp; 重点不是看内容，而是练习把新闻和文章，按照是什么、为什么、怎么办三部分进行解构，</p><p>&nbsp; &nbsp; 练习半年，你的申论乃至面试口头表述的逻辑性、条理性都会有大的进步，</p><p>&nbsp; &nbsp; 也能抓住题干准确答题。大概70分以上是保险的。</p><p>&nbsp; &nbsp; 根本不需要上任何培训班，浪费钱和时间，自己就能搞定。</p><p>&nbsp; &nbsp; 面试，就是你之前这些阅读量信息量的综合考验，只需要平心静气看清楚题目问什么，</p><p>&nbsp; &nbsp; 把自己平日里从新闻和人民日报学会的官方用语以有逻辑有条理的语言表述出来。妥了。</p><p>&nbsp; &nbsp; 一个考了三次第一次双第一体检拿下，第二次双第二落败，</p><p>&nbsp; &nbsp; 第三次快30岁才双一入围，目前是面试考官的老同志提供的建议。</p><p><br></p><p>* 如果你具备实事求是的态度，对一个你看不懂的东西，你不会自卑，不会崇拜，你会去研究它，了解它，等你了解了这项工作究竟是什么，你最终才能评价它，在这之后，或许你才会崇拜，才会自卑。</p><div><br><div><p>* 首先，重中之重，最重要的是<b>考研！考研！考研！</b>目标双一流院校或重点财经政法类院校。</p><p>量力而行很重要：如果你是厦大/南大/浙大/南开/天大这种准一线水平的，除了考本校之外，一定要试试北大光华/清华经管/CCER/高金/安泰/之类的地方，一旦成功那就是新的一番天地；如果你是普通一本或者二本且自身能力有限，目标可以定在重点财经类院校的，比如西南财经/江西财经/东北财经之类的，大小也是个财经类研究生，可以当作入行的敲门砖了。</p><p>其次，需要考的证书只有两个：一个叫<b>CPA-中国注册会计师</b>，另一个叫<b>司法考试</b>，其他什么CFA/ACCA/FRM一律都是屁用没有的扯犊子证书，至少在你刚毕业求职的时候是这样的，那些证书日后你有需要在职业上进一步发展的时候再行考虑吧。</p><p>不需要在毕业都考完。如果你的本科院校过得去（双一流985+两财一贸），你大四开始准备CPA，争取过个三门，碰上对研究生学历没那么太大要求的一些券商，你就可以入职开始你的投行生涯了。如果读了研究生，那就在读研期间争取把CPA跟司考都拿下，同时找券商做实习，等你毕业的时候，中金/国开/四大行总行那种地方咱们不提，拿着CPA跟司考去个海通/国泰君安/中信建投/申银万国/华泰证券之类的地方还是有可能实现的。</p><p>肺腑之言，爱信不信。</p><p><br></p><p>* 会报税、会做账、会出报表、会各种表统计、会项目测算等等，你以为你自己是个会计啦！不不不，你还是小白，因为你还不会所得税汇算清缴、不会财务分析、不会做融资、不会做上市的东西等等，慢慢学吧</p><p><br></p><p>* A股的优势，是国内门槛最低的合法赌博市场。牛市的基础不是基本面，是市场上的流动性。</p><p><br></p><p>* 在中国，如果你满足不了别人，你的人生就是失败的，除非你自己内心非常强大。</p><p><br></p><p>* 抛开传统的价值观。在我眼里，担当等于机会。而机会，就是财富。</p><p><br></p><p>*&nbsp;这东西跟能力无关，这就是平台的差距。不要以为，这世界是不会变的。那些看起来很不了不起的成绩，都源于一点点的积累</p><p><br></p><p>*&nbsp;我提供一个参考思路，大家可以深入学习一下国家十三五规划，那里说的很详细；</p><p><br></p><p>* 所谓农业经济的思维方式，就是“播种－可以收获－播更多的种－可以收更多的获”，类似的还有“考上好大学－找到好工作－从此过上幸福生活”</p><p>&nbsp; &nbsp; 线性＋静态＋预设结果。线性就是只认一条路，静态就是蒙上眼，预设结果就是认定付出就有收获，就是一头俯首耕地的呆牛。</p><p><br></p><p>*&nbsp;“没时间做某事”，也就等于认同“某事不重要”。</p><p><br></p><p>*&nbsp;拿住优质资产，盈利是大概率事件，但拿住是很难的。</p><p><br></p><p>*&nbsp;以前网上有句话说「认真你就输了」，我想我输了很多时间，而他输了可以在面试的时候侃侃而谈（说的对还是错其实没那么重要）的机会。</p></div></div></div>"
    },
    "i8l29sD36": {
      "blockId": "D2S51gJkH",
      "shelfId": "OrVbgLEFn",
      "bookId": "i8l29sD36",
      "name": "市场学",
      "content": "<div><div><font color=\"#ff0000\"><b>产品案例</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>为什么咖啡行业不景气，却遍地都是？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/268169923</div><div><br></div><font color=\"#ff0000\"><b>产品变现</b></font><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>* 有哪些流量巨大但始终无法变现的互联网产品？<font color=\"#ff0000\"><b><br></b></font><div>&nbsp; &nbsp;&nbsp;https://www.zhihu.com/question/26059765/answer/148846396</div></div><div>&nbsp; &nbsp;&nbsp;https://www.zhihu.com/question/26059765/answer/253412153</div><div>&nbsp; &nbsp; 如何看待游戏《贪玩蓝月》的公司创始人被捕？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/329184075/answer/714142046</div><div>&nbsp; &nbsp;&nbsp;茅台酒厂如何防止员工上班时偷喝茅台酒？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/303620398/answer/634047672</div></div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">利益分配</b></div><div><div>&nbsp; &nbsp; *&nbsp;为什么每次中国出现危机都喜欢启动大基建?</div><div>&nbsp; &nbsp; &nbsp; https://www.zhihu.com/question/376664591/answer/1077188422</div></div><div>&nbsp; &nbsp; * 真正的有钱人都买什么奢侈品？</div><div>&nbsp; &nbsp; &nbsp; https://www.zhihu.com/question/34587107/answer/985523285<br></div><div>&nbsp; &nbsp; * 美国家庭为什么容易破产？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/351165549/answer/868357982</div><div>&nbsp; &nbsp;&nbsp;为什么房地产商不能拿低价的土地把房价降下来?</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/318916762/answer/699167318</div><div>&nbsp; &nbsp;&nbsp;如何解决资本主义周期性危机？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/55120634/answer/722572792</div><div>&nbsp; &nbsp;&nbsp;如何看待包商银行被央行接管事件 ，中小城商行的发展前景在哪？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/325970300/answer/696727070</div><div>&nbsp; &nbsp;&nbsp;没有一个经济数据，一文看懂中国经济周期的真相</div><div>&nbsp; &nbsp; https://zhuanlan.zhihu.com/p/54076753</div><div>&nbsp; &nbsp;&nbsp;股票里真的有炒股票的庄家吗?谁是庄家?</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/20451849/answer/147923476</div><div>&nbsp; &nbsp;&nbsp;余额宝规模达到 1.43 万亿意味着什么？对银行的业务有哪些影响？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/61926374/answer/193032834</div><div>&nbsp; &nbsp;&nbsp;2019年全国房价会呈什么趋势？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/302685037/answer/583089503</div><div><br></div><div><div><font color=\"#ff0000\"><b>市场划分</b></font><br></div><div>&nbsp; &nbsp;&nbsp;中文互联网的产出在渐渐枯萎吗？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/49684783/answer/1088276178</div><div>&nbsp; &nbsp;&nbsp;为什么互联网行业工资高？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/32022042/answer/799455698</div><div>&nbsp; &nbsp;&nbsp;如何着手分析一个行业？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/20219092/answer/522122813</div><div>&nbsp; &nbsp;&nbsp;应届生 应该进企业做会计还是去代理记账公司？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/278572137/answer/636717479</div></div><div><br></div><div><font color=\"#ff0000\"><b>会计学</b></font></div><div><br></div><div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>参考文章</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 请问各位财会前辈，本人小白，学会计实操，报十几种行业的好吗？</div><div>&nbsp; &nbsp; &nbsp; &nbsp; https://www.zhihu.com/collection/46005262?page=1</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 所以学会计理论盯着企业会计准则一本书就够了，如果能真正掌握几个会计的基本准则，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 一通百通，无论什么行业，什么业务模式，都能处理。<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;为什么大部分财务人员工资那么低？</div><div>&nbsp; &nbsp; &nbsp; &nbsp; https://www.zhihu.com/question/34892325/answer/93962498</div></div>"
    },
    "v0jnGtVZl": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "v0jnGtVZl",
      "name": "Vue原理",
      "content": "<div>导读文章</div><div>&nbsp; &nbsp; Vue开发入门看这篇文章就够了</div><div>&nbsp; &nbsp;&nbsp;https://zhuanlan.zhihu.com/p/67893936</div>生命周期<div>&nbsp; &nbsp; beforeCreate =&gt; 初始化事件/生命周期</div><div><span style=\"white-space: pre;\">\t\t</span>created&nbsp;</div><div><span style=\"white-space: pre;\">\t\t\t</span>=&gt; 根据el:#app调用 vm.$mount(\"#app\")</div><div><span style=\"white-space: pre;\">\t\t\t</span>=&gt; 根据template编译到 vm.render 中</div><div><span style=\"white-space: pre;\">\t\t</span>beforeMount =&gt; vm.$el = DOM</div><div><span style=\"white-space: pre;\">\t\t</span>mounted =&gt; beforeUpdate &lt;=&gt; update =&gt; vm.$destroy()</div><div><span style=\"white-space: pre;\">\t\t</span>destroyed</div><div><br></div><div>VUE实例</div><div><div>***********************************************************************************</div><div>组件是可以复用的 Vue 实例</div><div><span style=\"white-space: pre;\">\t</span>1. 组件控制模板字符串\"&lt;templete&gt;\"/单vue文件</div><div><span style=\"white-space: pre;\">\t</span>2. 注册</div><div><span style=\"white-space: pre;\">\t\t</span>全局: Vue.component('component', {..详见基础..})</div><div><span style=\"white-space: pre;\">\t\t</span>局部: components: { 'component': {..详见基础..} } （常用）</div><div><span style=\"white-space: pre;\">\t</span>3. 动态组件</div><div><span style=\"white-space: pre;\">\t\t</span>3.1 &lt;component :is=\"currentTabComponent\"&gt;&lt;/component&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>3.2 ('component', {</div><div><span style=\"white-space: pre;\">\t\t\t</span>render: (createElement) =&gt; { return createElement(...) }</div><div><span style=\"white-space: pre;\">\t\t</span>})</div><div><span style=\"white-space: pre;\">\t</span># createElement(</div><div><span style=\"white-space: pre;\">\t\t</span>'HTML/Component-Name', // 必填</div><div><span style=\"white-space: pre;\">\t\t</span>{ data / computed / methods&nbsp; }, // 可选</div><div><span style=\"white-space: pre;\">\t\t</span>['String', 'createElement(...)'] // 可选</div><div><span style=\"white-space: pre;\">\t</span>)</div><div><span style=\"white-space: pre;\">\t</span></div><div># 通常使用HTML语言来创建模板语法</div><div># 函数式模板-render函数通过传入函数,返回一个createElement函数的调用结果,创建虚拟DOM</div><div>var vm = new Vue({</div><div>&nbsp; &nbsp; el:\"#app\",</div><div>&nbsp; &nbsp; render:function(cE){</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>return cE('tag',tag属性集合{ class:..,style:..,});</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; # 返回一个虚拟DOM树替换VM</div><div>&nbsp; &nbsp; # 简写:render: c =&gt; c(...);</div><div>})</div><div><br></div><div>***********************************************************************************</div><div># 使用父组件</div><div>&nbsp; &nbsp; 1.数据</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>父: &lt;name-x :中间变量=父数据&gt;</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>子: props:[\"中间变量\"]</div><div>&nbsp; &nbsp; 2.方法</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 父: &lt;name-x v-on:\"中间变量\"=父方法&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 子: &lt;template v-on:click=\"子方法\"&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; this.$emit(\"中间变量\"，参数1...)</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div># 使用子组件数据</div><div><span style=\"white-space: pre;\">\t</span>数据/方法</div><div><span style=\"white-space: pre;\">\t\t</span>父: &lt;name-x ref='name'&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$refs.name.fun/data</div><div><span style=\"white-space: pre;\">\t\t</span></div><div># 兄弟组件：</div><div><span style=\"white-space: pre;\">\t</span>创建一个新Vue的实例，让各个兄弟共用同一个事件机制</div><div><span style=\"white-space: pre;\">\t</span>创建空模板：export default new Vue()</div><div><span style=\"white-space: pre;\">\t</span>注册: mounted() =&gt; emptyVue.$on(\"中间变量\",(参数)=&gt;{回调})}//注册事件</div><div><span style=\"white-space: pre;\">\t</span>触发: emptyVue.$emit(\"中间变量\"，参数...)</div></div><div><br></div><div><br></div><div><div># 路由能根据路径的不同而在VM机中展示不同的组件</div><div>1.导入&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>npm i vue-router</div><div>2.创建路由对象</div><div><span style=\"white-space: pre;\">\t</span>Vue.use(VueRouter);</div><div><span style=\"white-space: pre;\">\t</span>var rou = new VueRouter({</div><div><span style=\"white-space: pre;\">\t\t</span>routes:[</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则1<span style=\"white-space: pre;\">\t</span>{</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>path:'/'',redirect:\"/index\",component:组件,</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>children:[{path:'a1', component:目标组件}, ...]},</div><div><span style=\"white-space: pre;\">\t\t\t\t</span># children会被渲染到/index的router-view中</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则2<span style=\"white-space: pre;\">\t</span>{path:'/', component:?},</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则3<span style=\"white-space: pre;\">\t</span>{path:'/', component:?}]})</div><div>3.APP注册: router:路由对象,</div><div>4.使用路由</div><div><span style=\"white-space: pre;\">\t</span>JS访问:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>&lt;router-link :to=\"{ name:'user', params:{userId: 123} }\"&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.push({ name:'user', params:{userId: 123} });</div><div><span style=\"white-space: pre;\">\t</span>获得参数:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.query.id/name</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.params.id/name</div><div><span style=\"white-space: pre;\">\t\t</span>this.$route.params.name //当前路由</div><div>***********************************************************************************</div></div><div><br></div><div><div>npm install vuex --save</div><div>1.创建仓库入口 /store/index.js</div><div><span style=\"white-space: pre;\">\t</span>Vue.use(Vuex)</div><div><span style=\"white-space: pre;\">\t</span>export default Vuex.Store({ modules: {} })</div><div>2.</div></div><div><br></div><div><div>安装 Node.exe</div><div>全局安装</div><div><span style=\"white-space: pre;\">\t</span>vue i @vue/cli -g</div><div><span style=\"white-space: pre;\">\t</span>依赖 @vue/cli-service 进行配置/拓展</div><div>传统生成项目</div><div><span style=\"white-space: pre;\">\t</span>1.vue create name</div><div><span style=\"white-space: pre;\">\t</span>2.public/index.html 文件是一个会被 html-webpack-plugin 处理的模板</div><div><span style=\"white-space: pre;\">\t</span></div><div><span style=\"white-space: pre;\">\t</span># 调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象：</div><div><span style=\"white-space: pre;\">\t</span>// vue.config.js</div><div>&nbsp; &nbsp; module.exports = {</div><div>&nbsp; &nbsp; &nbsp; configureWebpack: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new MyAwesomeWebpackPlugin()]}}</div><div>项目本地测试</div><div><span style=\"white-space: pre;\">\t</span>npm run serve (vue-cli-service serve)</div><div><span style=\"white-space: pre;\">\t</span>命令会启动一个开发服务器 (基于 webpack-dev-server)&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>可以使用 vue.config.js 里的 devServer 字段配置开发服务器。</div><div>项目打包</div><div><span style=\"white-space: pre;\">\t</span>npm run serve (vue-cli-service build)</div><div><span style=\"white-space: pre;\">\t</span>会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，</div></div>"
    },
    "ANPJFN8G-": {
      "blockId": "D2S51gJkH",
      "shelfId": "V6rREb5rV",
      "bookId": "ANPJFN8G-",
      "name": "市场方向",
      "content": "<div>市场划分<br></div><div>&nbsp; &nbsp;&nbsp;中文互联网的产出在渐渐枯萎吗？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/49684783/answer/1088276178</div><div>&nbsp; &nbsp;&nbsp;为什么互联网行业工资高？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/32022042/answer/799455698</div><div>&nbsp; &nbsp;&nbsp;如何着手分析一个行业？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/20219092/answer/522122813</div><div>&nbsp; &nbsp;&nbsp;应届生 应该进企业做会计还是去代理记账公司？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/278572137/answer/636717479</div>"
    },
    "Er5eOORwd": {
      "blockId": "D2S51gJkH",
      "shelfId": "nP7h_-tlw",
      "bookId": "Er5eOORwd",
      "name": "待读书籍",
      "content": "<span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">资治通鉴直解&nbsp;</span><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">张居正</span><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">未来地图&nbsp;</span>这本书关注了很多新兴的互联网技术、业态、模式，以及背后的商业思维<br></span></div><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">浪潮之巅&nbsp;</span>吴军 互联网产业科普向</span></div><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">两次全球大危机的比较研究&nbsp;刘鹤</span><br></span></div><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">四书集注&nbsp;</span></span></span>朱子读书法<span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">&nbsp;</span>朱熹</div><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><p>董筱丹、温铁军的《去依附》，图书管理员第一卷第一篇第三自然段。</p><p>纳西姆塔勒布《随机致富的傻瓜》《黑天鹅》《反脆弱》《非对称风险》。</p><p>庆祝新中国成立七十周年：马化腾</p><p><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">建议所有职场新人都看看《沧浪之水》或者改编的电视剧《岁月》</span><br></p><p>时代的见证者（陈润）重新发现改革&nbsp;界限下的中国（吴建新/钟庆）</p></span></div></span>"
    },
    "BUjFzVykf": {
      "blockId": "D2S51gJkH",
      "shelfId": "nP7h_-tlw",
      "bookId": "BUjFzVykf",
      "name": "Web面试题",
      "content": "面试题<div>&nbsp; &nbsp;&nbsp;前端面试分享: 两年经验社招-阿里巴巴（已经通过）</div><div>&nbsp; &nbsp; https://zhuanlan.zhihu.com/p/83801858</div><div>&nbsp; &nbsp;&nbsp;前端开发，在不要求学历的前提下，什么水平能进百度 阿里 华为 b站的大公司？</div><div>&nbsp; &nbsp; https://www.zhihu.com/collection/46005262</div><div>&nbsp; &nbsp;&nbsp;毕业一年左右的前端妹子面经总结</div><div>&nbsp; &nbsp;&nbsp;https://zhuanlan.zhihu.com/p/74229306</div>"
    },
    "Str9BOQqz": {
      "blockId": "CvCnS_7t1",
      "shelfId": "LarGoKp5H",
      "bookId": "Str9BOQqz",
      "name": "5-1 劳动节",
      "content": ""
    },
    "ySGXXuc4w": {
      "blockId": "CvCnS_7t1",
      "shelfId": "cMqIIVAY-",
      "bookId": "ySGXXuc4w",
      "name": "123",
      "content": ""
    },
    "mquJg1yJ2": {
      "blockId": "D2S51gJkH",
      "shelfId": "nP7h_-tlw",
      "bookId": "mquJg1yJ2",
      "name": "公司账号",
      "content": "JIRA<div>&nbsp; &nbsp; huangwenqiang</div><div>&nbsp; &nbsp; a123456789</div><div><br></div><div>Gitlab</div><div>&nbsp; &nbsp;&nbsp;wqao123456</div><div>&nbsp; &nbsp; 974879409</div><div><br></div><div><div>项目设计稿原型：</div><div>&nbsp; &nbsp; 金邻APP：https://ku1nos.axshare.com</div><div>&nbsp; &nbsp; 岛主APP：https://ee6atz.axshare.com</div><div>&nbsp; &nbsp; 蓝湖设计稿：https://lanhuapp.com/url/Ys9wV-87ZWO</div></div>"
    },
    "LkvISEGBt": {
      "blockId": "D2S51gJkH",
      "shelfId": "OrVbgLEFn",
      "bookId": "LkvISEGBt",
      "name": "数学分析(计算)",
      "content": ""
    },
    "pniXFB7J_": {
      "blockId": "D2S51gJkH",
      "shelfId": "OrVbgLEFn",
      "bookId": "pniXFB7J_",
      "name": "线性代数",
      "content": ""
    },
    "URxABKpVt": {
      "blockId": "D2S51gJkH",
      "shelfId": "OrVbgLEFn",
      "bookId": "URxABKpVt",
      "name": "统计学",
      "content": ""
    },
    "1D-3MKtm4": {
      "blockId": "CvCnS_7t1",
      "shelfId": "qoV8Oj9OL",
      "bookId": "1D-3MKtm4",
      "name": "设计模式",
      "content": ""
    },
    "BYaBjiNeF": {
      "blockId": "D2S51gJkH",
      "shelfId": "qnCrFmOHS",
      "bookId": "BYaBjiNeF",
      "name": "q",
      "content": ""
    },
    "7F7ppyypt": {
      "blockId": "GWl8k8C7I",
      "shelfId": "Mjg_nvG3K",
      "bookId": "7F7ppyypt",
      "name": "20/04/03《游戏设计模式》",
      "content": "<div>1.命令模式<br></div><div><br></div><div><br></div><div><div><font color=\"#ff0000\"><b>参考文章</b></font></div><div>&nbsp; &nbsp; *&nbsp;游戏编程模式 Robert Nystrom&nbsp;<font color=\"#4169e1\"><b>kindle</b></font></div></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; *&nbsp;</b></font>*&nbsp;使用你不需要它作为口头禅，用它来与猜测未来的自己会想要什么这种冲动进行斗争。</div>"
    },
    "k8ihIx7WZ": {
      "blockId": "CvCnS_7t1",
      "shelfId": "mmbc6CSOP",
      "bookId": "k8ihIx7WZ",
      "name": "200403",
      "content": "&nbsp; &nbsp; * 简单了解了常用设计模式<div>&nbsp; &nbsp; &nbsp; &nbsp; **&nbsp;前端开发 -&nbsp;计算机体系 -&nbsp;设计模式</div>"
    },
    "nK3allQck": {
      "blockId": "Q7eHmettS",
      "shelfId": "g7ISl8mtw",
      "bookId": "nK3allQck",
      "name": "321",
      "content": ""
    },
    "mDpDCHrBv": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "mDpDCHrBv",
      "name": "JavaScript包管理",
      "content": "<font color=\"#ff0000\"><b>NPM</b></font><div>&nbsp; &nbsp; 淘宝镜像</div><div><span style=\"white-space: pre;\">\t</span>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ npm config edit&nbsp;registry=https://registry.npm.taobao.org/</div><div><br></div><div>初始化包管理文件</div><div><span style=\"white-space: pre;\">\t</span>$ npm init -y // 产生 package.json</div><div><span style=\"white-space: pre;\">\t</span></div><div>搜索模块</div><div><span style=\"white-space: pre;\">\t</span>$ npm search</div><div><span style=\"white-space: pre;\">\t</span></div><div>安装</div><div><span style=\"white-space: pre;\">\t</span>$ npm install moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -g moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到全局，不会在项目node_modules目录中保存模块包。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save-dev moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入devDependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>删除包</div><div><span style=\"white-space: pre;\">\t</span>$ npm uninstall/remove name</div><div><span style=\"white-space: pre;\">\t</span></div><div>当导入一个包时：require('vue')</div><div>&nbsp; &nbsp; 1.找到对应的 node_modules</div><div>&nbsp; &nbsp; 2.找到require的包文件夹</div><div>&nbsp; &nbsp; 3.根据package.json找到需要的JS库文件</div>"
    },
    "jktBHDMdz": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "jktBHDMdz",
      "name": "VS Code",
      "content": "<div>prettier.config.js<br></div><div>{</div><div>&nbsp; &nbsp; // ***************** 必备 *****************</div><div>&nbsp; &nbsp; // 自动格式化</div><div>&nbsp; &nbsp; \"editor.formatOnSave\": true,</div><div><br></div><div>&nbsp; &nbsp; // Tab缩进为4个空格</div><div>&nbsp; &nbsp; \"prettier.tabWidth\": 4,</div><div><br></div><div>&nbsp; &nbsp; // 统一使用单引号</div><div>&nbsp; &nbsp; \"prettier.singleQuote\": true,</div><div><br></div><div>&nbsp; &nbsp; // ***************** 其他 *****************</div><div>&nbsp; &nbsp; // 是否自动添加分号</div><div>&nbsp; &nbsp; \"prettier.semi\": false,</div><div><br></div><div>&nbsp; &nbsp; // { / }两侧必须有空格</div><div>&nbsp; &nbsp; \"prettier.bracketSpacing\": true,</div><div><br></div><div>&nbsp; &nbsp; // 单参数箭头函数 总是带()</div><div>&nbsp; &nbsp; \"prettier.arrowParens\": \"always\",</div><div><br></div><div>&nbsp; &nbsp; // vue 模板/样式的缩进</div><div>&nbsp; &nbsp; \"prettier.vueIndentScriptAndStyle\": true</div><div>}</div>"
    },
    "41aId-_Yz": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "41aId-_Yz",
      "name": "Git",
      "content": "<div><b style=\"color: rgb(255, 0, 0);\">Git：流程管理</b><br></div><div><div><div>1.在代码托管区创建远程仓库</div><div>&nbsp; &nbsp; - 局域网: GitLab</div><div>&nbsp; &nbsp; - 外网: Github/码云</div><div>&nbsp; &nbsp;&nbsp;</div><div>2.获取</div><div><span style=\"white-space: pre;\">\t</span>- 创建本地仓库</div><div><span style=\"white-space: pre;\">\t\t</span>$ git init</div><div><span style=\"white-space: pre;\">\t</span>- 通过远程仓库提供的 URL 克隆代码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - HTTPS: 需要手动输入服务器账号密码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - SSH: 需要本地生成/服务器设置SSH keys</div><div><span style=\"white-space: pre;\">\t\t</span>$ git clone [url]</div><div>&nbsp; &nbsp; - 查看这个项目对应的远程仓库</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git remote -v</div><div><span style=\"white-space: pre;\">\t</span>- 获取最新代码</div><div><span style=\"white-space: pre;\">\t\t</span>$ git pull</div><div><span style=\"white-space: pre;\">\t\t</span>- git fetch: 获取远程代码</div><div><span style=\"white-space: pre;\">\t\t</span>- git merge: 和本地库合并</div><div><span style=\"white-space: pre;\">\t</span></div><div>3.本地更改</div><div><span style=\"white-space: pre;\">\t</span>- 工作区 → 暂存区</div><div>&nbsp; &nbsp; $ git add readme.txt</div><div>&nbsp; &nbsp; - 暂存区 → 本地库</div><div>&nbsp; &nbsp; $ git commit -m \"description\"</div><div>&nbsp; &nbsp;&nbsp;</div><div>4.查看本地版本</div><div><span style=\"white-space: pre;\">\t</span>- 查看工作区及暂存区的状态</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git status</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on branch master</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no commits yet</div><div><span style=\"white-space: pre;\">\t</span>- 想知道历史提交 /空格翻页/b向上/q退出</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log -pretty=oneline 或 git reflog // 获取索引值</div><div>&nbsp; &nbsp; - 本地回退版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 通过对 HEAD 指针来决定本地版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reflog // 获取索引值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reset --hard 'key' // 设置 HEAD 指针</div><div>&nbsp; &nbsp; - 比较</div><div>&nbsp; &nbsp; &nbsp; &nbsp; git 以ROW为比较单位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git diff [(或)文件名/版本] // 查看明细</div><div><div>&nbsp; &nbsp; &nbsp; 生成本地 SSH keys 用于提供远程仓库访问权限</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.生成本地SSH目录</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ ssh-keygen -t rsa -C '邮箱/账号'</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.查看生成的SSH keys</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ cat id_rsa.pub</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.在托管服务器上设置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 添加 SSH keys&nbsp;</div><div>&nbsp; &nbsp; # 外包<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git fork 关联复制</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ pull request 分支发起请求</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ merge 同意请求并合并</div><div>配置签名<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 提交时用于标识开发人员身份/与服务器账号密码无关</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 项目级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.email</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 系统级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.name \"Your Name\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.email \"email@example.com\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 这些信息会保存到 .git/config 中</div></div></div></div>"
    },
    "aiHo80uXw": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "aiHo80uXw",
      "name": "Web项目发布打包",
      "content": "<div><font color=\"#ff0000\"><b>Webpack</b></font></div>浏览器的限制<div>&nbsp; &nbsp; # 介绍</div><div>&nbsp; &nbsp; 目前的浏览器(内嵌渲染引擎/JS引擎)只支持 HTML/CSS/JavaScript 为基础的页面</div><div>&nbsp; &nbsp; - JS引擎有语法标准(ECMAScript)，而高级语法需要转译</div><div>&nbsp; &nbsp; * 模块化需求</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>原生HTML通过直接引用CSS/图片/JS代码形式无法适应大规模开发</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>于是通过模块化把一个复杂的系统分解到多个模块以方便编码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.CommonJS规范 - require同步加载/modules.exports暴露接口</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.AMD规范 - 需要第三方库requireJS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.ES6 / import/export 目前无法直接运行在大部分 JavaScript 运行环境下</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>目前的模块化方案都需要工具转译为 HTML/CSS/JavaScript</div><div>&nbsp; &nbsp; * 框架语法需要转译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; React JSX 语法需要转译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Vue 组件系统包含大量新语法 需要转译</div><div>&nbsp; &nbsp; * 新语言需要转译</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>TypeScript/SCSS 无法直接执行</div><div><br></div><div>使用说明</div><div><br></div><div><div># 介绍</div><div>&nbsp; &nbsp; 不断出现的 模块化/新语言/新框架 需求</div><div>&nbsp; &nbsp; 我们需要构建工具，在编写完代码后生成能在线上运行的代码</div><div><br></div><div># 目标</div><div>&nbsp; &nbsp; 模块合并：通过构建功能一次HTTP请求完所有需要的图片/等资源(bundle.js)</div><div>&nbsp; &nbsp; 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</div><div>&nbsp; &nbsp; 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</div><div>&nbsp; &nbsp; 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</div><div>&nbsp; &nbsp; 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</div><div>&nbsp; &nbsp; 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</div><div>&nbsp; &nbsp; 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</div><div><br></div><div># /dist/index.html( &lt;= bundle script) # Step 3 后不需要</div><div># /src/index.js</div><div># webpack-config.js</div><div># package.json</div><div><span style=\"white-space: pre;\">\t</span>\"start\": \"webpack-dev-server --open\"</div><div><span style=\"white-space: pre;\">\t</span>\"build\": \"webpack\" 或 \"webpack --config webpack-config.js\"</div></div><div><br></div><div>webpack.config.js</div><div><br></div><div><div>const path = require(\"path\");</div><div>const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); # Step 3</div><div>const CleanWebpackPlugin = require(\"clean-webpack-plugin\"); # Step 4</div><div><br></div><div>module.exports = {</div><div>&nbsp; &nbsp; # Step 1 基础功能</div><div>&nbsp; &nbsp; # 补充</div><div>&nbsp; &nbsp; mode: \"development\", // * 打包模式</div><div>&nbsp; &nbsp; devtool: \"inline-source-map\", // * 错误定位</div><div>&nbsp; &nbsp; # 打包路径</div><div>&nbsp; &nbsp; entry: \"./src/index.js\",</div><div>&nbsp; &nbsp; output: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; filename: \"bundle.js\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; path: path.resolve(__dirname, \"dist\")</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # Step 5 服务器模式：能够重新进行build加载（刷新了页面）</div><div>&nbsp; &nbsp; devServer: {</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>contentBase: { \"./dist\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; port: 8080,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hot: true, // * 局部刷新时需要开起</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # 打包内容</div><div>&nbsp; &nbsp; module: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; rules: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Step 2 加载样式/图片</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的样式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的图片</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - url-loader 依赖于 file-loader 用于图片优化/base64</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - base64 &lt;= options.limit(bit) &lt;=&nbsp; Img // 8192bit = 1024b = 1kb</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.(png|svg|jpg|gif)$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"file-loader\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"url-loader\", options: { limit: 8192 } }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><span style=\"white-space: pre;\">\t\t</span>]</div><div><span style=\"white-space: pre;\">\t</span>},</div><div>&nbsp; &nbsp; # 外部插件</div><div>&nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 3 自动生成 dist/Html 入口文件</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new HtmlWebpackPlugin({</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: \"MyLib\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; template: \"./src/packTemplate.html\" // 导出的模板</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // favicon: \"path/to/yourfile.ico\" // Link图标</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 4 打包前清空 dist 目录</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new CleanWebpackPlugin()</div><div>&nbsp; &nbsp; ]</div><div>};</div></div>"
    },
    "l52ksXno0": {
      "blockId": "D2S51gJkH",
      "shelfId": "l6ztlKkVv",
      "bookId": "l52ksXno0",
      "name": "服务器部署",
      "content": "<div>0.常用工具</div><div>&nbsp; &nbsp;&nbsp;Xftp / Xshell</div><div>1.常见服务器装配（运维）</div><div>&nbsp; &nbsp; * OS：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Windows</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - linux内核：Cento /&nbsp;Ubuntu</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Unix内核：...垄断着大型企业的关键性应用领域</div><div>&nbsp; &nbsp; *&nbsp;服务器程序：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Web/HTTP：只需支持HTTP协议（Tomcat，Windows IIS，Apache，Nginx）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 特定应用：支持各种协议并提供服务（<span style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px;\">BEA&nbsp;</span>Weblogic，<span style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px;\">IBM&nbsp;</span>WebSphere）</div>"
    },
    "lgh3QeiVg": {
      "blockId": "D2S51gJkH",
      "shelfId": "I5m9i2k-e",
      "bookId": "lgh3QeiVg",
      "name": "Js生态圈",
      "content": "<div>1.传统网站开发</div><div><br></div><div>&nbsp; &nbsp; 通常是一套代码进行样式适配，再部署到 PC / Mobile 不同平台，最后通过浏览器软件进行访问&nbsp; &nbsp;</div><div><br></div><div>2.移动端开发</div><div><br></div><div>&nbsp; &nbsp; Native APP (原生APP)</div><div>&nbsp; &nbsp; - Android：Java / IOS：Object-C/Swift 等</div><div><br></div><div>&nbsp; &nbsp; Hybrid APP (混合开发)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 是一种用Native技术来搭建本地Web环境，内容主要通过Web技术来提供的移动应用</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 主要开发技术</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Uni-App：自研Wxs技术降低视图层与语言引擎通信耗损</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - React-Native：JavaScript引擎，不同平台需要不同UI</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Flutter：Dart引擎，是纯粹的渲染引擎，简单、高性能，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 但由于Dart语法使得维护性/代码可读性很差，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不支持动态热更新，不同平台需要不同UI</div><div><br></div><div>3.客户端开发</div><div>&nbsp; &nbsp; Electron（@github）原来叫 Atom Shell</div><div><br></div><div>参考文章</div><div>&nbsp; &nbsp; Flutter、React-Native、Uni-App比较：https://ask.dcloud.net.cn/article/36083</div>"
    },
    "hbdOGIxvE": {
      "blockId": "D2S51gJkH",
      "shelfId": "I5m9i2k-e",
      "bookId": "hbdOGIxvE",
      "name": "Js包管理",
      "content": "<div>NPM</div><div>&nbsp; &nbsp; 淘宝镜像</div><div><span style=\"white-space:pre\">\t</span>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ npm config edit registry=https://registry.npm.taobao.org/</div><div><br></div><div>初始化包管理文件</div><div><span style=\"white-space:pre\">\t</span>$ npm init -y // 产生 package.json</div><div><span style=\"white-space:pre\">\t</span></div><div>搜索模块</div><div><span style=\"white-space:pre\">\t</span>$ npm search</div><div><span style=\"white-space:pre\">\t</span></div><div>安装</div><div><span style=\"white-space:pre\">\t</span>$ npm install moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -g moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到全局，不会在项目node_modules目录中保存模块包。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save-dev moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入devDependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>删除包</div><div><span style=\"white-space:pre\">\t</span>$ npm uninstall/remove name</div><div><span style=\"white-space:pre\">\t</span></div><div>当导入一个包时：require('vue')</div><div>&nbsp; &nbsp; 1.找到对应的 node_modules</div><div>&nbsp; &nbsp; 2.找到require的包文件夹</div><div>&nbsp; &nbsp; 3.根据package.json找到需要的JS库文件</div>"
    },
    "gYm3hCjRO": {
      "blockId": "D2S51gJkH",
      "shelfId": "I5m9i2k-e",
      "bookId": "gYm3hCjRO",
      "name": "VS Code",
      "content": "<div>prettier.config.js</div><div>{</div><div>&nbsp; &nbsp; // ***************** 必备 *****************</div><div>&nbsp; &nbsp; // 自动格式化</div><div>&nbsp; &nbsp; \"editor.formatOnSave\": true,</div><div><br></div><div>&nbsp; &nbsp; // Tab缩进为4个空格</div><div>&nbsp; &nbsp; \"prettier.tabWidth\": 4,</div><div><br></div><div>&nbsp; &nbsp; // 统一使用单引号</div><div>&nbsp; &nbsp; \"prettier.singleQuote\": true,</div><div><br></div><div>&nbsp; &nbsp; // ***************** 其他 *****************</div><div>&nbsp; &nbsp; // 是否自动添加分号</div><div>&nbsp; &nbsp; \"prettier.semi\": false,</div><div><br></div><div>&nbsp; &nbsp; // { / }两侧必须有空格</div><div>&nbsp; &nbsp; \"prettier.bracketSpacing\": true,</div><div><br></div><div>&nbsp; &nbsp; // 单参数箭头函数 总是带()</div><div>&nbsp; &nbsp; \"prettier.arrowParens\": \"always\",</div><div><br></div><div>&nbsp; &nbsp; // vue 模板/样式的缩进</div><div>&nbsp; &nbsp; \"prettier.vueIndentScriptAndStyle\": true</div><div>}</div>"
    },
    "TDv04-Zta": {
      "blockId": "D2S51gJkH",
      "shelfId": "I5m9i2k-e",
      "bookId": "TDv04-Zta",
      "name": "Git",
      "content": "<div>Git</div><div>1.在代码托管区创建远程仓库</div><div>&nbsp; &nbsp; - 局域网: GitLab</div><div>&nbsp; &nbsp; - 外网: Github/码云</div><div>&nbsp; &nbsp;&nbsp;</div><div>2.获取</div><div><span style=\"white-space:pre\">\t</span>- 创建本地仓库</div><div><span style=\"white-space:pre\">\t\t</span>$ git init</div><div><span style=\"white-space:pre\">\t</span>- 通过远程仓库提供的 URL 克隆代码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - HTTPS: 需要手动输入服务器账号密码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - SSH: 需要本地生成/服务器设置SSH keys</div><div><span style=\"white-space:pre\">\t\t</span>$ git clone [url]</div><div>&nbsp; &nbsp; - 查看这个项目对应的远程仓库</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git remote -v</div><div><span style=\"white-space:pre\">\t</span>- 获取最新代码</div><div><span style=\"white-space:pre\">\t\t</span>$ git pull</div><div><span style=\"white-space:pre\">\t\t</span>- git fetch: 获取远程代码</div><div><span style=\"white-space:pre\">\t\t</span>- git merge: 和本地库合并</div><div><span style=\"white-space:pre\">\t</span></div><div>3.本地更改</div><div><span style=\"white-space:pre\">\t</span>- 工作区 → 暂存区</div><div>&nbsp; &nbsp; $ git add readme.txt</div><div>&nbsp; &nbsp; - 暂存区 → 本地库</div><div>&nbsp; &nbsp; $ git commit -m \"description\"</div><div>&nbsp; &nbsp;&nbsp;</div><div>4.查看本地版本</div><div><span style=\"white-space:pre\">\t</span>- 查看工作区及暂存区的状态</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git status</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on branch master</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no commits yet</div><div><span style=\"white-space:pre\">\t</span>- 想知道历史提交 /空格翻页/b向上/q退出</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log -pretty=oneline 或 git reflog // 获取索引值</div><div>&nbsp; &nbsp; - 本地回退版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 通过对 HEAD 指针来决定本地版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reflog // 获取索引值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reset --hard 'key' // 设置 HEAD 指针</div><div>&nbsp; &nbsp; - 比较</div><div>&nbsp; &nbsp; &nbsp; &nbsp; git 以ROW为比较单位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git diff [(或)文件名/版本] // 查看明细</div><div>&nbsp; &nbsp; &nbsp; 生成本地 SSH keys 用于提供远程仓库访问权限</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.生成本地SSH目录</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ ssh-keygen -t rsa -C '邮箱/账号'</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.查看生成的SSH keys</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ cat id_rsa.pub</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.在托管服务器上设置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 添加 SSH keys&nbsp;</div><div>&nbsp; &nbsp; # 外包</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git fork 关联复制</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ pull request 分支发起请求</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ merge 同意请求并合并</div><div>配置签名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 提交时用于标识开发人员身份/与服务器账号密码无关</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 项目级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.email</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 系统级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.name \"Your Name\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.email \"email@example.com\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 这些信息会保存到 .git/config 中</div>"
    },
    "1OKwhTthP": {
      "blockId": "D2S51gJkH",
      "shelfId": "I5m9i2k-e",
      "bookId": "1OKwhTthP",
      "name": "Web项目发布生产包",
      "content": "<div>Webpack</div><div>浏览器的限制</div><div>&nbsp; &nbsp; # 介绍</div><div>&nbsp; &nbsp; 目前的浏览器(内嵌渲染引擎/JS引擎)只支持 HTML/CSS/JavaScript 为基础的页面</div><div>&nbsp; &nbsp; - JS引擎有语法标准(ECMAScript)，而高级语法需要转译</div><div>&nbsp; &nbsp; * 模块化需求</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>原生HTML通过直接引用CSS/图片/JS代码形式无法适应大规模开发</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>于是通过模块化把一个复杂的系统分解到多个模块以方便编码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.CommonJS规范 - require同步加载/modules.exports暴露接口</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.AMD规范 - 需要第三方库requireJS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.ES6 / import/export 目前无法直接运行在大部分 JavaScript 运行环境下</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>目前的模块化方案都需要工具转译为 HTML/CSS/JavaScript</div><div>&nbsp; &nbsp; * 框架语法需要转译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; React JSX 语法需要转译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Vue 组件系统包含大量新语法 需要转译</div><div>&nbsp; &nbsp; * 新语言需要转译</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>TypeScript/SCSS 无法直接执行</div><div><br></div><div>使用说明</div><div><br></div><div># 介绍</div><div>&nbsp; &nbsp; 不断出现的 模块化/新语言/新框架 需求</div><div>&nbsp; &nbsp; 我们需要构建工具，在编写完代码后生成能在线上运行的代码</div><div><br></div><div># 目标</div><div>&nbsp; &nbsp; 模块合并：通过构建功能一次HTTP请求完所有需要的图片/等资源(bundle.js)</div><div>&nbsp; &nbsp; 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</div><div>&nbsp; &nbsp; 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</div><div>&nbsp; &nbsp; 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</div><div>&nbsp; &nbsp; 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</div><div>&nbsp; &nbsp; 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</div><div>&nbsp; &nbsp; 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</div><div><br></div><div># /dist/index.html( &lt;= bundle script) # Step 3 后不需要</div><div># /src/index.js</div><div># webpack-config.js</div><div># package.json</div><div><span style=\"white-space:pre\">\t</span>\"start\": \"webpack-dev-server --open\"</div><div><span style=\"white-space:pre\">\t</span>\"build\": \"webpack\" 或 \"webpack --config webpack-config.js\"</div><div><br></div><div>webpack.config.js</div><div><br></div><div>const path = require(\"path\");</div><div>const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); # Step 3</div><div>const CleanWebpackPlugin = require(\"clean-webpack-plugin\"); # Step 4</div><div><br></div><div>module.exports = {</div><div>&nbsp; &nbsp; # Step 1 基础功能 ======================================================</div><div>&nbsp; &nbsp; # 补充</div><div>&nbsp; &nbsp; mode: \"development\", // * 打包模式</div><div>&nbsp; &nbsp; devtool: \"inline-source-map\", // * 错误定位</div><div>&nbsp; &nbsp; # 打包路径</div><div>&nbsp; &nbsp; entry: \"./src/index.js\",</div><div>&nbsp; &nbsp; output: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; filename: \"bundle.js\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; path: path.resolve(__dirname, \"dist\")</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # Step 5 服务器模式：能够重新进行build加载（刷新了页面）</div><div>&nbsp; &nbsp; devServer: {</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>contentBase: { \"./dist\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; port: 8080,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hot: true, // * 局部刷新时需要开起</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # 打包内容</div><div>&nbsp; &nbsp; module: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; rules: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Step 2 加载样式/图片 ==========================================</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的样式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的图片</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - url-loader 依赖于 file-loader 用于图片优化/base64</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - base64 &lt;= options.limit(bit) &lt;=&nbsp; Img // 8192bit = 1024b = 1kb</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.(png|svg|jpg|gif)$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"file-loader\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"url-loader\", options: { limit: 8192 } }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><span style=\"white-space:pre\">\t\t</span>]</div><div><span style=\"white-space:pre\">\t</span>},</div><div>&nbsp; &nbsp; # 外部插件</div><div>&nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 3 自动生成 dist/Html 入口文件 ==================================</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new HtmlWebpackPlugin({</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: \"MyLib\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; template: \"./src/packTemplate.html\" // 导出的模板</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // favicon: \"path/to/yourfile.ico\" // Link图标</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 4 打包前清空 dist 目录 =========================================</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new CleanWebpackPlugin()</div><div>&nbsp; &nbsp; ]</div><div>};</div>"
    },
    "SJ3X0mnT9": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "SJ3X0mnT9",
      "name": "Vue",
      "content": "<div><font color=\"#ff0000\"><b>开发Tips</b></font></div><div>&nbsp; &nbsp;<font color=\"#4169e1\"><b>&nbsp;*&nbsp;动态加载图片&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 起因：在webpack中会将图片图片来当做模块来用，url-loader将无法解析图片地址</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 解决方法：1.将图片作为模块加载 2.将图片放入static目录+绝对路径</div><div>&nbsp; &nbsp;<font color=\"#4169e1\"><b>&nbsp;*&nbsp;强制渲染DOM&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;Vue.set(target, key, newValue)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Object.assign({}, old, new)</div><div><br></div><div><font color=\"#ff0000\"><b>生命周期</b></font></div><div>&nbsp; &nbsp; beforeCreate =&gt; 初始化事件/生命周期</div><div><span style=\"white-space: pre;\">\t\t</span>created&nbsp;</div><div><span style=\"white-space: pre;\">\t\t\t</span>=&gt; 根据el:#app调用 vm.$mount(\"#app\")</div><div><span style=\"white-space: pre;\">\t\t\t</span>=&gt; 根据template编译到 vm.render 中</div><div><span style=\"white-space: pre;\">\t\t</span>beforeMount =&gt; vm.$el = DOM</div><div><span style=\"white-space: pre;\">\t\t</span>mounted =&gt; beforeUpdate &lt;=&gt; update =&gt; vm.$destroy()</div><div><span style=\"white-space: pre;\">\t\t</span>destroyed</div><div><br></div><div><font color=\"#ff0000\"><b>Vue实例</b></font></div><div>组件是可以复用的 Vue 实例</div><div><span style=\"white-space: pre;\">\t</span>1. 组件控制模板字符串\"&lt;templete&gt;\"/单vue文件</div><div><span style=\"white-space: pre;\">\t</span>2. 注册</div><div><span style=\"white-space: pre;\">\t\t</span>全局: Vue.component('component', {..详见基础..})</div><div><span style=\"white-space: pre;\">\t\t</span>局部: components: { 'component': {..详见基础..} } （常用）</div><div><span style=\"white-space: pre;\">\t</span>3. 动态组件</div><div><span style=\"white-space: pre;\">\t\t</span>3.1 &lt;component :is=\"currentTabComponent\"&gt;&lt;/component&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>3.2 ('component', {</div><div><span style=\"white-space: pre;\">\t\t\t</span>render: (createElement) =&gt; { return createElement(...) }</div><div><span style=\"white-space: pre;\">\t\t</span>})</div><div><span style=\"white-space: pre;\">\t</span># createElement(</div><div><span style=\"white-space: pre;\">\t\t</span>'HTML/Component-Name', // 必填</div><div><span style=\"white-space: pre;\">\t\t</span>{ data / computed / methods&nbsp; }, // 可选</div><div><span style=\"white-space: pre;\">\t\t</span>['String', 'createElement(...)'] // 可选</div><div><span style=\"white-space: pre;\">\t</span>)</div><div><span style=\"white-space: pre;\">\t</span></div><div># 通常使用HTML语言来创建模板语法</div><div># 函数式模板-render函数通过传入函数,返回一个createElement函数的调用结果,创建虚拟DOM</div><div>var vm = new Vue({</div><div>&nbsp; &nbsp; el:\"#app\",</div><div>&nbsp; &nbsp; render:function(cE){</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>return cE('tag',tag属性集合{ class:..,style:..,});</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; # 返回一个虚拟DOM树替换VM</div><div>&nbsp; &nbsp; # 简写:render: c =&gt; c(...);</div><div>})</div><div><br></div><div>***********************************************************************************</div><div># 使用父组件</div><div>&nbsp; &nbsp; 1.数据</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>父: &lt;name-x :中间变量=父数据&gt;</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>子: props:[\"中间变量\"]</div><div>&nbsp; &nbsp; 2.方法</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 父: &lt;name-x v-on:\"中间变量\"=父方法&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 子: &lt;template v-on:click=\"子方法\"&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; this.$emit(\"中间变量\"，参数1...)</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div># 使用子组件数据</div><div><span style=\"white-space: pre;\">\t</span>数据/方法</div><div><span style=\"white-space: pre;\">\t\t</span>父: &lt;name-x ref='name'&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$refs.name.fun/data</div><div><span style=\"white-space: pre;\">\t\t</span></div><div># 兄弟组件：</div><div><span style=\"white-space: pre;\">\t</span>创建一个新Vue的实例，让各个兄弟共用同一个事件机制</div><div><span style=\"white-space: pre;\">\t</span>创建空模板：export default new Vue()</div><div><span style=\"white-space: pre;\">\t</span>注册: mounted() =&gt; emptyVue.$on(\"中间变量\",(参数)=&gt;{回调})}//注册事件</div><div><span style=\"white-space: pre;\">\t</span>触发: emptyVue.$emit(\"中间变量\"，参数...)</div><div><br></div><div><br></div><div># 路由能根据路径的不同而在VM机中展示不同的组件</div><div>1.导入&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>npm i vue-router</div><div>2.创建路由对象</div><div><span style=\"white-space: pre;\">\t</span>Vue.use(VueRouter);</div><div><span style=\"white-space: pre;\">\t</span>var rou = new VueRouter({</div><div><span style=\"white-space: pre;\">\t\t</span>routes:[</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则1<span style=\"white-space: pre;\">\t</span>{</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>path:'/'',redirect:\"/index\",component:组件,</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>children:[{path:'a1', component:目标组件}, ...]},</div><div><span style=\"white-space: pre;\">\t\t\t\t</span># children会被渲染到/index的router-view中</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则2<span style=\"white-space: pre;\">\t</span>{path:'/', component:?},</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则3<span style=\"white-space: pre;\">\t</span>{path:'/', component:?}]})</div><div>3.APP注册: router:路由对象,</div><div>4.使用路由</div><div><span style=\"white-space: pre;\">\t</span>JS访问:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>&lt;router-link :to=\"{ name:'user', params:{userId: 123} }\"&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.push({ name:'user', params:{userId: 123} });</div><div><span style=\"white-space: pre;\">\t</span>获得参数:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.query.id/name</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.params.id/name</div><div><span style=\"white-space: pre;\">\t\t</span>this.$route.params.name //当前路由</div><div>***********************************************************************************</div><div><br></div><div>npm install vuex --save</div><div>1.创建仓库入口 /store/index.js</div><div><span style=\"white-space: pre;\">\t</span>Vue.use(Vuex)</div><div><span style=\"white-space: pre;\">\t</span>export default Vuex.Store({ modules: {} })</div><div>2.</div><div><br></div><div>安装 Node.exe</div><div>全局安装</div><div><span style=\"white-space: pre;\">\t</span>vue i @vue/cli -g</div><div><span style=\"white-space: pre;\">\t</span>依赖 @vue/cli-service 进行配置/拓展</div><div>传统生成项目</div><div><span style=\"white-space: pre;\">\t</span>1.vue create name</div><div><span style=\"white-space: pre;\">\t</span>2.public/index.html 文件是一个会被 html-webpack-plugin 处理的模板</div><div><span style=\"white-space: pre;\">\t</span></div><div><span style=\"white-space: pre;\">\t</span># 调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象：</div><div><span style=\"white-space: pre;\">\t</span>// vue.config.js</div><div>&nbsp; &nbsp; module.exports = {</div><div>&nbsp; &nbsp; &nbsp; configureWebpack: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new MyAwesomeWebpackPlugin()]}}</div><div>项目本地测试</div><div><span style=\"white-space: pre;\">\t</span>npm run serve (vue-cli-service serve)</div><div><span style=\"white-space: pre;\">\t</span>命令会启动一个开发服务器 (基于 webpack-dev-server)&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>可以使用 vue.config.js 里的 devServer 字段配置开发服务器。</div><div>项目打包</div><div><span style=\"white-space: pre;\">\t</span>npm run serve (vue-cli-service build)</div><div><span style=\"white-space: pre;\">\t</span>会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，</div>"
    },
    "OXCmUpCOP": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "OXCmUpCOP",
      "name": "前端生态圈",
      "content": "<div><font color=\"#4169e1\"><b>1.传统网站开发</b></font></div><div><br></div><div>&nbsp; &nbsp; 通常是一套代码进行样式适配，再部署到 PC / Mobile 不同平台，最后通过浏览器软件进行访问&nbsp; &nbsp;</div><div><br></div><div><font color=\"#4169e1\"><b>2.移动端开发</b></font></div><div><br></div><div>&nbsp; &nbsp; Native APP (原生APP)</div><div>&nbsp; &nbsp; - Android：Java / IOS：Object-C/Swift 等</div><div><br></div><div>&nbsp; &nbsp; Hybrid APP (混合开发)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 是一种用Native技术来搭建本地Web环境，内容主要通过Web技术来提供的移动应用</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 主要开发技术</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Uni-App：自研Wxs技术降低视图层与语言引擎通信耗损</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - React-Native：JavaScript引擎，不同平台需要不同UI</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Flutter：Dart引擎，是纯粹的渲染引擎，简单、高性能，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 但由于Dart语法使得维护性/代码可读性很差，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不支持动态热更新，不同平台需要不同UI</div><div><br></div><div><font color=\"#4169e1\"><b>3.客户端开发</b></font></div><div>&nbsp; &nbsp; Electron（@github）原来叫 Atom Shell</div><div><br></div><div><font color=\"#ff0000\"><b>参考文章</b></font></div><div>&nbsp; &nbsp; Flutter、React-Native、Uni-App比较：https://ask.dcloud.net.cn/article/36083</div>"
    },
    "sxNnAdyej": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "bookId": "sxNnAdyej",
      "name": "NPM",
      "content": "<div><font color=\"#ff0000\"><b>NPM</b></font></div><div>&nbsp; &nbsp; 淘宝镜像</div><div><span style=\"white-space: pre;\">\t</span>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ npm config edit registry=https://registry.npm.taobao.org/</div><div><br></div><div>初始化包管理文件</div><div><span style=\"white-space: pre;\">\t</span>$ npm init -y // 产生 package.json</div><div><span style=\"white-space: pre;\">\t</span></div><div>搜索模块</div><div><span style=\"white-space: pre;\">\t</span>$ npm search</div><div><span style=\"white-space: pre;\">\t</span></div><div>安装</div><div><span style=\"white-space: pre;\">\t</span>$ npm install moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -g moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到全局，不会在项目node_modules目录中保存模块包。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save-dev moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入devDependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>删除包</div><div><span style=\"white-space: pre;\">\t</span>$ npm uninstall/remove name</div><div><span style=\"white-space: pre;\">\t</span></div><div>当导入一个包时：require('vue')</div><div>&nbsp; &nbsp; 1.找到对应的 node_modules</div><div>&nbsp; &nbsp; 2.找到require的包文件夹</div><div>&nbsp; &nbsp; 3.根据package.json找到需要的JS库文件</div>"
    },
    "GjFQNZWGF": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "bookId": "GjFQNZWGF",
      "name": "Git",
      "content": "<div><font color=\"#ff0000\"><b>Git</b></font></div><div>1.在代码托管区创建远程仓库：Github/码云</div><div>2.获取</div><div><span style=\"white-space: pre;\">\t</span>- 创建本地仓库</div><div><span style=\"white-space: pre;\">\t\t</span>$ git init</div><div><span style=\"white-space: pre;\">\t</span>- 通过远程仓库提供的 URL 克隆代码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - HTTPS: 需要手动输入服务器账号密码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - SSH: 需要本地生成/服务器设置SSH keys</div><div><span style=\"white-space: pre;\">\t\t</span>$ git clone [url]</div><div>&nbsp; &nbsp; - 查看这个项目对应的远程仓库</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git remote -v</div><div><span style=\"white-space: pre;\">\t</span>- 获取最新代码</div><div><span style=\"white-space: pre;\">\t\t</span>$ git pull</div><div><span style=\"white-space: pre;\">\t\t</span>- git fetch: 获取远程代码</div><div><span style=\"white-space: pre;\">\t\t</span>- git merge: 和本地库合并</div><div><span style=\"white-space: pre;\">\t</span></div><div>3.本地更改</div><div><span style=\"white-space: pre;\">\t</span>- 工作区 → 暂存区</div><div>&nbsp; &nbsp; $ git add readme.txt</div><div>&nbsp; &nbsp; - 暂存区 → 本地库</div><div>&nbsp; &nbsp; $ git commit -m \"description\"</div><div>&nbsp; &nbsp;&nbsp;</div><div>4.查看本地版本</div><div><span style=\"white-space: pre;\">\t</span>- 查看工作区及暂存区的状态</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git status</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on branch master</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no commits yet</div><div><span style=\"white-space: pre;\">\t</span>- 想知道历史提交 /空格翻页/b向上/q退出</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log -pretty=oneline 或 git reflog // 获取索引值</div><div>&nbsp; &nbsp; - 本地回退版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 通过对 HEAD 指针来决定本地版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reflog // 获取索引值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reset --hard 'key' // 设置 HEAD 指针</div><div>&nbsp; &nbsp; - 比较</div><div>&nbsp; &nbsp; &nbsp; &nbsp; git 以ROW为比较单位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git diff [(或)文件名/版本] // 查看明细</div><div>&nbsp; &nbsp; &nbsp; 生成本地 SSH keys 用于提供远程仓库访问权限</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.生成本地SSH目录</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ ssh-keygen -t rsa -C '邮箱/账号'</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.查看生成的SSH keys</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ cat id_rsa.pub</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.在托管服务器上设置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 添加 SSH keys&nbsp;</div><div>&nbsp; &nbsp; # 外包</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git fork 关联复制</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ pull request 分支发起请求</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ merge 同意请求并合并</div><div>配置签名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 提交时用于标识开发人员身份/与服务器账号密码无关</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 项目级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.email</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 系统级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.name \"Your Name\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.email \"email@example.com\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 这些信息会保存到 .git/config 中</div>"
    },
    "LuYirYo0A": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "bookId": "LuYirYo0A",
      "name": "Web部署",
      "content": "<div><font color=\"#ff0000\"><b>部署需求</b></font></div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>* 浏览器的限制</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 只支持 HTML/CSS/JavaScript 为基础的页面</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>* 模块化需求</b></font></div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>原生HTML通过直接引用CSS/图片/JS代码形式无法适应大规模开发</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>于是通过模块化把一个复杂的系统分解到多个模块以方便编码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.CommonJS规范 - modules.exports暴露接口/require同步加载</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.AMD规范 - 需要第三方库requireJS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.ES6 / import/export 目前无法直接运行在大部分 JavaScript 运行环境下</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>目前的模块化方案<font color=\"#ff0000\"><b>都需要工具</b></font>转译为 HTML/CSS/JavaScript</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>* 框架语法需要转译</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; React JSX 语法需要转译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Vue 组件系统包含大量新语法 需要转译</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>* 新语法需要转译</b></font></div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>TypeScript/SCSS 无法直接执行</div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">Webpack</b></div><div><b style=\"color: rgb(255, 0, 0);\"><br></b></div><div>&nbsp; &nbsp; 不断出现的 模块化/新语言/新框架 需求</div><div>&nbsp; &nbsp; 我们需要构建工具，在编写完代码后<font color=\"#ff0000\"><b>生成</b></font>能在线上运行的代码</div><div><br></div><div>&nbsp; &nbsp; # 目标</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 模块合并：通过构建功能一次HTTP请求完所有需要的图片/等资源(bundle.js)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</div><div><br></div><div># /dist/index.html( &lt;= bundle script) # Step 3 后不需要</div><div># /src/index.js</div><div># webpack-config.js</div><div># package.json</div><div><span style=\"white-space: pre;\">\t</span>\"start\": \"webpack-dev-server --open\"</div><div><span style=\"white-space: pre;\">\t</span>\"build\": \"webpack\" 或 \"webpack --config webpack-config.js\"</div><div><br></div><div>webpack.config.js</div><div><br></div><div>const path = require(\"path\");</div><div>const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); # Step 3</div><div>const CleanWebpackPlugin = require(\"clean-webpack-plugin\"); # Step 4</div><div><br></div><div>module.exports = {</div><div>&nbsp; &nbsp; # Step 1 基础功能&nbsp;</div><div>&nbsp; &nbsp; # 补充</div><div>&nbsp; &nbsp; mode: \"development\", // * 打包模式</div><div>&nbsp; &nbsp; devtool: \"inline-source-map\", // * 错误定位</div><div>&nbsp; &nbsp; # 打包路径</div><div>&nbsp; &nbsp; entry: \"./src/index.js\",</div><div>&nbsp; &nbsp; output: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; filename: \"bundle.js\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; path: path.resolve(__dirname, \"dist\")</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # Step 5 服务器模式：能够重新进行build加载（刷新了页面）</div><div>&nbsp; &nbsp; devServer: {</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>contentBase: { \"./dist\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; port: 8080,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hot: true, // * 局部刷新时需要开起</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # 打包内容</div><div>&nbsp; &nbsp; module: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; rules: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Step 2 加载样式/图片&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的样式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的图片</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - url-loader 依赖于 file-loader 用于图片优化/base64</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - base64 &lt;= options.limit(bit) &lt;=&nbsp; Img // 8192bit = 1024b = 1kb</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.(png|svg|jpg|gif)$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"file-loader\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"url-loader\", options: { limit: 8192 } }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><span style=\"white-space: pre;\">\t\t</span>]</div><div><span style=\"white-space: pre;\">\t</span>},</div><div>&nbsp; &nbsp; # 外部插件</div><div>&nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 3 自动生成 dist/Html 入口文件&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new HtmlWebpackPlugin({</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: \"MyLib\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; template: \"./src/packTemplate.html\" // 导出的模板</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // favicon: \"path/to/yourfile.ico\" // Link图标</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 4 打包前清空 dist 目录&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new CleanWebpackPlugin()</div><div>&nbsp; &nbsp; ]</div><div>};</div>"
    },
    "MdIBQC95b": {
      "blockId": "D2S51gJkH",
      "shelfId": "EpjNpojH6",
      "bookId": "MdIBQC95b",
      "name": "IDE",
      "content": "<div>prettier.config.js</div><div>{</div><div>&nbsp; &nbsp; // ***************** 必备 *****************</div><div>&nbsp; &nbsp; // 自动格式化</div><div>&nbsp; &nbsp; \"editor.formatOnSave\": true,</div><div><br></div><div>&nbsp; &nbsp; // Tab缩进为4个空格</div><div>&nbsp; &nbsp; \"prettier.tabWidth\": 4,</div><div><br></div><div>&nbsp; &nbsp; // 统一使用单引号</div><div>&nbsp; &nbsp; \"prettier.singleQuote\": true,</div><div><br></div><div>&nbsp; &nbsp; // ***************** 其他 *****************</div><div>&nbsp; &nbsp; // 是否自动添加分号</div><div>&nbsp; &nbsp; \"prettier.semi\": false,</div><div><br></div><div>&nbsp; &nbsp; // { / }两侧必须有空格</div><div>&nbsp; &nbsp; \"prettier.bracketSpacing\": true,</div><div><br></div><div>&nbsp; &nbsp; // 单参数箭头函数 总是带()</div><div>&nbsp; &nbsp; \"prettier.arrowParens\": \"always\",</div><div><br></div><div>&nbsp; &nbsp; // vue 模板/样式的缩进</div><div>&nbsp; &nbsp; \"prettier.vueIndentScriptAndStyle\": true</div><div>}</div>"
    },
    "MItpW-4b4": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "MItpW-4b4",
      "name": "图形学",
      "content": "<div><font color=\"#ff0000\"><b>常用图表库 API</b></font></div><font color=\"#ff0000\"><b>Canvas</b></font><div>&nbsp; &nbsp;&nbsp;</div>"
    },
    "sJiMEO7C_": {
      "blockId": "WckgEzTFu",
      "shelfId": "cAPSALi3a",
      "bookId": "sJiMEO7C_",
      "name": "312",
      "content": ""
    },
    "UuuMGnYpM": {
      "blockId": "DCgJdlX5R",
      "shelfId": "D-CDKmCae",
      "bookId": "UuuMGnYpM",
      "name": "浏览器原理",
      "content": "<div><div><b><font color=\"#ff0000\">浏览器端</font></b></div><div>&nbsp; &nbsp; 解压缩gzip资源 /&nbsp;资源缓存 /&nbsp;根据MIME类型解析内容</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>1.渲染引擎</b></font></div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font><b>#&nbsp;解析</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; #1 解码/构建 DOM 树 / CSS&nbsp;树</div><div>&nbsp; &nbsp; &nbsp; &nbsp; #2&nbsp;合并DOM/CSS树：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 计算DOM单位 /&nbsp;确定样式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 渲染阻塞：CSS 样式 &gt; Script脚本 &gt; DOM树</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b>#&nbsp;绘制</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; #4&nbsp;布局/绘制DOM结点到渲染层，合并渲染层</div><div>&nbsp; &nbsp; &nbsp; &nbsp; #5&nbsp;布局改变会导致<font color=\"#4169e1\"><b>回流</b></font>(成本高)，属性样式改变会导致<font color=\"#4169e1\"><b>重绘</b></font></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>2.JavaScript引擎</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 编译执行：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b>1.词法解析</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 得出抽象语法树（AST）并转换成机器指令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>&nbsp;2.预编译：</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;抽象JS内存环境：全局环境/函数环境/Eval</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;抽象JS内存环境内容：执行上下文</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>* 创建执行上下文（所谓的变量提升）</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 创建变量内存（变量/函数）&gt;&nbsp;建立作用域链 &gt;&nbsp;确定this指向当前执行上下文</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>3.执行&nbsp;</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*&nbsp;</b></font><b style=\"color: rgb(65, 105, 225);\">由于动态类型特性，相同代码可能由于类型不同/值更改而被重新编译：a=1/a=\"1\"）</b></div><div><b style=\"color: rgb(255, 0, 0);\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;事件循环执行顺序</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;常规代码 - 同步队列（宏任务）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Promise.then / process.nextTick - ES6/Node（微任务）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;浏览器事件 / 定时器 / HTTP异步请求进程 - 异步队列（异步任务）</div></div><div><br></div><div><font color=\"#ff0000\"><b><br></b></font></div><div><div><font color=\"#ff0000\"><b>参考文章</b></font></div><div>&nbsp; &nbsp;&nbsp;事件冒泡、事件捕获和事件委托</div><div>&nbsp; &nbsp; https://www.cnblogs.com/Chen-XiaoJun/p/6210987.html</div></div>"
    },
    "_hV6pI9rJ": {
      "blockId": "DCgJdlX5R",
      "shelfId": "D-CDKmCae",
      "bookId": "_hV6pI9rJ",
      "name": "HTTP",
      "content": "<div><b><font color=\"#ff0000\">浏览器URL解析</font></b></div><div>&nbsp; &nbsp; 1.字符串解析</div><div>&nbsp; &nbsp; 2.HTTP Strict Transport Security：强制客户端使用HTTPS请求资源</div><div>&nbsp; &nbsp; 3.其他操作：安全检查、限制访问（996.icu）</div><div>&nbsp; &nbsp; 4.检查资源缓存</div><div><br></div><div><font color=\"#ff0000\"><b>DNS查询（Domain Name System）</b></font></div><div>&nbsp; &nbsp; * DNS服务器 主要用于域名与 IP 地址的相互转换</div><div>&nbsp; &nbsp; 1.查询本地缓存：浏览器/操作系统/路由器/ISP DNS地址缓存（本地首选DNS服务器）</div><div>&nbsp; &nbsp; 2.向\"国内根域名服务器\"查询</div><div><br></div><div><font color=\"#ff0000\"><b>与查询结果的IP地址建立连接</b></font></div><div>&nbsp; &nbsp; 应用层（封装<font color=\"#ff0000\"><b>HTTP：80</b></font>报文：请求头/&nbsp;请求体）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;<font color=\"#4169e1\"><b>GET / POST</b></font>(新增修改权) /&nbsp;<font color=\"#4169e1\"><b>PUT</b></font>(修改权) /&nbsp;<font color=\"#4169e1\"><b>DELETE</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; - OPTIONS&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 获取目的资源所支持的通信方式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 跨域请求中，其是浏览器自发起的预检请求，以检测实际请求是否可以被浏览器接受。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;<font color=\"#4169e1\"><b>HTTPS：443</b></font><br></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font>基于HTTP添加<font color=\"#ff0000\"><b>&nbsp;</b></font>SSL（Secure Sockets Layer）协议用于数据加密</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务器需要付费申请CA证书（公钥）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;三次握手后，浏览器请求证书信息（私钥），协商安全等级，建立秘钥会话</div><div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font><font color=\"#4169e1\"><b>AJAX</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font>XMLHttpRequest</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 自封装了Fetch方法</div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</font><font color=\"#4169e1\"><b>同源策略</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font>同源策略是浏览器的安全限制，从一个源加载的文档或者脚本默认不能访问另一个源的资源</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 通过<font color=\"#4169e1\"><b>CORS</b></font>(Cross-Origin Resources Sharing)，浏览器允许向其他源服务器发送资源请求。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;目前基本上主流的浏览器都支持CORS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务端需要在响应头中设置 Access-Control-Allow-Origin 就可以开启 CORS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;可以通过代理服务器（如Nginx）转发请求/响应来规避跨域问题</div></div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;<font color=\"#4169e1\"><b>身份认证方式</b></font><div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务器可以设置浏览器保存&nbsp;<font color=\"#4169e1\"><b>Cookie</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务器生产保存&nbsp;<font color=\"#4169e1\"><b>Session</b></font>（内存开销，扩展迁移不易），浏览器临时使用&nbsp;<font color=\"#4169e1\"><b>Session&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务端根据秘钥生成<font color=\"#4169e1\"><b>Token</b></font>，浏览器保存token，服务端只需要通过秘钥<font color=\"#4169e1\"><b>验证</b></font><b style=\"color: rgb(65, 105, 225);\">Token</b><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b style=\"color: rgb(65, 105, 225);\">-&nbsp;三次握手：</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b>1.Client 发送连接请求报文</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.Serve 接受连接回复ACK报文，并分配计算资源</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.Client 接受报文再次发送ACK报文（TCP连接建立）</div><div><div>&nbsp; &nbsp; 网络层（封装IP首部）</div><div>&nbsp; &nbsp; 链路层（封装以太网首部）</div><div>&nbsp; &nbsp; 物理层</div><div><br></div><div><font color=\"#ff0000\"><b>服务器处理请求</b></font></div><div><br></div><div><b><font color=\"#ff0000\">浏览器端渲染页面</font></b></div><div><br></div><div><b><font color=\"#ff0000\">参考文章</font></b></div><div>&nbsp; &nbsp; 1.你所不知道的 HSTS：Strict Transport Security</div><div>&nbsp; &nbsp; &nbsp; &nbsp; https://www.barretlee.com/blog/2015/10/22/hsts-intro/<br></div></div><div>&nbsp; &nbsp; 2.Web服务器、应用程序服务器、HTTP服务器区别</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://zhuanlan.zhihu.com/p/58917525</div><div>&nbsp; &nbsp; 3.在浏览器输入 URL 回车之后发生了什么（超详细版）</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://zhuanlan.zhihu.com/p/80551769</div><div>&nbsp; &nbsp;&nbsp;一个HTTP打趴80%面试者</div><div>&nbsp; &nbsp; https://zhuanlan.zhihu.com/p/70949908</div></div></div>"
    },
    "eBhBpeVDd": {
      "blockId": "DCgJdlX5R",
      "shelfId": "D-CDKmCae",
      "bookId": "eBhBpeVDd",
      "name": "DOM API",
      "content": "<div><b style=\"color: rgb(255, 0, 0);\">HTML5 API</b><br></div><div><b style=\"color: rgb(255, 0, 0);\"><br></b></div><div><b style=\"color: rgb(255, 0, 0);\">DOM</b><br></div><div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>基本常识</b></font></div><div><span style=\"white-space: pre;\">\t</span>页面以结点Node为基本组成单位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 结点类型&nbsp;nodeType</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 文档结点(document)：9&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 元素结点(标签)：1</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Attribute属性结点：2&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -TextNode文字结点：3</div><div>&nbsp; &nbsp; &nbsp; &nbsp; document.element可以直接调用结点的基本属性</div><div>&nbsp; &nbsp; &nbsp; &nbsp; document.element.nodeName/nodeType/nodeValue:元素基本值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # innerHTML返回串中含标签/innerText不含标签</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>获取结点</b></font></div><div><span style=\"white-space: pre;\">\t</span>getElementById()</div><div><span style=\"white-space: pre;\">\t</span>getElementsByName/ClassName/TagName()：集合</div><div><span style=\"white-space: pre;\">\t</span># 必须在document下进行查找(TagName除外)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; querySelector(“css字符串”)：只会返回第一个符合结点</div><div>&nbsp; &nbsp; &nbsp; &nbsp; querySelectorAll(“css字符串”)：返回数组</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 父节点：parentNode</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 子结点：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first/last/parentElementChild</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; previous/nextElementSibling</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; children：集合</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hasChildNodes()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 以下查询有可能返回字符结点(如空白字符)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first/last/parentChild</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; previous/nextSibling</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childNodes</div><div>&nbsp; &nbsp;<font color=\"#4169e1\"><b>&nbsp;编辑结点</b></font></div><div><span style=\"white-space: pre;\">\t</span>修改：createElement(\"\") / appendChild / insertBefore(新，旧)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 删除：e.parentNode.removeChild(e)：需要找出父元素</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 样式修改：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Window.getComputedStyle(node,null) : obj : 只读</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.currentStyle.样式//仅仅IE支持</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; .style.cssText = {display:bolck;...}</div><div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; 结点事件属性</b></font></div><div><font color=\"#4169e1\" style=\"font-weight: bold;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font><font color=\"#ff0000\"><b>绑定事件</b></font></div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp;- onclick / onscroll / onmouseover / onmousewheel(wheelDelta:滚动方向 )</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp;- 可以为DOM事件设置监听函数</div><div><span style=\"white-space: pre;\">\t</span>&nbsp;<span style=\"white-space: pre;\">\t</span>1. e.onclick = function(event){}</div><div><span style=\"white-space: pre;\">\t</span>&nbsp;<span style=\"white-space: pre;\">\t</span>2. target.addEventListener(\"onclick\",fun,是否在捕获阶段触发//0)</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#ff0000\"><b>事件</b></font><b style=\"color: rgb(255, 0, 0);\">捕获/</b><b style=\"color: rgb(255, 0, 0);\">冒泡</b></div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; *&nbsp;捕获：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;需要手动开启</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 从文档的根结点 -&gt;&nbsp;目标结点：沿途触发所有存在的相同事件，建立传播途径</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;冒泡：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 从目标结点 -&gt;&nbsp;文档根结点：沿途触发所有存在的相同事件</div></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 阻止事件传播：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * event.stopPropagation()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * e.preventDefault()</div><span style=\"font-family: 宋体;\"></span><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * event.cancelBubble = true（IE）<div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#ff0000\"><b>事件委派</b></font>：</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; # 利用事件冒泡,只绑定一次监听函数</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.在共同父元素上设置响应函数</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 由于子元素和父元素有共同的响应事件，所以不用循环为子元素绑定监听函数</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.if(event.target.class==\"目标\"){监听函数}</div><div><br></div></div><div><font color=\"#ff0000\"><b>BOM</b></font></div></div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>window</b></font>：窗口/网页全局对象</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;<font color=\"#4169e1\"><b>Location：文档URL</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 定时器方法</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * setTimeout/setInterval(expression,time)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * clearTimeout/Interval(timer)</div></div></div>"
    },
    "hEQsagyJy": {
      "blockId": "uuzRN_3cX",
      "shelfId": "At1V2rMjl",
      "bookId": "hEQsagyJy",
      "name": "服务器软件分类",
      "content": "<div><font color=\"#ff0000\"><b>服务器处理请求</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>1.常见服务器装配（运维）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * OS：Windows / linux内核：Cento /&nbsp;Ubuntu / Unix内核：商用操作系统</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;服务器程序：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Web/HTTP：只需支持HTTP协议（Tomcat，Windows IIS，Apache，Nginx）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 特定应用：支持各种协议并提供服务（<span style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px;\">BEA&nbsp;</span>Weblogic，<span style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px;\">IBM&nbsp;</span>WebSphere）</div>"
    },
    "FX240__fe": {
      "blockId": "DCgJdlX5R",
      "shelfId": "D-CDKmCae",
      "bookId": "FX240__fe",
      "name": "CSS 常用",
      "content": "<div><div><b><font color=\"#ff0000\">常用样式</font></b></div><div><span style=\"white-space: pre;\">\t</span>行内块元素</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; display:inline-block</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; 水平对齐 vertical-align: top</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; 间隙 font-size: 0</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 背景透明:</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;opacity：0~1：所有&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rgba(x,y,z,0~1)：单独</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>行内换行</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 换行符无效 / 多个空格会被合并为一个 / 句子自动换行 / 单词超出边界</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; word-wrap: break-word</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 行内裁剪:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; white-space: nowrap;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text-overflow: ellipsis;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overflow: hidden;</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; 背景图像</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1. 设置背景图: background-image: url(../img/a.jpg)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2. 控制xy重复: background-repeat: repeat-x/y / no repeat</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3. 铺满屏幕：background-size:cover/num%</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4. 固定不动：background-attachment: fixed;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>Overflow</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visible<span style=\"white-space: pre;\">\t</span>默认值。内容不会被修剪，会呈现在元素框之外。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hidden<span style=\"white-space: pre;\">\t</span>内容会被修剪，并且其余内容是不可见的。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scroll<span style=\"white-space: pre;\">\t</span>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto<span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</div></div><div><br></div><div><font color=\"#ff0000\"><b>选择器</b></font></div><div><span style=\"white-space: pre;\">\t</span>1.优先级: 行内&gt; #ID选择器 &gt; .类+伪类选择器/属性选择器 &gt; 元素选择器 &gt; *通用 &gt; 继承</div><div><span style=\"white-space: pre;\">\t</span>2.语法:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 多选择器: A，B，C</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 前/后/后所有：a -+~ b</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 仅仅子：A &gt; a</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.伪类</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :link 未访问&nbsp;:visited 已访问&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :active&nbsp;点击&nbsp;:hover 鼠标放入 :focus 文本框输入时 :selection 文本鼠标选中时候</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ::before/after 文字前/后&amp;标签之间 { content:\"\" }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p:first-child p:nth-child(index):任意位置子元素&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p:first-of-type:第一个p</div><div><br></div><div><font color=\"#ff0000\"><b>动画</b></font></div><div><font color=\"#4169e1\"><b>transform</b></font></div><div>&nbsp; &nbsp; 平移：transform: translate(X,Y)</div><div>&nbsp; &nbsp; 旋转：transform-origin:x y：旋转基点</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform: rotate(30deg)</div><div>&nbsp; &nbsp; 放缩：transform: scale(X,Y);//倍数</div><div>&nbsp; &nbsp; 3D旋转：transform: rotateX/Y(120deg)</div><div><br></div><div><font color=\"#4169e1\"><b>transition</b></font></div><div>&nbsp; &nbsp; 1.为指定属性(时长)添加过渡效果：transition: width 2s,height 1s...</div><div>&nbsp; &nbsp; 2.指定属性绑定事件监听：div:hover {width...height...}</div><div>&nbsp; &nbsp; # transition: all 1s + css组合</div><div><br></div><div><font color=\"#4169e1\"><b>animation</b></font></div><div>&nbsp; &nbsp; - name 1s 时间函数 开始时间 次数();</div><div>&nbsp; &nbsp; - ease: 慢快慢 / linear:匀速</div><div>&nbsp; &nbsp; - @keyframes name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 0% {background:red;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 100% {background:green;}}</div>"
    },
    "3hn-zcj50": {
      "blockId": "DCgJdlX5R",
      "shelfId": "D-CDKmCae",
      "bookId": "3hn-zcj50",
      "name": "CSS 布局",
      "content": "<div><font color=\"#ff0000\"><b>Position定位（默认&nbsp;static&nbsp;且&nbsp;z-index&nbsp;无效</b></font><b style=\"color: rgb(255, 0, 0);\">）</b><br></div><div>&nbsp; &nbsp; 1 文档流:&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; relative：相对于原位置移动</div><div>&nbsp; &nbsp; 2 脱离文档流：</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>absolute：相对relative移动,会提升层级</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 脱离文档流而产生的高度塌陷 &amp; 相邻|垂直|内外边距重叠</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以通过添加块元素解决,清除因浮动产生的移动影响</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .clearfix:before,.clearfix:after</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {content:\"\";display:table;clear:both;}</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>float：会产生挤压</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>fixed：相对于可视界面移动,会提升层级</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div><font color=\"#ff0000\"><b>弹性盒子</b></font></div><div><span style=\"white-space: pre;\">\t</span>1.容器设置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex | inline-flex</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.容器属性</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-direction：row | row-reverse | column | column-reverse</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-wrap：nowrap | wrap | wrap-reverse</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flex-flow:&nbsp; &nbsp;row nowrap</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>横轴对齐&nbsp;</b></font>justify-content:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>flex-start<font color=\"#4169e1\"><b>(默认)</b></font>&nbsp;/ flex-end / center / space-between /&nbsp;space-around</div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>纵轴对齐&nbsp;</b></font>align-items:&nbsp;<div><span style=\"white-space: pre;\">\t\t</span>flex-start / flex-end / center / baseline(<font color=\"#4169e1\"><b>按文字对齐</b></font>) / stretch<font color=\"#4169e1\"><b>(默认：高度占满)</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 多横轴对齐&nbsp;</b></font>align-content:&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp; flex-start / flex-end / center / space-between / space-around / stretch<b style=\"color: rgb(65, 105, 225);\">(默认：高度占满)</b></div><div><span style=\"white-space: pre;\">\t\t</span># 子元素 float/clear/vertical-align 会失效</div><div><span style=\"white-space: pre;\">\t</span><font color=\"#4169e1\"><b>3.容器内容设置</b></font></div><div><span style=\"white-space: pre;\">\t\t</span>1. order: 值越小越靠前/默认 0</div><div><span style=\"white-space: pre;\">\t\t</span>2. flex: (占比) none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</div><div><span style=\"white-space: pre;\">\t\t</span>3. align-self: 单独设置 align-items 个性的对齐</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>&nbsp; &nbsp; &nbsp; &nbsp; 4. margin-?:auto 会获取剩余所有空白</div><div><br></div><div><b><font color=\"#ff0000\">移动端适配&nbsp;</font></b></div><div>&nbsp; &nbsp; 主要通过媒体查询&nbsp;<font color=\"#4169e1\"><b>@media</b></font>&nbsp;为不同设备设计不同样式<br></div><div>&nbsp; &nbsp; 通常需要用meta定义了浏览器宽度 = 设备宽度</div><div>&nbsp; &nbsp; &lt;meta name='viewport' content= 'width=device-width, initial-scale=1.0'&gt;</div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; 百分比布局</b></font></div><div><span style=\"white-space: pre;\">\t</span>- 为不同设备编写不同的CSS样式文件</div><div><span style=\"white-space: pre;\">\t</span>- 宽度默认 100%; - 但是字体可能会模糊</div><div><b><font color=\"#4169e1\">&nbsp; &nbsp; Rem布局</font></b></div><div><span style=\"white-space: pre;\">\t</span># 像素设备比 -DPR -表示1个css像素对应（覆盖）的物理像素个数</div><div><span style=\"white-space: pre;\">\t</span># HTML 默认font-size:16px / 下面动态设置HTML字体</div><div><br></div><div><div><font color=\"#ff0000\"><b>//动态设置页面根字体</b></font></div><div>(function(doc, win) {</div><div>&nbsp; //1.找到HTML页面根结点</div><div>&nbsp; let html = doc.getElementsByTagName(\"html\")[0],</div><div>&nbsp; &nbsp; //2.设置全局事件 = 屏幕发生改变事件</div><div>&nbsp; &nbsp; reEvt = \"orientationchange\" in win ? \"orientationchange\" : \"resize\", //转屏/缩放</div><div>&nbsp; &nbsp; //3.设置回调函数</div><div>&nbsp; &nbsp; reFontSize = function() {</div><div>&nbsp; &nbsp; &nbsp; var clientW = doc.documentElement.clientWidth || doc.body.clientWidth; //当前屏幕宽度</div><div>&nbsp; &nbsp; &nbsp; if (!clientW) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; // 设计稿/字体 = 1920px/16px = 屏幕宽/1rem</div><div>&nbsp; &nbsp; &nbsp; let rem = (clientW * 15) / 1920;</div><div>&nbsp; &nbsp; &nbsp; rem = rem &lt; 12 ? 12 : rem;</div><div>&nbsp; &nbsp; &nbsp; html.style.fontSize = rem + \"px\";</div><div>&nbsp; &nbsp; };</div><div>&nbsp; //5.全局添加事件监听(全局事件/回调)</div><div>&nbsp; win.addEventListener(reEvt, reFontSize);</div><div>&nbsp; //6.DOMContentLoaded-&gt;dom加载完就执行,onload要dom/css/js都加载完才执行</div><div>&nbsp; doc.addEventListener(\"DOMContentLoaded\", reFontSize);</div><div>})(document, window);</div></div><div><div><font color=\"#ff0000\"><b><br></b></font></div><div><font color=\"#ff0000\"><b>常用的居中方式</b></font></div><div>&nbsp; &nbsp; 1 水平居中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; margin:0 auto&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (行内)text-align:center</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; justify-content: center;</div><div>&nbsp; &nbsp; 2 垂直居中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (单行内)line-height</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>(多行)display:table-cell; vertical-align: middle;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; align-items: center;</div><div>&nbsp; &nbsp; 3 同时对齐</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ab+re定位：trbl:0; margin:auto;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; top/left：50%; transform(-50%,-50%)/margin-l/r:-50%;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; justify-content: center; align-items: center;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;<font color=\"#4169e1\"><b>&nbsp;(弹性盒)display: flex; margin:auto;</b></font></div></div>"
    },
    "uI_NquISx": {
      "blockId": "DCgJdlX5R",
      "shelfId": "2bQM1u5VX",
      "bookId": "uI_NquISx",
      "name": "ECMAscript",
      "content": "<div><div><b style=\"color: rgb(255, 0, 0);\">JavaScript发展</b><br></div><div>&nbsp; &nbsp; 1995.&nbsp;JavaScript（Ecma Script）诞生，使用<font color=\"#4169e1\"><b>解释器</b></font>逐行编译代码</div><div>&nbsp; &nbsp; 2008. 浏览器性能竞争：Google开发V8添加<font color=\"#4169e1\"><b>及时编译器</b></font>（JITs：Just in Time）&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * NodeJS，Electron&nbsp;运行环境成为可能</div><div>&nbsp; &nbsp; 2013.&nbsp;诞生强类型语言提升性能，二次转译为 JavaScript：TypeScript (MS)，Dart (Google)</div><div>&nbsp; &nbsp; 2013. 添加JavaScript语法拓展：Asm.js (Mozilla)</div><div>&nbsp; &nbsp; 2017. 将所有强类型语言编译为&nbsp;WebAssembly（MS，Google，Mozilla，Apple）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 业务逻辑调试困难 / 无法操作DOM</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;适合数据密集型计算</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * \"web领域的汇编语言\"</div></div><div><br></div><div><font color=\"#ff0000\"><b>ES6</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp; *&nbsp;</b></font>不同版本的引擎支持不同的高级语法</div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp; &nbsp;&nbsp;</font><font color=\"#4169e1\"><b>声</b></font><font color=\"#4169e1\"><b>明变量</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * var 在全局范围内有效</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * let 只在 let 命令所在的代码块内有效 不存在预处理:会产生报错</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * const 声明一个只读的常量，一旦声明，常量的值就不能改变。</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>解构式赋值</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;快速根据 数组及对象&nbsp;中的值进行变量声明</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;let [] / {} = Array/Object</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;<b>剩余运算符 ...args</b></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>新增内建对象：</b></font>* Symbol / Set / Map</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>箭头函数：()=&gt;{}</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; 模板字符串：`字符串+${变量}`</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; 简洁声明对象/方法：{var} / name(){}</b></font></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>模块化：</b></font>export import&nbsp;模块化&nbsp;use '<span class=\"marked\">strict</span>' 严格模式</div><div><br><div><b><font color=\"#ff0000\">参考文章</font></b></div><div>&nbsp; &nbsp; 1.几张图让你看懂 WebAssembly</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://www.jianshu.com/p/bff8aa23fe4d</div></div><div>&nbsp; &nbsp; 2.如何评论浏览器最新的 WebAssembly 字节码技术？</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;https://www.zhihu.com/question/31415286</div>"
    },
    "VZ1e0BxnY": {
      "blockId": "DCgJdlX5R",
      "shelfId": "2bQM1u5VX",
      "bookId": "VZ1e0BxnY",
      "name": "内存管理",
      "content": "<div><font color=\"#ff0000\"><b>基础数据&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>1.undefined</b></font><b style=\"color: rgb(65, 105, 225);\">：</b><b style=\"color: rgb(65, 105, 225);\">undefined</b>（变量默认值）</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>2.null</b></font><b style=\"color: rgb(65, 105, 225);\">：object</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>3.数字 123</b></font><b style=\"color: rgb(65, 105, 225);\">：number</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>4.字符串“”</b></font><b style=\"color: rgb(65, 105, 225);\">：string</b></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; 5.true/false：boolean</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp;&nbsp;</b></font>* 本质是内存代表的值保存在栈中</div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>判断类型</div><div>&nbsp; &nbsp; &nbsp; &nbsp; typeof：string</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target instanceof suppose：返回a是否是B构造函数的实例</div><div>&nbsp; &nbsp; &nbsp; &nbsp; parseInt/Float(): 先转换成字符串: 从头逐字符取出有效数字并返回数字</div><div><div><b style=\"color: rgb(65, 105, 225);\"><br></b></div><div><b><font color=\"#ff0000\">创建对象</font></b></div><div>&nbsp; &nbsp; 1.不推荐直接创建&nbsp;<b style=\"color: rgb(255, 0, 0);\">根Object&nbsp;</b>的实例 a = {} / new Object()</div><div>&nbsp; &nbsp; 2.推荐通过原型链特性创建对象实例：声明大写首字母构造函数，在原型区放置公共方法</div><div>&nbsp; &nbsp; * new -&nbsp;划分实例内存 /&nbsp;this指向实例内存 /&nbsp;执行构造函数 /&nbsp;返回新对象指针</div><div>&nbsp; &nbsp; *&nbsp;通常使用&nbsp;for in 遍历对象值键对</div><div>&nbsp; &nbsp; 3.ES6 class&nbsp;本质是语法糖</div><div>&nbsp; &nbsp; &nbsp; &nbsp; extends / static / constructor / 子类构造方法必须出现 super():&nbsp;</div><span class=\"hl-code\"></span><span class=\"hl-brackets\"></span><div>&nbsp; &nbsp; 4.<font color=\"#ff0000\"><b>Function执行&nbsp;</b></font>的五种场景</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;回调函数(&nbsp;如计时器 )被执行：this&nbsp;指向&nbsp;window，undefined（严格模式）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 对象执行内部方法：this 指向对象本身</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 路人执行他人方法：this&nbsp;指向路人</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 立即调用：function.<font color=\"#ff0000\"><b>apply</b></font>(&nbsp;target,&nbsp;<font color=\"#4169e1\"><b>[arg1, arg2]</b></font>&nbsp;)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 立即调用：function.<font color=\"#ff0000\"><b>call</b></font>(&nbsp;target,&nbsp;<font color=\"#4169e1\"><b>arg1, arg2</b></font>&nbsp;) //&nbsp;apply&nbsp;的语法糖</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 返回新方法：function.<font color=\"#ff0000\"><b>bind</b></font>( target&nbsp;)：</div></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;创建对象实例执行构造方法：this&nbsp;指向实例</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;箭头函数执行：this&nbsp;等同于父作用域的&nbsp;this</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b>*&nbsp;优先级依次上升</b></div><div><br></div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>* 对象分类</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 宿主(运行环境)对象 DOM/BOM</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 自定义对象：构造函数实例</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>内建对象</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 通常&nbsp;</b></font>* String Array Number Boolean Date Math RegExp</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>ES6新增&nbsp;</b></font>* Symbol Set Map Promise</div></div><div><br></div><div><div><font color=\"#ff0000\"><b>原型/构造链</b></font><br></div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>1.原型链&nbsp;</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font>* JS没有公共类的概念，为了实现对象的继承功能</div><div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b><font color=\"#4169e1\">实例&nbsp;</font></b>__proto__ =&nbsp;<font color=\"#4169e1\"><b>根Object实例</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b style=\"color: rgb(65, 105, 225);\">构造函数内存&nbsp;</b>prototype =&nbsp;<b style=\"color: rgb(65, 105, 225);\">根Object实例</b></div></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b style=\"color: rgb(65, 105, 225);\">根Object实例&nbsp;</b>__proto__ =&nbsp;<font color=\"#ff0000\"><b>所有对象根Object构造函数</b></font></div></div><div><div><br></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>2.构造链</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; 实例</b></font><font color=\"#4169e1\"><b>&nbsp;</b></font>constructor =<font color=\"#4169e1\"><b>&nbsp;构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b></font><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b><font color=\"#4169e1\"><b>&nbsp;</b></font>constructor =&nbsp;<b style=\"color: rgb(65, 105, 225);\">Function</b><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b><b style=\"color: rgb(65, 105, 225);\">Function</b><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b><b style=\"color: rgb(65, 105, 225);\">&nbsp;</b>constructor =&nbsp;<b style=\"color: rgb(65, 105, 225);\">Function</b><font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</b><b style=\"color: rgb(65, 105, 225);\">根Object实例&nbsp;</b>constructor =&nbsp;<font color=\"#4169e1\"><b>构造函数</b></font><b style=\"color: rgb(65, 105, 225);\">内存</b></div></div></div><div><b style=\"color: rgb(65, 105, 225);\"><br></b></div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>闭包产生</b></font></div><div><font color=\"#4169e1\" style=\"font-weight: bold;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font><b># 某个函数与某个引用环境存在引用关系，闭包指这个引用环境中的(自由)变量集合</b></div><div><span style=\"white-space: pre;\">\t</span>1.存在嵌套的外部函数 - 内部函数</div><div><span style=\"white-space: pre;\">\t</span>2.内部函数调用了外部函数的变量</div><div><span style=\"white-space: pre;\">\t</span>3.内部函数被<b>外部变量</b>引用且执行，即内部函数执行(闭包产生)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 外部变量没被销毁=内部函数没被销毁=外部函数没被销毁</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 外部变量是在内部函数预加载时被引用的 =&nbsp;<b>闭包产生</b></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>闭包用途</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.匿名函数自调用,把相关数据暴露给window.模块名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.可以根据模块名直接使用相关数据</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function foo() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>var x = 3;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function a(){return x++;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>return a;</div><div><span style=\"white-space: pre;\">\t\t</span>}</div><div><span style=\"white-space: pre;\">\t\t</span>var m = foo();</div><div><span style=\"white-space: pre;\">\t\t</span># 全局引用foo(已经执行)/导致函数a不消失/导致变量x不消失</div></div>"
    },
    "xkLTOTlBI": {
      "blockId": "DCgJdlX5R",
      "shelfId": "2bQM1u5VX",
      "bookId": "xkLTOTlBI",
      "name": "内建对象",
      "content": "<div><b style=\"color: rgb(255, 0, 0);\">Object</b><br></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>对象的key只能是 Symbol/String</div><div>&nbsp; &nbsp; 数组 Object.keys(obj)</div><div>&nbsp; &nbsp; 键数组 Object.keys(obj)</div><div>&nbsp; &nbsp; 值数组 Object.values(obj)</div><div>&nbsp; &nbsp; 值键对二维数组 Object.entries(obj)</div><div>&nbsp; &nbsp; 遍历：for in&nbsp;循环</div><div>&nbsp; &nbsp; # 判断对象为空 JSON.stringfy()==={} || Object.keys(obj).length===0</div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">String</b><br></div><div><div>&nbsp; &nbsp; 合并：concat()</div><div>&nbsp; &nbsp; 截取：slice(statr, end之前) / substring(statr, end之前)</div><div>&nbsp; &nbsp; 获取下标：indexOf()/lastIndexOf()</div><div>&nbsp; &nbsp; 查询：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; charAt(index)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; match()<span style=\"white-space: pre;\">\t</span>找到一个或多个正则表达式的匹配。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; replace()<span style=\"white-space: pre;\">\t</span>替换与正则表达式匹配的子串。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; search()<span style=\"white-space: pre;\">\t</span>检索与正则表达式相匹配的值。</div><div>&nbsp; &nbsp; 转换为数组：split(分隔符)</div><div>&nbsp; &nbsp; 新字符串：String(ins): String / Object.toString(): 返回新字符串, undefined/null 报错</div></div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Symbol（不是对象，而是基础值）</b></font></div><div><div><span style=\"white-space: pre;\">\t</span>* 标识唯一的值 - 解决：字符串不具有唯一性</div><div><span style=\"white-space: pre;\">\t</span>1.单例模式 const NAME = Symbol('name')</div><div><span style=\"white-space: pre;\">\t</span>2.键声明</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Symbol.for('tar'):全局搜索/若无则新建</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Symbol.keyFor('tar'):全局键搜索</div></div><div><br></div><b style=\"color: rgb(255, 0, 0);\">Array</b><div><div>&nbsp; &nbsp; push()<span style=\"white-space: pre;\">\t</span>向数组的末尾添加一个或更多元素，并返回新的长度&nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; pop()<span style=\"white-space: pre;\">\t</span>删除并返回数组的最后一个元素<br></div>&nbsp; &nbsp; shift()<span style=\"white-space: pre;\">\t</span>删除并返回数组的第一个元素<div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 合并：A.concat(B)</div><div>&nbsp; &nbsp; 截取 slice(start, end之前)</div><div>&nbsp; &nbsp; 替换 splice(start, 删除num个数, '新元素')</div><div>&nbsp; &nbsp; 带分隔符的字符串：join(分隔符)</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 排序：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; reverse()<span style=\"white-space: pre;\">\t</span>颠倒数组中元素的顺序</div><div>&nbsp; &nbsp; &nbsp; &nbsp; sort(compare) 默认排序顺序是根据字符串UniCode码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 需要传参 function compare(start,end){ return start-end // 升序 }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 对象排序</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function compare(e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return function(start,end){ return start[e]-end[e] }}</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>arr.forEach(function(item,index,thisArr){ console.log(item) })</div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Set</b></font></div><div><div><span style=\"white-space: pre;\">\t</span>新建 new Set( Array/String )：转换为&nbsp;key:number&nbsp;的 Object</div><div><span style=\"white-space: pre;\">\t</span>增加 set.add(value)</div><div><span style=\"white-space: pre;\">\t</span>长度 size</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>数组 let arr = [...mySet] //&nbsp;返回新数组</div><div><span style=\"white-space: pre;\">\t</span>--------------------------</div><div><span style=\"white-space: pre;\">\t</span>并集 new Set([...a, ...b])</div><div><span style=\"white-space: pre;\">\t</span>交集 new Set([...a].filter(x =&gt; b.has(x)))</div><div><span style=\"white-space: pre;\">\t</span>差集 new Set([...a].filter(x =&gt; !b.has(x)))</div></div><div><br></div><div><font color=\"#4169e1\"><b>ES6 Map</b></font></div><div><span style=\"white-space: pre;\">\t</span>克隆/合并 new Map(oldMap)<div><span style=\"white-space: pre;\">\t</span>新建 new Map(二维数组)</div><div><span style=\"white-space: pre;\">\t</span>增加 map.set(key,value)</div><div><span style=\"white-space: pre;\">\t</span>删除 map.delete(key)</div><div><span style=\"white-space: pre;\">\t</span>长度 size</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span># 按插入顺序输出</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>for of&nbsp;循环 / forEach( (value,key)=&gt;{}, map )</div><div><b style=\"color: rgb(65, 105, 225);\"><br></b></div><div><b style=\"color: rgb(65, 105, 225);\">ES6 Promise</b></div></div></div>"
    },
    "NH3-DkygI": {
      "blockId": "DCgJdlX5R",
      "shelfId": "v1x8EzKB6",
      "bookId": "NH3-DkygI",
      "name": "主流应用分布",
      "content": "<div><font color=\"#4169e1\"><b>1.传统网站开发</b></font></div><div><br></div><div>&nbsp; &nbsp; 通常是一套代码进行样式适配，再部署到 PC / Mobile 不同平台，最后通过浏览器软件进行访问&nbsp; &nbsp;</div><div><br></div><div><font color=\"#4169e1\"><b>2.移动端开发</b></font></div><div><br></div><div>&nbsp; &nbsp; Native APP (原生APP)</div><div>&nbsp; &nbsp; - Android：Java / IOS：Object-C/Swift 等</div><div><br></div><div>&nbsp; &nbsp; Hybrid APP (混合开发)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 是一种用Native技术来搭建本地Web环境，内容主要通过Web技术来提供的移动应用</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 主要开发技术</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Uni-App：自研Wxs技术降低视图层与语言引擎通信耗损</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - React-Native：JavaScript引擎，不同平台需要不同UI</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Flutter：Dart引擎，是纯粹的渲染引擎，简单、高性能，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 但由于Dart语法使得维护性/代码可读性很差，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不支持动态热更新，不同平台需要不同UI</div><div><br></div><div><font color=\"#4169e1\"><b>3.客户端开发</b></font></div><div>&nbsp; &nbsp; Electron（@github）原来叫 Atom Shell</div><div><br></div><div><font color=\"#ff0000\"><b>参考文章</b></font></div><div>&nbsp; &nbsp; Flutter、React-Native、Uni-App比较：https://ask.dcloud.net.cn/article/36083</div>"
    },
    "iRX1FoSXg": {
      "blockId": "DCgJdlX5R",
      "shelfId": "v1x8EzKB6",
      "bookId": "iRX1FoSXg",
      "name": "UI-Vue",
      "content": "<div><font color=\"#ff0000\"><b>开发Tips</b></font></div><div>&nbsp; &nbsp;<font color=\"#4169e1\"><b>&nbsp;*&nbsp;动态加载图片&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 起因：在webpack中会将图片图片来当做模块来用，url-loader将无法解析图片地址</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 解决方法：1.将图片作为模块加载 2.将图片放入static目录+绝对路径</div><div>&nbsp; &nbsp;<font color=\"#4169e1\"><b>&nbsp;*&nbsp;强制渲染DOM&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;Vue.set(target, key, newValue)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Object.assign({}, old, new)</div><div><br></div><div><font color=\"#ff0000\"><b>生命周期</b></font></div><div>&nbsp; &nbsp; beforeCreate =&gt; 初始化事件/生命周期</div><div><span style=\"white-space: pre;\">\t\t</span>created&nbsp;</div><div><span style=\"white-space: pre;\">\t\t\t</span>=&gt; 根据el:#app调用 vm.$mount(\"#app\")</div><div><span style=\"white-space: pre;\">\t\t\t</span>=&gt; 根据template编译到 vm.render 中</div><div><span style=\"white-space: pre;\">\t\t</span>beforeMount =&gt; vm.$el = DOM</div><div><span style=\"white-space: pre;\">\t\t</span>mounted =&gt; beforeUpdate &lt;=&gt; update =&gt; vm.$destroy()</div><div><span style=\"white-space: pre;\">\t\t</span>destroyed</div><div><br></div><div><font color=\"#ff0000\"><b>Vue实例</b></font></div><div>组件是可以复用的 Vue 实例</div><div><span style=\"white-space: pre;\">\t</span>1. 组件控制模板字符串\"&lt;templete&gt;\"/单vue文件</div><div><span style=\"white-space: pre;\">\t</span>2. 注册</div><div><span style=\"white-space: pre;\">\t\t</span>全局: Vue.component('component', {..详见基础..})</div><div><span style=\"white-space: pre;\">\t\t</span>局部: components: { 'component': {..详见基础..} } （常用）</div><div><span style=\"white-space: pre;\">\t</span>3. 动态组件</div><div><span style=\"white-space: pre;\">\t\t</span>3.1 &lt;component :is=\"currentTabComponent\"&gt;&lt;/component&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>3.2 ('component', {</div><div><span style=\"white-space: pre;\">\t\t\t</span>render: (createElement) =&gt; { return createElement(...) }</div><div><span style=\"white-space: pre;\">\t\t</span>})</div><div><span style=\"white-space: pre;\">\t</span># createElement(</div><div><span style=\"white-space: pre;\">\t\t</span>'HTML/Component-Name', // 必填</div><div><span style=\"white-space: pre;\">\t\t</span>{ data / computed / methods&nbsp; }, // 可选</div><div><span style=\"white-space: pre;\">\t\t</span>['String', 'createElement(...)'] // 可选</div><div><span style=\"white-space: pre;\">\t</span>)</div><div><span style=\"white-space: pre;\">\t</span></div><div># 通常使用HTML语言来创建模板语法</div><div># 函数式模板-render函数通过传入函数,返回一个createElement函数的调用结果,创建虚拟DOM</div><div>var vm = new Vue({</div><div>&nbsp; &nbsp; el:\"#app\",</div><div>&nbsp; &nbsp; render:function(cE){</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>return cE('tag',tag属性集合{ class:..,style:..,});</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; # 返回一个虚拟DOM树替换VM</div><div>&nbsp; &nbsp; # 简写:render: c =&gt; c(...);</div><div>})</div><div><br></div><div>***********************************************************************************</div><div># 使用父组件</div><div>&nbsp; &nbsp; 1.数据</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>父: &lt;name-x :中间变量=父数据&gt;</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>子: props:[\"中间变量\"]</div><div>&nbsp; &nbsp; 2.方法</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 父: &lt;name-x v-on:\"中间变量\"=父方法&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 子: &lt;template v-on:click=\"子方法\"&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; this.$emit(\"中间变量\"，参数1...)</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div># 使用子组件数据</div><div><span style=\"white-space: pre;\">\t</span>数据/方法</div><div><span style=\"white-space: pre;\">\t\t</span>父: &lt;name-x ref='name'&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$refs.name.fun/data</div><div><span style=\"white-space: pre;\">\t\t</span></div><div># 兄弟组件：</div><div><span style=\"white-space: pre;\">\t</span>创建一个新Vue的实例，让各个兄弟共用同一个事件机制</div><div><span style=\"white-space: pre;\">\t</span>创建空模板：export default new Vue()</div><div><span style=\"white-space: pre;\">\t</span>注册: mounted() =&gt; emptyVue.$on(\"中间变量\",(参数)=&gt;{回调})}//注册事件</div><div><span style=\"white-space: pre;\">\t</span>触发: emptyVue.$emit(\"中间变量\"，参数...)</div><div><br></div><div><br></div><div># 路由能根据路径的不同而在VM机中展示不同的组件</div><div>1.导入&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>npm i vue-router</div><div>2.创建路由对象</div><div><span style=\"white-space: pre;\">\t</span>Vue.use(VueRouter);</div><div><span style=\"white-space: pre;\">\t</span>var rou = new VueRouter({</div><div><span style=\"white-space: pre;\">\t\t</span>routes:[</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则1<span style=\"white-space: pre;\">\t</span>{</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>path:'/'',redirect:\"/index\",component:组件,</div><div><span style=\"white-space: pre;\">\t\t\t\t</span>children:[{path:'a1', component:目标组件}, ...]},</div><div><span style=\"white-space: pre;\">\t\t\t\t</span># children会被渲染到/index的router-view中</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则2<span style=\"white-space: pre;\">\t</span>{path:'/', component:?},</div><div><span style=\"white-space: pre;\">\t\t\t</span>规则3<span style=\"white-space: pre;\">\t</span>{path:'/', component:?}]})</div><div>3.APP注册: router:路由对象,</div><div>4.使用路由</div><div><span style=\"white-space: pre;\">\t</span>JS访问:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>&lt;router-link :to=\"{ name:'user', params:{userId: 123} }\"&gt;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.push({ name:'user', params:{userId: 123} });</div><div><span style=\"white-space: pre;\">\t</span>获得参数:&nbsp;</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.query.id/name</div><div><span style=\"white-space: pre;\">\t\t</span>this.$router.params.id/name</div><div><span style=\"white-space: pre;\">\t\t</span>this.$route.params.name //当前路由</div><div>***********************************************************************************</div><div><br></div><div>npm install vuex --save</div><div>1.创建仓库入口 /store/index.js</div><div><span style=\"white-space: pre;\">\t</span>Vue.use(Vuex)</div><div><span style=\"white-space: pre;\">\t</span>export default Vuex.Store({ modules: {} })</div><div>2.</div><div><br></div><div>安装 Node.exe</div><div>全局安装</div><div><span style=\"white-space: pre;\">\t</span>vue i @vue/cli -g</div><div><span style=\"white-space: pre;\">\t</span>依赖 @vue/cli-service 进行配置/拓展</div><div>传统生成项目</div><div><span style=\"white-space: pre;\">\t</span>1.vue create name</div><div><span style=\"white-space: pre;\">\t</span>2.public/index.html 文件是一个会被 html-webpack-plugin 处理的模板</div><div><span style=\"white-space: pre;\">\t</span></div><div><span style=\"white-space: pre;\">\t</span># 调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象：</div><div><span style=\"white-space: pre;\">\t</span>// vue.config.js</div><div>&nbsp; &nbsp; module.exports = {</div><div>&nbsp; &nbsp; &nbsp; configureWebpack: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new MyAwesomeWebpackPlugin()]}}</div><div>项目本地测试</div><div><span style=\"white-space: pre;\">\t</span>npm run serve (vue-cli-service serve)</div><div><span style=\"white-space: pre;\">\t</span>命令会启动一个开发服务器 (基于 webpack-dev-server)&nbsp;</div><div><span style=\"white-space: pre;\">\t</span>可以使用 vue.config.js 里的 devServer 字段配置开发服务器。</div><div>项目打包</div><div><span style=\"white-space: pre;\">\t</span>npm run serve (vue-cli-service build)</div><div><span style=\"white-space: pre;\">\t</span>会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，</div>"
    },
    "LW-v37H72": {
      "blockId": "DCgJdlX5R",
      "shelfId": "v1x8EzKB6",
      "bookId": "LW-v37H72",
      "name": "UI-React",
      "content": ""
    },
    "XhHY3u6IR": {
      "blockId": "U2EWIATls",
      "shelfId": "55QFkq23J",
      "bookId": "XhHY3u6IR",
      "name": "组成原理",
      "content": "1.计算机发展史<div>&nbsp; &nbsp; * 人力计算：computer 过去指专门从事计算大数字的从业人员（让优秀的人浪费时间算数简直侮辱尊严）</div><div>&nbsp; &nbsp; * 查询计算：变量表 计算统计并记录出常用的数字</div><div>&nbsp; &nbsp; * 机器计算： 通用计算机概念：希望机器能可编程地，自动完成一系列计算操作</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 巨大/计算速度缓慢 “继电器01”的计算机诞生</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 更快的“三级真空管01”计算机诞生</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 现代化的迷你的“晶体管 -&nbsp;<font color=\"#4169e1\"><b>半导体</b></font>材料”计算机诞生</div><div><br></div><div>2.计算机数学：<font color=\"#4169e1\"><b>布尔代数</b></font></div><div>&nbsp; &nbsp; * 通过电路逻辑，来实现计算机的二进制计数，8位（bit）电路能代表2^8个值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 由于常用则另称<font color=\"#4169e1\"><b>（1byte）字节</b></font>，1024byte 表示 1kb</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 浮点数：1*正负 + 8*值存位 + 23*有效数位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 文字：1967 ASCII，1992 Unicode&nbsp;</div><div><br></div><div>3.机器计算：使用逻辑门电路来将“输入逻辑”转换为“输出逻辑”</div><div>&nbsp; &nbsp; *&nbsp;<font color=\"#ff0000\"><b>ALU</b></font>：计算机的核心计算组件</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 计算单元：输出值逻辑 / 逻辑单元：输出判断逻辑</div><div>&nbsp; &nbsp; * 存储计算结果</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;<font color=\"#ff0000\"><b>寄存器</b></font>：临时保存计算结果</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 多个寄存器实现的较大数字的存储，即&nbsp;<font color=\"#ff0000\"><b>RAM（随时访问任何位置的数值）</b></font></div><div>&nbsp; &nbsp; *&nbsp;<font color=\"#ff0000\"><b>CPU</b></font>&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Center Processor Unit</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 通过不同寄存器&nbsp;<font color=\"#4169e1\"><b>读取 - 解码 - 执行&nbsp;</b></font>已设置好的指令（实现与ALU的计算 或者 与RAM的读写）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 通过“时钟”精准触发电信号/Hz，不断执行上述<font color=\"#4169e1\"><b>指令循环</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; * 更快的计算</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 现代CPU有专门电路来处理图形、视频等</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 更快地操作数据：通过&nbsp;<font color=\"#ff0000\"><b>Cache</b></font>&nbsp;缓存存储常用指令、值等</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 并行处理&nbsp;<font color=\"#4169e1\"><b>指令循环&nbsp;</b></font>指令循环，最终使得在固定时间内执行最多的指令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 多核处理器：一个CPU中有多个独立处理单元共享数据，合作运算</div><div><br></div><div>4.编程</div><div>&nbsp; &nbsp; * 可编程的计算：存储程序式计算机（冯·诺依曼结构）</div><div>&nbsp; &nbsp; * 输入输出设备</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 早期的卡片IO - 插线式IO - 语言式IO</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - CPU汇编语言 +&nbsp;<font color=\"#ff0000\"><b>汇编器</b></font>&nbsp;= 机器码（二进制）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;<font color=\"#ff0000\"><b>编译器+高级语言</b></font>&nbsp;= 机器码 或者 汇编语言</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 1960 BASIC - 1970 C - 1980 C++ - 1990 Python/Ruby/Java - 2000 C#/Go</div><div>&nbsp; &nbsp; &nbsp;* 高级语言特性</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 变量 / 流程 / 函数 / 对象（都是为了更少的代码，及更高效的软件工程）</div><div><br></div><div>5.操作系统</div><div>&nbsp; &nbsp; - 商用 unix</div><div>&nbsp; &nbsp; - 个人 windows</div>"
    },
    "qfE-3dk7P": {
      "blockId": "U2EWIATls",
      "shelfId": "55QFkq23J",
      "bookId": "qfE-3dk7P",
      "name": "数据结构",
      "content": ""
    },
    "NLG8RA-_E": {
      "blockId": "U2EWIATls",
      "shelfId": "55QFkq23J",
      "bookId": "NLG8RA-_E",
      "name": "算法应用",
      "content": ""
    },
    "GfOk1Sh_r": {
      "blockId": "U2EWIATls",
      "shelfId": "55QFkq23J",
      "bookId": "GfOk1Sh_r",
      "name": "网络",
      "content": ""
    },
    "x2PZE07sX": {
      "blockId": "U2EWIATls",
      "shelfId": "55QFkq23J",
      "bookId": "x2PZE07sX",
      "name": "操作系统",
      "content": ""
    },
    "q377PeE7V": {
      "blockId": "U2EWIATls",
      "shelfId": "Voh8g7nW6",
      "bookId": "q377PeE7V",
      "name": "介绍",
      "content": "1.计算机发展史<div>&nbsp; &nbsp; * 人力计算：computer 过去指专门从事计算大数字的从业人员（让优秀的人浪费时间算数简直侮辱尊严）</div><div>&nbsp; &nbsp; * 查询计算：变量表 计算统计并记录出常用的数字</div><div>&nbsp; &nbsp; * 机器计算： 通用计算机概念：希望机器能可编程地，自动完成一系列计算操作</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 巨大/计算速度缓慢 “继电器01”的计算机诞生</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 更快的“三级真空管01”计算机诞生</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 现代化的迷你的“晶体管 -&nbsp;<font color=\"#4169e1\"><b>半导体</b></font>材料”计算机诞生</div><div><br></div><div>2.计算机数学：<font color=\"#4169e1\"><b>布尔代数</b></font></div><div>&nbsp; &nbsp; * 通过电路逻辑，来实现计算机的二进制计数，8位（bit）电路能代表2^8个值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 由于常用则另称<font color=\"#4169e1\"><b>（1byte）字节</b></font>，1024byte 表示 1kb</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 浮点数：1*正负 + 8*值存位 + 23*有效数位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 文字：1967 ASCII，1992 Unicode&nbsp;</div><div><br></div><div>3.机器计算：使用逻辑门电路来将“输入逻辑”转换为“输出逻辑”</div><div>&nbsp; &nbsp; *&nbsp;<font color=\"#ff0000\"><b>ALU</b></font>：计算机的核心计算组件</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 计算单元：输出值逻辑 / 逻辑单元：输出判断逻辑</div><div>&nbsp; &nbsp; * 存储计算结果</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;<font color=\"#ff0000\"><b>寄存器</b></font>：临时保存计算结果</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 多个寄存器实现的较大数字的存储，即&nbsp;<font color=\"#ff0000\"><b>RAM（随时访问任何位置的数值）</b></font></div><div>&nbsp; &nbsp; *&nbsp;<font color=\"#ff0000\"><b>CPU</b></font>&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Center Processor Unit</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 通过不同寄存器&nbsp;<font color=\"#4169e1\"><b>读取 - 解码 - 执行&nbsp;</b></font>已设置好的指令（实现与ALU的计算 或者 与RAM的读写）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 通过“时钟”精准触发电信号/Hz，不断执行上述<font color=\"#4169e1\"><b>指令循环</b></font></div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; * 更快的计算</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 现代CPU有专门电路来处理图形、视频等</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 更快地操作数据：通过&nbsp;<font color=\"#ff0000\"><b>Cache</b></font>&nbsp;缓存存储常用指令、值等</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 并行处理&nbsp;<font color=\"#4169e1\"><b>指令循环&nbsp;</b></font>指令循环，最终使得在固定时间内执行最多的指令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 多核处理器：一个CPU中有多个独立处理单元共享数据，合作运算</div><div><br></div><div>4.编程</div><div>&nbsp; &nbsp; * 可编程的计算：存储程序式计算机（冯·诺依曼结构）</div><div>&nbsp; &nbsp; * 输入输出设备</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 早期的卡片IO - 插线式IO - 语言式IO</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - CPU汇编语言 +&nbsp;<font color=\"#ff0000\"><b>汇编器</b></font>&nbsp;= 机器码（二进制）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;<font color=\"#ff0000\"><b>编译器+高级语言</b></font>&nbsp;= 机器码 或者 汇编语言</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 1960 BASIC - 1970 C - 1980 C++ - 1990 Python/Ruby/Java - 2000 C#/Go</div><div>&nbsp; &nbsp; &nbsp;* 高级语言特性</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 变量 / 流程 / 函数 / 对象（都是为了更少的代码，及更高效的软件工程）</div><div><br></div><div>5.操作系统</div><div>&nbsp; &nbsp; - 商用 unix</div><div>&nbsp; &nbsp; - 个人 windows</div>"
    },
    "06thTC3zW": {
      "blockId": "U2EWIATls",
      "shelfId": "SdTAGDIMM",
      "bookId": "06thTC3zW",
      "name": "介绍",
      "content": "<div><font color=\"#ff0000\"><b>* 原则</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font><font color=\"#4169e1\"><b>单一职责原则</b></font>&nbsp;* 一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font><font color=\"#4169e1\"><b>开闭原则</b></font>&nbsp;*&nbsp;在程序需要进行拓展的时候，不能去修改原有的代码</div><div>&nbsp; &nbsp; 里氏代换原则 *&nbsp;任何基类可以出现的地方，子类一定可以出现</div><div>&nbsp; &nbsp; 依赖倒转原则 *&nbsp;针对接口编程，依赖于抽象而不依赖于具体（啥玩意？）</div><div>&nbsp; &nbsp; 接口隔离原则 *&nbsp;使用多个隔离的接口，比使用单个接口要好</div><div>&nbsp; &nbsp; 最少知道原则 *&nbsp;一个实体应当尽量少地与其他实体之间发生相互作用</div><div>&nbsp; &nbsp; 合成复用原则 *&nbsp;尽量使用合成/聚合的方式，而不是使用继承</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>面向对象的三大原则</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;封装：隐藏对象的属性，仅对外公开行为</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;继承：抽取共有特征和方法形成高一层的super类</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;多态：同一个处理手段可以用来处理多种不同的情况</div><div><br></div><font color=\"#ff0000\"><b>1.创建型</b></font><div><div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>单例模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 保证一个类仅有一个 Singleton&nbsp;实例，并提供一个访问它的全局访问点。</div></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>原型模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;通过拷贝原型对象创建新的相同 Prototype 对象</div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>工厂模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * Factory（日志生成器）=&gt; Production（错误日志）</div><div>&nbsp; &nbsp;&nbsp;<b style=\"color: rgb(65, 105, 225);\">抽象工厂模式</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * AbstructFactory（皮肤器）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ** AFactory（皮肤色生成器）=&gt; AProduction（皮肤色）</div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ** BFactory（皮肤材质生成器）=&gt; BProduction（皮肤材质）</div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>建造者模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * Builder（点餐机）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ** AFactory（汉堡生成器）=&gt; AProduction（汉堡）</div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ** BFactory（可乐生成器）=&gt; BProduction（可乐）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt; Production（套餐：可乐+汉堡）</div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">2.结构型</b></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>适配器模式&nbsp;</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 视频播放器</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ** Adapter（内嵌振动器）=&gt;&nbsp;实现了振动功能的视频播放器</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#ff0000\"><b>桥接模式 ？</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;对于两个独立变化的维度&nbsp;似乎和抽象工厂模式高度相似</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>过滤器模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * Filter（考试筛选）=&gt; Target（及格的孩子）</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>组合模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;Node（结点）=&gt; Tree（树）</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>装饰器模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * A（牛奶）=&gt; * DecoratorA（牛奶带糖）</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>外观模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;其实就是“封装”，不暴露实现细节只提供实现方法</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>享元模式</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 第一次查询创建对象，后续查询返回相同对象（已缓存）</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>代理模式</b></font></div>&nbsp; &nbsp; &nbsp; &nbsp; * =&gt; Target（火车票）<div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;Proxy（代售点） =&gt; Target（火车票）</div><div><b style=\"color: rgb(255, 0, 0);\">3.行为型</b></div><div>&nbsp; &nbsp; 责任链模式</div><div>&nbsp; &nbsp; 命令模式</div><div>&nbsp; &nbsp; 解释器模式</div><div>&nbsp; &nbsp; 迭代器模式</div><div>&nbsp; &nbsp; 中介模式</div><div>&nbsp; &nbsp; 备忘录模式</div><div>&nbsp; &nbsp; 观察者模式</div><div>&nbsp; &nbsp; 状态模式</div><div>&nbsp; &nbsp; 空对象模式</div><div>&nbsp; &nbsp; 策略模式</div><div>&nbsp; &nbsp; 模板模式</div><div>&nbsp; &nbsp; 访问者模式</div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">4.J2ee型</b></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>MVC模式</b></font></div><div>&nbsp; &nbsp; 业务代表模式</div><div>&nbsp; &nbsp; 组合实体模式</div><div>&nbsp; &nbsp; 数据访问对象模式</div><div>&nbsp; &nbsp; 前端控制器模式</div><div>&nbsp; &nbsp; 拦截过滤器模式</div><div>&nbsp; &nbsp; 服务定位模式</div><div>&nbsp; &nbsp; 传输对象模式</div><div><br></div><div><br></div>"
    },
    "gCahXUHz-": {
      "blockId": "DCgJdlX5R",
      "shelfId": "8ehQoNmob",
      "bookId": "gCahXUHz-",
      "name": "NPM",
      "content": "<div><font color=\"#ff0000\"><b>NPM</b></font></div><div>&nbsp; &nbsp; 淘宝镜像</div><div><span style=\"white-space: pre;\">\t</span>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ npm config edit registry=https://registry.npm.taobao.org/</div><div><br></div><div>初始化包管理文件</div><div><span style=\"white-space: pre;\">\t</span>$ npm init -y // 产生 package.json</div><div><span style=\"white-space: pre;\">\t</span></div><div>搜索模块</div><div><span style=\"white-space: pre;\">\t</span>$ npm search</div><div><span style=\"white-space: pre;\">\t</span></div><div>安装</div><div><span style=\"white-space: pre;\">\t</span>$ npm install moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -g moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到全局，不会在项目node_modules目录中保存模块包。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save-dev moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入devDependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>删除包</div><div><span style=\"white-space: pre;\">\t</span>$ npm uninstall/remove name</div><div><span style=\"white-space: pre;\">\t</span></div><div>当导入一个包时：require('vue')</div><div>&nbsp; &nbsp; 1.找到对应的 node_modules</div><div>&nbsp; &nbsp; 2.找到require的包文件夹</div><div>&nbsp; &nbsp; 3.根据package.json找到需要的JS库文件</div>"
    },
    "ofIlda18c": {
      "blockId": "DCgJdlX5R",
      "shelfId": "8ehQoNmob",
      "bookId": "ofIlda18c",
      "name": "Git",
      "content": "<div><font color=\"#ff0000\"><b>Git</b></font></div><div>1.在代码托管区创建远程仓库：Github/码云</div><div>2.获取</div><div><span style=\"white-space: pre;\">\t</span>- 创建本地仓库</div><div><span style=\"white-space: pre;\">\t\t</span>$ git init</div><div><span style=\"white-space: pre;\">\t</span>- 通过远程仓库提供的 URL 克隆代码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - HTTPS: 需要手动输入服务器账号密码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - SSH: 需要本地生成/服务器设置SSH keys</div><div><span style=\"white-space: pre;\">\t\t</span>$ git clone [url]</div><div>&nbsp; &nbsp; - 查看这个项目对应的远程仓库</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git remote -v</div><div><span style=\"white-space: pre;\">\t</span>- 获取最新代码</div><div><span style=\"white-space: pre;\">\t\t</span>$ git pull</div><div><span style=\"white-space: pre;\">\t\t</span>- git fetch: 获取远程代码</div><div><span style=\"white-space: pre;\">\t\t</span>- git merge: 和本地库合并</div><div><span style=\"white-space: pre;\">\t</span></div><div>3.本地更改</div><div><span style=\"white-space: pre;\">\t</span>- 工作区 → 暂存区</div><div>&nbsp; &nbsp; $ git add readme.txt</div><div>&nbsp; &nbsp; - 暂存区 → 本地库</div><div>&nbsp; &nbsp; $ git commit -m \"description\"</div><div>&nbsp; &nbsp;&nbsp;</div><div>4.查看本地版本</div><div><span style=\"white-space: pre;\">\t</span>- 查看工作区及暂存区的状态</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git status</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on branch master</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no commits yet</div><div><span style=\"white-space: pre;\">\t</span>- 想知道历史提交 /空格翻页/b向上/q退出</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log -pretty=oneline 或 git reflog // 获取索引值</div><div>&nbsp; &nbsp; - 本地回退版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 通过对 HEAD 指针来决定本地版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reflog // 获取索引值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reset --hard 'key' // 设置 HEAD 指针</div><div>&nbsp; &nbsp; - 比较</div><div>&nbsp; &nbsp; &nbsp; &nbsp; git 以ROW为比较单位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git diff [(或)文件名/版本] // 查看明细</div><div>&nbsp; &nbsp; &nbsp; 生成本地 SSH keys 用于提供远程仓库访问权限</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.生成本地SSH目录</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ ssh-keygen -t rsa -C '邮箱/账号'</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.查看生成的SSH keys</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ cat id_rsa.pub</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.在托管服务器上设置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 添加 SSH keys&nbsp;</div><div>&nbsp; &nbsp; # 外包</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git fork 关联复制</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ pull request 分支发起请求</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ merge 同意请求并合并</div><div>配置签名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 提交时用于标识开发人员身份/与服务器账号密码无关</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 项目级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.email</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 系统级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.name \"Your Name\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.email \"email@example.com\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 这些信息会保存到 .git/config 中</div>"
    },
    "dggBzPZ8a": {
      "blockId": "DCgJdlX5R",
      "shelfId": "8ehQoNmob",
      "bookId": "dggBzPZ8a",
      "name": "部署",
      "content": "<div><font color=\"#ff0000\"><b>部署需求</b></font></div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>* 浏览器的限制</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 只支持 HTML/CSS/JavaScript 为基础的页面</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>* 模块化需求</b></font></div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>原生HTML通过直接引用CSS/图片/JS代码形式无法适应大规模开发</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>于是通过模块化把一个复杂的系统分解到多个模块以方便编码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.CommonJS规范 - modules.exports暴露接口/require同步加载</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.AMD规范 - 需要第三方库requireJS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.ES6 / import/export 目前无法直接运行在大部分 JavaScript 运行环境下</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>目前的模块化方案<font color=\"#ff0000\"><b>都需要工具</b></font>转译为 HTML/CSS/JavaScript</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>* 框架语法需要转译</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; React JSX 语法需要转译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Vue 组件系统包含大量新语法 需要转译</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>* 新语法需要转译</b></font></div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>TypeScript/SCSS 无法直接执行</div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">Webpack</b></div><div><b style=\"color: rgb(255, 0, 0);\"><br></b></div><div>&nbsp; &nbsp; 不断出现的 模块化/新语言/新框架 需求</div><div>&nbsp; &nbsp; 我们需要构建工具，在编写完代码后<font color=\"#ff0000\"><b>生成</b></font>能在线上运行的代码</div><div><br></div><div>&nbsp; &nbsp; # 目标</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 模块合并：通过构建功能一次HTTP请求完所有需要的图片/等资源(bundle.js)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</div><div><br></div><div># /dist/index.html( &lt;= bundle script) # Step 3 后不需要</div><div># /src/index.js</div><div># webpack-config.js</div><div># package.json</div><div><span style=\"white-space: pre;\">\t</span>\"start\": \"webpack-dev-server --open\"</div><div><span style=\"white-space: pre;\">\t</span>\"build\": \"webpack\" 或 \"webpack --config webpack-config.js\"</div><div><br></div><div>webpack.config.js</div><div><br></div><div>const path = require(\"path\");</div><div>const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); # Step 3</div><div>const CleanWebpackPlugin = require(\"clean-webpack-plugin\"); # Step 4</div><div><br></div><div>module.exports = {</div><div>&nbsp; &nbsp; # Step 1 基础功能&nbsp;</div><div>&nbsp; &nbsp; # 补充</div><div>&nbsp; &nbsp; mode: \"development\", // * 打包模式</div><div>&nbsp; &nbsp; devtool: \"inline-source-map\", // * 错误定位</div><div>&nbsp; &nbsp; # 打包路径</div><div>&nbsp; &nbsp; entry: \"./src/index.js\",</div><div>&nbsp; &nbsp; output: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; filename: \"bundle.js\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; path: path.resolve(__dirname, \"dist\")</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # Step 5 服务器模式：能够重新进行build加载（刷新了页面）</div><div>&nbsp; &nbsp; devServer: {</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>contentBase: { \"./dist\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; port: 8080,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hot: true, // * 局部刷新时需要开起</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # 打包内容</div><div>&nbsp; &nbsp; module: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; rules: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Step 2 加载样式/图片&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的样式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的图片</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - url-loader 依赖于 file-loader 用于图片优化/base64</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - base64 &lt;= options.limit(bit) &lt;=&nbsp; Img // 8192bit = 1024b = 1kb</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.(png|svg|jpg|gif)$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"file-loader\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"url-loader\", options: { limit: 8192 } }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><span style=\"white-space: pre;\">\t\t</span>]</div><div><span style=\"white-space: pre;\">\t</span>},</div><div>&nbsp; &nbsp; # 外部插件</div><div>&nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 3 自动生成 dist/Html 入口文件&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new HtmlWebpackPlugin({</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: \"MyLib\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; template: \"./src/packTemplate.html\" // 导出的模板</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // favicon: \"path/to/yourfile.ico\" // Link图标</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 4 打包前清空 dist 目录&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new CleanWebpackPlugin()</div><div>&nbsp; &nbsp; ]</div><div>};</div>"
    },
    "eBZFWVY0J": {
      "blockId": "DCgJdlX5R",
      "shelfId": "8ehQoNmob",
      "bookId": "eBZFWVY0J",
      "name": "IDE",
      "content": "<div>prettier.config.js</div><div>{</div><div>&nbsp; &nbsp; // ***************** 必备 *****************</div><div>&nbsp; &nbsp; // 自动格式化</div><div>&nbsp; &nbsp; \"editor.formatOnSave\": true,</div><div><br></div><div>&nbsp; &nbsp; // Tab缩进为4个空格</div><div>&nbsp; &nbsp; \"prettier.tabWidth\": 4,</div><div><br></div><div>&nbsp; &nbsp; // 统一使用单引号</div><div>&nbsp; &nbsp; \"prettier.singleQuote\": true,</div><div><br></div><div>&nbsp; &nbsp; // ***************** 其他 *****************</div><div>&nbsp; &nbsp; // 是否自动添加分号</div><div>&nbsp; &nbsp; \"prettier.semi\": false,</div><div><br></div><div>&nbsp; &nbsp; // { / }两侧必须有空格</div><div>&nbsp; &nbsp; \"prettier.bracketSpacing\": true,</div><div><br></div><div>&nbsp; &nbsp; // 单参数箭头函数 总是带()</div><div>&nbsp; &nbsp; \"prettier.arrowParens\": \"always\",</div><div><br></div><div>&nbsp; &nbsp; // vue 模板/样式的缩进</div><div>&nbsp; &nbsp; \"prettier.vueIndentScriptAndStyle\": true</div><div>}</div>"
    },
    "aSA3uhCIT": {
      "blockId": "U2EWIATls",
      "shelfId": "9Exg2gPYK",
      "bookId": "aSA3uhCIT",
      "name": "基础",
      "content": "<div><font color=\"#4169e1\"><b>计数与进制</b></font></div><div>&nbsp; &nbsp; 十进制：1024 = 10^3(1) + 10^2(0) +&nbsp;10^1(2) +&nbsp;1(4)</div><div>&nbsp; &nbsp; 二进制：1024 = 2^3(1) + 2^2(0) + 2^1(2)+ 1(4)</div><div><br></div><div><font color=\"#4169e1\"><b>函数防抖 debounce</b></font></div><div>&nbsp; &nbsp;&nbsp;<b>短时间内连续触发事件，回调只执行最后一次，多次触发会导致重新计时</b></div><div>&nbsp; &nbsp; const debounce = (func, wait) =&gt; {</div><div><span style=\"white-space: pre;\">\t</span>let timer;</div><div><span style=\"white-space: pre;\">\t</span>return () =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clearTimeout(timer);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timer = setTimeout(func, wait);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; };</div><div>&nbsp; &nbsp; };</div><div><br></div><div><font color=\"#4169e1\"><b>函数节流&nbsp;throttle</b></font></div><div>&nbsp; &nbsp;&nbsp;<b>事件触发后,执行回调，一定时间后才能继续触发</b></div><div>&nbsp; &nbsp; const throttle = (func, wait) =&gt; {</div><div><span style=\"white-space: pre;\">\t</span>let timer;</div><div><span style=\"white-space: pre;\">\t</span>return () =&gt; {</div><div><span style=\"white-space: pre;\">\t\t</span>if (timer) {return;}//连续触发事件判断计时器是否执行</div><div><span style=\"white-space: pre;\">\t\t</span>timer = setTimeout(()=&gt;{</div><div><span style=\"white-space: pre;\">\t\t\t</span>func();</div><div><span style=\"white-space: pre;\">\t\t\t</span>timer = null;</div><div><span style=\"white-space: pre;\">\t\t</span>}, wait);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; };</div><div>&nbsp; &nbsp; };</div>"
    },
    "zKd47sqnW": {
      "blockId": "U2EWIATls",
      "shelfId": "ntUIPXagV",
      "bookId": "zKd47sqnW",
      "name": "基础",
      "content": "局域网 LAN 概念&nbsp;<div>&nbsp; &nbsp; - 以太网技术：一条以太网线连接多台计算机（MAC地址）</div><div>广域网 WAN 概念</div><div>&nbsp; &nbsp; - 服务商 ISP 管理</div><div>&nbsp; &nbsp; - 数据包传输协议（IP）根据IP地址负责找到正确的计算机</div><div>&nbsp; &nbsp; - 更多应用协议（UDP/TCP）负责送到正确的程序</div>"
    },
    "rRLdmjJbK": {
      "blockId": "YxnegsTMH",
      "shelfId": "23a3PBcDa",
      "bookId": "rRLdmjJbK",
      "name": "数学分析(计算)",
      "content": ""
    },
    "TgJ2tJx6e": {
      "blockId": "YxnegsTMH",
      "shelfId": "23a3PBcDa",
      "bookId": "TgJ2tJx6e",
      "name": "线性代数",
      "content": ""
    },
    "afdu-jqlw": {
      "blockId": "YxnegsTMH",
      "shelfId": "23a3PBcDa",
      "bookId": "afdu-jqlw",
      "name": "统计学",
      "content": ""
    },
    "rTi82kJre": {
      "blockId": "YxnegsTMH",
      "shelfId": "Ho01HabXF",
      "bookId": "rTi82kJre",
      "name": "产品案例",
      "content": "<div><div><font color=\"#ff0000\"><b>产品案例</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>为什么咖啡行业不景气，却遍地都是？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/268169923</div><div><br></div><font color=\"#ff0000\"><b>产品变现</b></font><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>* 有哪些流量巨大但始终无法变现的互联网产品？<font color=\"#ff0000\"><b><br></b></font><div>&nbsp; &nbsp;&nbsp;https://www.zhihu.com/question/26059765/answer/148846396</div></div><div>&nbsp; &nbsp;&nbsp;https://www.zhihu.com/question/26059765/answer/253412153</div><div>&nbsp; &nbsp; 如何看待游戏《贪玩蓝月》的公司创始人被捕？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/329184075/answer/714142046</div><div>&nbsp; &nbsp;&nbsp;茅台酒厂如何防止员工上班时偷喝茅台酒？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/303620398/answer/634047672</div></div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">利益分配</b></div><div><div>&nbsp; &nbsp; *&nbsp;为什么每次中国出现危机都喜欢启动大基建?</div><div>&nbsp; &nbsp; &nbsp; https://www.zhihu.com/question/376664591/answer/1077188422</div></div><div>&nbsp; &nbsp; * 真正的有钱人都买什么奢侈品？</div><div>&nbsp; &nbsp; &nbsp; https://www.zhihu.com/question/34587107/answer/985523285<br></div><div>&nbsp; &nbsp; * 美国家庭为什么容易破产？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/351165549/answer/868357982</div><div>&nbsp; &nbsp;&nbsp;为什么房地产商不能拿低价的土地把房价降下来?</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/318916762/answer/699167318</div><div>&nbsp; &nbsp;&nbsp;如何解决资本主义周期性危机？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/55120634/answer/722572792</div><div>&nbsp; &nbsp;&nbsp;如何看待包商银行被央行接管事件 ，中小城商行的发展前景在哪？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/325970300/answer/696727070</div><div>&nbsp; &nbsp;&nbsp;没有一个经济数据，一文看懂中国经济周期的真相</div><div>&nbsp; &nbsp; https://zhuanlan.zhihu.com/p/54076753</div><div>&nbsp; &nbsp;&nbsp;股票里真的有炒股票的庄家吗?谁是庄家?</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/20451849/answer/147923476</div><div>&nbsp; &nbsp;&nbsp;余额宝规模达到 1.43 万亿意味着什么？对银行的业务有哪些影响？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/61926374/answer/193032834</div><div>&nbsp; &nbsp;&nbsp;2019年全国房价会呈什么趋势？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/302685037/answer/583089503</div><div><br></div><div><div><font color=\"#ff0000\"><b>市场划分</b></font><br></div><div>&nbsp; &nbsp;&nbsp;中文互联网的产出在渐渐枯萎吗？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/49684783/answer/1088276178</div><div>&nbsp; &nbsp;&nbsp;为什么互联网行业工资高？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/32022042/answer/799455698</div><div>&nbsp; &nbsp;&nbsp;如何着手分析一个行业？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/20219092/answer/522122813</div><div>&nbsp; &nbsp;&nbsp;应届生 应该进企业做会计还是去代理记账公司？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/278572137/answer/636717479</div></div><div><br></div><div><font color=\"#ff0000\"><b>会计学</b></font></div><div><br></div><div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>参考文章</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 请问各位财会前辈，本人小白，学会计实操，报十几种行业的好吗？</div><div>&nbsp; &nbsp; &nbsp; &nbsp; https://www.zhihu.com/collection/46005262?page=1</div><div>&nbsp; &nbsp; &nbsp; &nbsp; * 所以学会计理论盯着企业会计准则一本书就够了，如果能真正掌握几个会计的基本准则，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 一通百通，无论什么行业，什么业务模式，都能处理。<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp;为什么大部分财务人员工资那么低？</div><div>&nbsp; &nbsp; &nbsp; &nbsp; https://www.zhihu.com/question/34892325/answer/93962498</div></div>"
    },
    "AZ2G447Hy": {
      "blockId": "YxnegsTMH",
      "shelfId": "q6_9Db-FR",
      "bookId": "AZ2G447Hy",
      "name": "基础",
      "content": "<div><font color=\"#ff0000\"><b>政治目标</b></font></div><div><font color=\"#ff0000\"><b><br></b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>失去了人口红利的中国会怎样？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/354301326/answer/946847312</div><div>&nbsp; &nbsp;&nbsp;人们研究如甲骨文之类的古文字的意义是什么？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/24164877/answer/735299839</div><div>&nbsp; &nbsp; 美国为什么不侵略邻近且资源丰富的加拿大？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/21685448/answer/426741248</div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font></div><div><font color=\"#ff0000\"><b>各时间政策分析</b></font></div><div><font color=\"#ff0000\"><b><br></b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>* 有哪些行为堪比「1949 年加入国民党」？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/265048690/answer/297995221</div><div>&nbsp; &nbsp; *&nbsp;知乎用户有哪些预言最终被证实了？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/265334984/answer/1098369373</div><div>&nbsp; &nbsp; *“实体经济越来越不行了”这种流行观点是否成立？为什么？</div><div>&nbsp; &nbsp; https://www.zhihu.com/collection/46005262</div><div>&nbsp; &nbsp;<br></div><div><font color=\"#ff0000\"><b>人物立场分析</b></font></div><div><font color=\"#ff0000\"><b><br></b></font></div><div>&nbsp; &nbsp; *&nbsp;沙僧真的是因为打碎了玻璃盏才被赶到下界的吗？</div><div>&nbsp; &nbsp; &nbsp; https://www.zhihu.com/question/371515636/answer/1016244372</div><div>&nbsp; &nbsp; * 生活中有没有特别绿茶的女生？</div><div>&nbsp; &nbsp; &nbsp; https://www.zhihu.com/question/328524632/answer/995660728</div><div>&nbsp; &nbsp;&nbsp;怎样在机关事业单位不被老油条欺负？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/337531740/answer/886984703</div><div>&nbsp; &nbsp;&nbsp;最失败的一次外交活动</div><div>&nbsp; &nbsp; https://zhuanlan.zhihu.com/p/84372675</div><div>&nbsp; &nbsp;&nbsp;英国打过几乎所有国家，为什么没几个国家恨它？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/46770386/answer/797812681</div><div>&nbsp; &nbsp;&nbsp;曹操比刘邦到底差哪儿，为何不能一统天下？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/308017350/answer/626051963</div><div>&nbsp; &nbsp;&nbsp;为何史书少有令人有「跪感」的「烧脑」的权谋反转？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/54826697/answer/678424196</div><div>&nbsp; &nbsp;&nbsp;是不是外国人活得想得很简单？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/308268014/answer/620768338</div><div>&nbsp; &nbsp;&nbsp;</div><div><br></div>"
    },
    "EkK7jwTlc": {
      "blockId": "YxnegsTMH",
      "shelfId": "MMuN17Zro",
      "bookId": "EkK7jwTlc",
      "name": "摘抄",
      "content": "<div><font color=\"#4169e1\"><b>*&nbsp;知乎收藏是看不完的，不如单纯的收藏，有时间了再消化并计入笔记系统</b></font></div><div><br></div><div><font color=\"#ff0000\"><b>==================================================技术向</b></font></div><div><div>前言</div>&nbsp; &nbsp; * 一个33岁老程序员的感悟<div>&nbsp; &nbsp; https://zhuanlan.zhihu.com/p/91167083</div><div>&nbsp; &nbsp;&nbsp;前端工程师的深度或者核心竞争力体现在哪里？</div><div>&nbsp; &nbsp; https://www.zhihu.com/question/263926959/answer/275947141</div></div><div><br></div><div><b style=\"color: rgb(255, 0, 0);\">==================================================生活向</b><br></div>*&nbsp;<span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">搞科研是需要天赋的。说难也不难，就是一种研究思路的问题，先找问题，再搜数据，利用一两个验证方法而已。但是这个思路你现在要是没有，以后也很难有。有句话我觉得说的挺对，有些人为了逃避思考，愿意做任何事。</span><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><br></span></div><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">*&nbsp;</span>我一点都不讨厌我带的学生没有科研能力，我手底下上百个硕士生，不可能个个优秀。再不行，我还有博士生可以用。但是我很讨厌那种明知道自己没有科研能力，还不抓紧时间给自己找后路的学生。你要是觉得自己不想读博，跟我说，我放你去实习。那些不发论文，还不去实习给自己找出路的学生，我是最讨厌。</div><div><br></div><div><p>* 我给你实操的建议。</p><p>&nbsp; &nbsp; 一是行测，从现在起，每天利用吃饭时间看新闻或听新闻，八卦多了会有印象。</p><p>&nbsp; &nbsp; 利用上厕所和通勤时间，顶多再用半小时休闲时间看真题卷和模拟卷，不是做题是看题！</p><p>&nbsp; &nbsp; 看解题思路和背答案！一天熟知20题答案或套路，</p><p>&nbsp; &nbsp; 到考试时，你脑子里大概就有近3000道题答案了。怎么着70多分也能蒙上。</p><p>&nbsp; &nbsp; 二是申论。每天用半小时到一小时看人民日报。</p><p>&nbsp; &nbsp; 重点不是看内容，而是练习把新闻和文章，按照是什么、为什么、怎么办三部分进行解构，</p><p>&nbsp; &nbsp; 练习半年，你的申论乃至面试口头表述的逻辑性、条理性都会有大的进步，</p><p>&nbsp; &nbsp; 也能抓住题干准确答题。大概70分以上是保险的。</p><p>&nbsp; &nbsp; 根本不需要上任何培训班，浪费钱和时间，自己就能搞定。</p><p>&nbsp; &nbsp; 面试，就是你之前这些阅读量信息量的综合考验，只需要平心静气看清楚题目问什么，</p><p>&nbsp; &nbsp; 把自己平日里从新闻和人民日报学会的官方用语以有逻辑有条理的语言表述出来。妥了。</p><p>&nbsp; &nbsp; 一个考了三次第一次双第一体检拿下，第二次双第二落败，</p><p>&nbsp; &nbsp; 第三次快30岁才双一入围，目前是面试考官的老同志提供的建议。</p><p><br></p><p>* 如果你具备实事求是的态度，对一个你看不懂的东西，你不会自卑，不会崇拜，你会去研究它，了解它，等你了解了这项工作究竟是什么，你最终才能评价它，在这之后，或许你才会崇拜，才会自卑。</p><div><br><div><p>* 首先，重中之重，最重要的是<b>考研！考研！考研！</b>目标双一流院校或重点财经政法类院校。</p><p>量力而行很重要：如果你是厦大/南大/浙大/南开/天大这种准一线水平的，除了考本校之外，一定要试试北大光华/清华经管/CCER/高金/安泰/之类的地方，一旦成功那就是新的一番天地；如果你是普通一本或者二本且自身能力有限，目标可以定在重点财经类院校的，比如西南财经/江西财经/东北财经之类的，大小也是个财经类研究生，可以当作入行的敲门砖了。</p><p>其次，需要考的证书只有两个：一个叫<b>CPA-中国注册会计师</b>，另一个叫<b>司法考试</b>，其他什么CFA/ACCA/FRM一律都是屁用没有的扯犊子证书，至少在你刚毕业求职的时候是这样的，那些证书日后你有需要在职业上进一步发展的时候再行考虑吧。</p><p>不需要在毕业都考完。如果你的本科院校过得去（双一流985+两财一贸），你大四开始准备CPA，争取过个三门，碰上对研究生学历没那么太大要求的一些券商，你就可以入职开始你的投行生涯了。如果读了研究生，那就在读研期间争取把CPA跟司考都拿下，同时找券商做实习，等你毕业的时候，中金/国开/四大行总行那种地方咱们不提，拿着CPA跟司考去个海通/国泰君安/中信建投/申银万国/华泰证券之类的地方还是有可能实现的。</p><p>肺腑之言，爱信不信。</p><p><br></p><p>* 会报税、会做账、会出报表、会各种表统计、会项目测算等等，你以为你自己是个会计啦！不不不，你还是小白，因为你还不会所得税汇算清缴、不会财务分析、不会做融资、不会做上市的东西等等，慢慢学吧</p><p><br></p><p>* A股的优势，是国内门槛最低的合法赌博市场。牛市的基础不是基本面，是市场上的流动性。</p><p><br></p><p>* 在中国，如果你满足不了别人，你的人生就是失败的，除非你自己内心非常强大。</p><p><br></p><p>* 抛开传统的价值观。在我眼里，担当等于机会。而机会，就是财富。</p><p><br></p><p>*&nbsp;这东西跟能力无关，这就是平台的差距。不要以为，这世界是不会变的。那些看起来很不了不起的成绩，都源于一点点的积累</p><p><br></p><p>*&nbsp;我提供一个参考思路，大家可以深入学习一下国家十三五规划，那里说的很详细；</p><p><br></p><p>* 所谓农业经济的思维方式，就是“播种－可以收获－播更多的种－可以收更多的获”，类似的还有“考上好大学－找到好工作－从此过上幸福生活”</p><p>&nbsp; &nbsp; 线性＋静态＋预设结果。线性就是只认一条路，静态就是蒙上眼，预设结果就是认定付出就有收获，就是一头俯首耕地的呆牛。</p><p><br></p><p>*&nbsp;“没时间做某事”，也就等于认同“某事不重要”。</p><p><br></p><p>*&nbsp;拿住优质资产，盈利是大概率事件，但拿住是很难的。</p><p><br></p><p>*&nbsp;以前网上有句话说「认真你就输了」，我想我输了很多时间，而他输了可以在面试的时候侃侃而谈（说的对还是错其实没那么重要）的机会。</p><p><br></p><p>*&nbsp;深山修炼情节</p></div></div></div>"
    },
    "OnyM97DNC": {
      "blockId": "YxnegsTMH",
      "shelfId": "MMuN17Zro",
      "bookId": "OnyM97DNC",
      "name": "待读书籍",
      "content": "<span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">资治通鉴直解&nbsp;</span><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">张居正</span><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">未来地图&nbsp;</span>这本书关注了很多新兴的互联网技术、业态、模式，以及背后的商业思维<br></span></div><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">浪潮之巅&nbsp;</span>吴军 互联网产业科普向</span></div><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">两次全球大危机的比较研究&nbsp;刘鹤</span><br></span></div><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">四书集注&nbsp;</span>朱子读书法<span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">&nbsp;</span>朱熹</div><div><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\"><p>董筱丹、温铁军的《去依附》，图书管理员第一卷第一篇第三自然段。</p><p>纳西姆塔勒布《随机致富的傻瓜》《黑天鹅》《反脆弱》《非对称风险》。</p><p>庆祝新中国成立七十周年：马化腾</p><p><span class=\"RichText ztext CopyrightRichText-richText\" itemprop=\"text\">建议所有职场新人都看看《沧浪之水》或者改编的电视剧《岁月》</span><br></p><p>时代的见证者（陈润）重新发现改革&nbsp;界限下的中国（吴建新/钟庆）</p></span></div>"
    },
    "yD6sHdo7b": {
      "blockId": "DCgJdlX5R",
      "shelfId": "YKdKtabb9",
      "bookId": "yD6sHdo7b",
      "name": "面试题",
      "content": "<div><br></div><div><br></div><font color=\"#ff0000\"><b>参考文章</b></font><br><div>&nbsp; &nbsp;&nbsp;前端面试分享: 两年经验社招-阿里巴巴（已经通过）</div><div>&nbsp; &nbsp; https://zhuanlan.zhihu.com/p/83801858</div><div>&nbsp; &nbsp;&nbsp;前端开发，在不要求学历的前提下，什么水平能进百度 阿里 华为 b站的大公司？</div><div>&nbsp; &nbsp; https://www.zhihu.com/collection/46005262</div><div>&nbsp; &nbsp;&nbsp;毕业一年左右的前端妹子面经总结</div><div>&nbsp; &nbsp;&nbsp;https://zhuanlan.zhihu.com/p/74229306</div>"
    },
    "nyF-QQmkl": {
      "blockId": "DCgJdlX5R",
      "shelfId": "YKdKtabb9",
      "bookId": "nyF-QQmkl",
      "name": "公司账号",
      "content": "JIRA<div>&nbsp; &nbsp; huangwenqiang</div><div>&nbsp; &nbsp; a123456789</div><div><br></div><div>Gitlab</div><div>&nbsp; &nbsp;&nbsp;wqao123456</div><div>&nbsp; &nbsp; 974879409</div><div><br></div><div><div>项目设计稿原型：</div><div>&nbsp; &nbsp; 金邻APP：https://ku1nos.axshare.com</div><div>&nbsp; &nbsp; 岛主APP：https://ee6atz.axshare.com</div><div>&nbsp; &nbsp; 蓝湖设计稿：https://lanhuapp.com/url/Ys9wV-87ZWO</div></div>"
    },
    "5WWpMPDhf": {
      "blockId": "DCgJdlX5R",
      "shelfId": "v1x8EzKB6",
      "bookId": "5WWpMPDhf",
      "name": "DOM 绘图",
      "content": "<font color=\"#ff0000\"><b>EchartsJS</b></font><div>&nbsp; &nbsp;<b> 使用：npm install echarts</b></div><div>&nbsp; &nbsp; <b>1.需要为一个Echarts实例准备一个具有宽高的DOM容器，并初始化这个实例</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"main\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"width: 600px;height:400px;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></div><div><span class=\"hljs-tag\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span class=\"hljs-keyword\">var</span> <font color=\"#4169e1\"><b>myChart </b></font>= echarts.init(<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'main'</span>));</div><div>&nbsp; &nbsp; <b>2.指定实例的图表类型和数据</b></div><div><b>&nbsp; &nbsp;&nbsp;</b><b style=\"color: rgb(65, 105, 225);\">myChart .setOption({</b></div><div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; series:[</b></div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</b></div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type:</b></div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data:</b></div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</b></div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ......</b></div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; ]</b></div></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; })</b></div>"
    },
    "QaZb5jCcY": {
      "blockId": "DCgJdlX5R",
      "shelfId": "2bQM1u5VX",
      "bookId": "QaZb5jCcY",
      "name": "ES6 Promise 实现",
      "content": "<div><b style=\"color: rgb(255, 0, 0);\">目标：异步函数链式调用</b><br></div><div><b style=\"color: rgb(255, 0, 0);\"><br></b></div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">* Promise( async )：</font></div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp; &nbsp; </font><font style=\"\">- 声明</font></div><div><font style=\"\"><font color=\"#4169e1\"><b>&nbsp; &nbsp; &nbsp; &nbsp; A：data</b></font></font></div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>B：</b></font><font color=\"#4169e1\"><b>then微任务队列</b></font>，<div><font style=\"\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>C：</b></font></font><b style=\"color: rgb(65, 105, 225);\">微</b><b style=\"color: rgb(65, 105, 225);\">任务队列执行方法</b></div><div><font style=\"\">&nbsp; &nbsp; - 执行传入的</font><span style=\"color: rgb(255, 0, 0); font-weight: 700;\">async</span>，通过<font color=\"#4169e1\"><b> C&nbsp;</b></font>执行所有微任务</div><div><font style=\"\"><br></font></div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">*&nbsp;then( </font><font color=\"#4169e1\" style=\"\"><b>queueHandle</b></font><font color=\"#ff0000\" style=\"font-weight: bold;\"> )</font></div><div><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp; &nbsp; </font><font style=\"\">-&nbsp;返回新Promise(&nbsp;<font color=\"#4169e1\"><b>queueHandle</b></font><font color=\"#ff0000\" style=\"font-weight: bold;\">&nbsp;</font>)</font></div><div><font style=\"\"><br></font></div><div><font style=\"\">*&nbsp;执行步骤</font></div><div><font style=\"\"><br></font></div><div><font style=\"\">&nbsp; &nbsp; 1.构建Promise( async )</font></div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;async 同步代码执行<div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;async&nbsp;异步代码进入 V8异步队列<font color=\"#4169e1\"><b>（1）</b></font></div><div><font color=\"#4169e1\"><b><br></b></font></div><div>&nbsp; &nbsp; 2.执行 then(&nbsp;getThenRes )</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;构建Promise2( getThenRes&nbsp;)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;构建微任务：调用 getThenRes</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;then&nbsp;中同步代码执行，this=<font color=\"#ff0000\"><b>上一个Promise</b></font>&nbsp;<font color=\"#4169e1\"><b>微任务+1</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;返回 Promise2</div><div><font color=\"#4169e1\"><b><br></b></font></div><div>&nbsp; &nbsp; 3.执行 then( getThenRes&nbsp;)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;构建Promise3( getThenRes&nbsp;)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;then&nbsp;中同步代码执行，this=<font color=\"#ff0000\"><b>上一个Promise2</b></font>&nbsp;<font color=\"#4169e1\"><b>微任务</b></font><b style=\"color: rgb(65, 105, 225);\">+1</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;返回 Promise3</div><div><br></div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>(1)</b></font><b style=\"color: rgb(65, 105, 225);\">&nbsp;</b>async&nbsp;异步代码得到结果 <font color=\"#ff0000\"><b>Res</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;通过Promise的<b style=\"\"><font color=\"#4169e1\"> C(</font><font color=\"#ff0000\">Res</font></b><b style=\"color: rgb(65, 105, 225);\">)，</b>执行Promise2 的微任务：执行 getThenRes&nbsp;取得返回值</div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;通过<font color=\"#ff0000\"><b>Promise2</b></font>的<b><font color=\"#4169e1\">&nbsp;C(</font><font color=\"#ff0000\">Res</font></b><b style=\"color: rgb(65, 105, 225);\">)，</b>执行Promise3 的微任务：执行 getThenRes&nbsp;取得返回值<div>&nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;通过<font color=\"#ff0000\"><b>Promise3</b></font>的<b><font color=\"#4169e1\">&nbsp;C(</font><font color=\"#ff0000\">Res</font></b><b style=\"color: rgb(65, 105, 225);\">)，没有微任务</b><br></div><div><b style=\"color: rgb(65, 105, 225);\"><br></b></div><div><b style=\"color: rgb(65, 105, 225);\">*&nbsp;代码实现</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; -----------------------------------------------------------------</b></div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp;</b> function Promise( (userTask)=&gt;{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; this.data = null</div><div>&nbsp; &nbsp; &nbsp; &nbsp; this.queue = []</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function <font color=\"#ff0000\"><b>resolve</b></font>(value) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.data = value</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.queue.forEach(<font color=\"#4169e1\"><b>thenTask </b></font>=&gt; <font color=\"#4169e1\"><b>thenTask</b></font>())</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; userTask(<font color=\"#ff0000\"><b>resolve</b></font>.bind(this))</div><div>&nbsp; &nbsp; } )</div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; -----------------------------------------------------------------</b><div><div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp;</b>&nbsp;Promise.prototype.then = (getThenRes)=&gt;{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; let <b>buildTask </b>= <font color=\"#ff0000\"><b>resolveParam&nbsp;</b></font>=&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let <font color=\"#4169e1\"><b>thenTask </b></font>= ()=&gt;{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let res = getThenRes(this.data)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res instanceof Promise ? res.then(<font color=\"#ff0000\"><b>resolve</b></font>) : <font color=\"#ff0000\"><b>resolve</b></font>(res)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //&nbsp;这里的&nbsp;<font color=\"#ff0000\"><b>r</b></font><b style=\"color: rgb(255, 0, 0);\">esolveParam</b><font color=\"#ff0000\"><b>&nbsp;</b></font>指then方法调用者的&nbsp;<font color=\"#ff0000\"><b>resolve</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>this</b>.queue.push(<font color=\"#4169e1\"><b>thenTask</b></font>) <b>//&nbsp;这里的this指向then方法调用者</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return new Promise(<b>buildTask</b>)</div><div>&nbsp; &nbsp; }</div></div><b style=\"color: rgb(65, 105, 225);\">&nbsp; &nbsp; -----------------------------------------------------------------</b><div><font color=\"#4169e1\"><b>&nbsp; &nbsp; Async / Await&nbsp;</b></font>是内置了执行器的 generator 函数。</div><div><font color=\"#4169e1\"><b>&nbsp; &nbsp;&nbsp;</b></font></div><div><font color=\"#4169e1\"><b><br></b></font><div><font color=\"#ff0000\"><b>参考文章</b></font></div><div>&nbsp; &nbsp; 20行实现一个简单的Promise</div><div>&nbsp; &nbsp; https://my.oschina.net/jamesview/blog/3216558</div></div><div>&nbsp; &nbsp; async/await&nbsp;的本质</div><div>&nbsp; &nbsp;&nbsp;https://zhuanlan.zhihu.com/p/112800700</div>"
    },
    "0-DGMoTWa": {
      "blockId": "DCgJdlX5R",
      "shelfId": "v1x8EzKB6",
      "bookId": "0-DGMoTWa",
      "name": "虚拟DOM",
      "content": "<font color=\"#ff0000\"><b>痛点：高频的DOM操作及其大量Dom状态管理</b></font><div>&nbsp; &nbsp; 正常：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 监听DOM状态数据 =&gt;&nbsp;手动更新DOM</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>MVVM</b></font>：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 监听DOM状态数据 =&gt;&nbsp;通过模板引擎重新渲染整颗DOM树</div><div>&nbsp; &nbsp; <font color=\"#4169e1\"><b>Virtual DOM</b></font>：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 本质上就是在 JS 和 DOM 之间做了一个缓存，通过对比局部渲染DOM树</div><div><br></div><div>参考文章</div><div>&nbsp; &nbsp;&nbsp;前端为什么操作 DOM 是最耗性能的呢？</div><div>&nbsp; &nbsp;&nbsp;https://www.zhihu.com/question/324992717</div>"
    },
    "sbf75ijDW": {
      "blockId": "DCgJdlX5R",
      "shelfId": "v1x8EzKB6",
      "bookId": "sbf75ijDW",
      "name": "性能优化",
      "content": "<div><b style=\"color: rgb(255, 0, 0);\">痛点：高频的DOM操作及其大量Dom状态管理</b><br></div><div>&nbsp; &nbsp; 正常：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 监听DOM状态数据 =&gt;&nbsp;手动更新DOM</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>MVVM</b></font>：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 监听DOM状态数据 =&gt;&nbsp;通过双向绑定自动重新渲染整颗DOM树</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 双向绑定原理</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;通过Object.defineProperty()来<font color=\"#ff0000\"><b>产生 set/get监听函数 </b></font>实现<font color=\"#ff0000\"><b>数据劫持</b></font></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 监听者：监听所有属性</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 订阅者管理器：根据输入的监听属性更新DOM订阅者</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DOM订阅者：根据对应的监听属性更新视图</div><div>&nbsp; &nbsp;&nbsp;<font color=\"#4169e1\"><b>Virtual DOM</b></font>：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 本质上就是在 JS 和 DOM 之间做了一个缓存，通过对比局部渲染DOM树</div><div>&nbsp; &nbsp;&nbsp;</div><div>参考文章</div><div>&nbsp; &nbsp;&nbsp;前端为什么操作 DOM 是最耗性能的呢？</div>&nbsp; &nbsp; https://www.zhihu.com/question/324992717<div><font color=\"#ff0000\"><b><br></b></font></div><div><font color=\"#ff0000\"><b>SSR：server side render</b></font><div>&nbsp; &nbsp; *&nbsp;仅仅适用于Vue/React相关虚拟DOM框架&nbsp;</div><div>&nbsp; &nbsp; *&nbsp;返回单纯HTML结构的页面，并局部标记，之后再根据标记重新渲染</div><div>&nbsp; &nbsp; *&nbsp;更有利于SEO（爬虫只获取请求结果，不执行其中的JS脚本）</div><div>&nbsp; &nbsp; *&nbsp;首屏渲染不容易有长时间的白屏</div><div><br></div><div>客户端渲染</div><div>&nbsp; &nbsp; 请求HTML文件</div><div>&nbsp; &nbsp; JS文件加载执行：JS代码动态生成DOM（空白屏）</div><div>&nbsp; &nbsp; CSS加载执行</div><div><br></div><div>服务端渲染</div><div>&nbsp; &nbsp; 请求核心不带样式的HTML字符串</div>&nbsp; &nbsp; CSS加载执行<div><br></div><div><font color=\"#ff0000\"><b>懒加载</b></font></div><div><font color=\"#ff0000\"><b>&nbsp; &nbsp;&nbsp;</b></font>可视区域加载：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 元素offsetTop -&nbsp;可视区scroolTop &lt;&nbsp;浏览器clientHeight</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - getBoundingClientRect() //获取元素的大小及位置</div></div>"
    }
  }
}