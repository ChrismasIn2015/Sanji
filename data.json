{
  "blocks": {
    "D2S51gJkH": {
      "blockId": "D2S51gJkH",
      "name": "前端开发",
      "color": "#666666"
    },
    "i9hSICf-d": {
      "blockId": "i9hSICf-d",
      "name": "工作专区",
      "color": "#666666"
    }
  },
  "shelfs": {
    "VYWlh1oUK": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "name": "1.关于浏览器",
      "books": [
        {
          "blockId": "D2S51gJkH",
          "shelfId": "VYWlh1oUK",
          "bookId": "t8zI6NxlB",
          "name": "13",
          "content": ""
        },
        {
          "blockId": "D2S51gJkH",
          "shelfId": "VYWlh1oUK",
          "bookId": "bp5x-ofOD",
          "name": "啊是啊是",
          "content": ""
        },
        {
          "blockId": "D2S51gJkH",
          "shelfId": "VYWlh1oUK",
          "bookId": "UUgdEYUCg",
          "name": "213",
          "content": ""
        }
      ]
    },
    "Ovrt1kT5d": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "name": "2.关于JavaScript",
      "books": [
        {
          "blockId": "D2S51gJkH",
          "shelfId": "Ovrt1kT5d",
          "bookId": "-ASbUq8l4",
          "name": "13213",
          "content": ""
        }
      ]
    },
    "zbn-DYDR3": {
      "blockId": "zzyVg8gA_",
      "shelfId": "zbn-DYDR3",
      "name": "阿斯达"
    },
    "f2_y5u4yN": {
      "blockId": "i9hSICf-d",
      "shelfId": "f2_y5u4yN",
      "name": "1.公司的账号"
    },
    "UKfQP2D2P": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "name": "前端工程化"
    }
  },
  "books": {
    "ojYwL7UG6": {
      "blockId": "zzyVg8gA_",
      "shelfId": "zbn-DYDR3",
      "bookId": "ojYwL7UG6",
      "name": "213",
      "content": ""
    },
    "p1cpxe2o8": {
      "blockId": "i9hSICf-d",
      "shelfId": "f2_y5u4yN",
      "bookId": "p1cpxe2o8",
      "name": "平台账号密码",
      "content": "JIRA<div>&nbsp; &nbsp; huangwenqiang</div><div>&nbsp; &nbsp; hwq1234560.</div><div><br></div><div>Gitlab</div><div>&nbsp; &nbsp;&nbsp;wqao123456</div><div>&nbsp; &nbsp; 974879409</div><div><br></div><div><div>项目设计稿原型：</div><div>&nbsp; &nbsp; 金邻APP：https://ku1nos.axshare.com</div><div>&nbsp; &nbsp; 岛主APP：https://ee6atz.axshare.com</div><div>&nbsp; &nbsp; 蓝湖设计稿：https://lanhuapp.com/url/Ys9wV-87ZWO</div></div>"
    },
    "Mho-rv0VY": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "Mho-rv0VY",
      "name": "HTML",
      "content": "<div>浏览器渲染过程</div><div>&nbsp; &nbsp; 1.用HTML分析器，分析HTML元素，构建一颗DOM树</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>- onload函数触发</div><div>&nbsp; &nbsp; 2.用CSS分析器，分析CSS文件和元素样式，生成页面的样式表。</div><div>&nbsp; &nbsp; 3.将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 每个DOM节点都有attach方法，接受样式信息，返回一个render对象。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 这些render对象最终会被构建成一颗Render树。</div><div>&nbsp; &nbsp; 4.有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。</div><div>&nbsp; &nbsp; 5.Render树和节点显示坐标都有了，就调用每个节点paint方法，把它们绘制出来。&nbsp;</div><div>&nbsp; &nbsp; # 构建DOM数是一个渐进过程，为达到更好用户体验，渲染引擎会尽快将内容显示在屏幕上。</div><div>&nbsp; &nbsp; # 它不必等到整个HTML文档解析完毕之后才开始构建render数和布局。</div><div>***********************************************************************************</div><div><span style=\"white-space:pre\">\t</span>rel : 关系 : icon/stylesheet</div><div><span style=\"white-space:pre\">\t</span>href : 连接 : #顶部/#id/javascript/url</div><div><span style=\"white-space:pre\">\t</span></div><div>&nbsp; &nbsp; 网页图标 : &lt;link rel=\"icon\" src=\"logo.png\" sizes=\"32x32\"&gt;</div><div>&nbsp; &nbsp; 图片连接 : &lt;a href&gt;&lt;img src=\"URL\" alt=\"替换文本\"&gt;&lt;/a&gt;</div><div>&nbsp; &nbsp; 文字区域 : &lt;textarea&gt; disabled=\"disabled\"禁止拖动</div><div><br></div><div>&nbsp; &nbsp; 表单 : &lt;form action=\"url\" method=\"post\"&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 样式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 表单长度 : size</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 底部文字 : placeholder</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 内容长度 : maxlength</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 内容选取 : name/value</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (type)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 内容text/复选checkbox/单选radio</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 重置reset/下拉select+option</div>"
    },
    "_6NM7OvHK": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "_6NM7OvHK",
      "name": "CSS-通用",
      "content": "<div>选择器</div><div><span style=\"white-space:pre\">\t</span>1.优先级: 行内&gt; #ID选择器 &gt; .类+伪类选择器/属性选择器 &gt; 元素选择器 &gt; *通用 &gt; 继承</div><div><span style=\"white-space:pre\">\t</span>2.语法: 多选择器: A，B，C / a -/+/~ b : 前/后/后所有 / A &gt; a(仅仅子)</div><div>&nbsp; &nbsp; 3.伪类</div><div>&nbsp; &nbsp; &nbsp; &nbsp; :link 未访问 :active 长按 :hover 鼠标放入 :visited 已访问</div><div>&nbsp; &nbsp; &nbsp; &nbsp; :focus 文本框输入时 :selection 文本鼠标选中时候</div><div>&nbsp; &nbsp; &nbsp; &nbsp; :before/after 文字前/后&amp;标签之间 { content:\"\" }</div><div>&nbsp; &nbsp; 4.参数</div><div>&nbsp; &nbsp; &nbsp; &nbsp; p:first-child p:nth-child(num):任意位置子元素 p:first-of-type:第一个p</div><div>*********************************************************************</div><div>常用样式</div><div><span style=\"white-space:pre\">\t</span>背景图像</div><div><span style=\"white-space:pre\">\t\t</span>1. 设置背景图: background-image: url(../img/a.jpg)</div><div><span style=\"white-space:pre\">\t\t</span>2. 控制xy重复: background-repeat: repeat-x/y / no repeat</div><div><span style=\"white-space:pre\">\t\t</span>3. 铺满屏幕：background-size:cover/num%</div><div><span style=\"white-space:pre\">\t\t</span>4. 固定不动：background-attachment: fixed;</div><div><span style=\"white-space:pre\">\t</span>行内块元素</div><div><span style=\"white-space:pre\">\t\t</span>display:inline-block</div><div><span style=\"white-space:pre\">\t\t</span>水平对齐 vertical-align: top</div><div><span style=\"white-space:pre\">\t\t</span>间隙 font-size: 0</div><div>&nbsp; &nbsp; Overflow</div><div>&nbsp; &nbsp; &nbsp; &nbsp; visible<span style=\"white-space:pre\">\t</span>默认值。内容不会被修剪，会呈现在元素框之外。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hidden<span style=\"white-space:pre\">\t</span>内容会被修剪，并且其余内容是不可见的。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; scroll<span style=\"white-space:pre\">\t</span>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; auto<span style=\"white-space:pre\">\t</span>如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</div><div>&nbsp; &nbsp; 背景透明:</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>opacity：0~1：所有 rgba(x,y,z,0~1)：单独</div><div>&nbsp; &nbsp; 文字</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>空格转义字符 &amp;nbsp</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>默认:&nbsp;</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span>换行符无效 / 多个空格会被合并为一个 / 句子自动换行 / 单词超出边界</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>Block-换行:&nbsp;</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span>word-wrap: break-word</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>裁剪:&nbsp;</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span>white-space: nowrap;</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span>text-overflow: ellipsis;</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span>overflow: hidden;</div>"
    },
    "XURCBzeg1": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "XURCBzeg1",
      "name": "CSS-动画",
      "content": "<div>transform</div><div>&nbsp; &nbsp; 平移：transform: translate(X,Y)</div><div>&nbsp; &nbsp; 旋转：transform-origin:x y：旋转基点</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform: rotate(30deg)</div><div>&nbsp; &nbsp; 放缩：transform: scale(X,Y);//倍数</div><div>&nbsp; &nbsp; 3D旋转：transform: rotateX/Y(120deg)</div><div>&nbsp; &nbsp;&nbsp;</div><div>*********************************************************************</div><div>transition</div><div>&nbsp; &nbsp; 1.为指定属性(时长)添加过渡效果：transition: width 2s,height 1s...</div><div>&nbsp; &nbsp; 2.指定属性绑定事件监听：div:hover {width...height...}</div><div>&nbsp; &nbsp; # transition: all 1s + css组合</div><div>&nbsp; &nbsp;&nbsp;</div><div>*********************************************************************</div><div>复杂</div><div>&nbsp; &nbsp; 1.animation:name 1s 时间函数 开始时间 次数();</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>ease:慢快慢/linear:匀速</div><div>&nbsp; &nbsp; 2.@keyframes name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 0% {background:red;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 100% {background:green;}}</div><div>支持</div><div><span style=\"white-space:pre\">\t</span>-webkit- Chrome:IOS/-moz- firefox/</div>"
    },
    "N7oaZjUns": {
      "blockId": "D2S51gJkH",
      "shelfId": "VYWlh1oUK",
      "bookId": "N7oaZjUns",
      "name": "CSS-布局",
      "content": "<div>定位</div><div>&nbsp; &nbsp; 1 文档流: relative：相对于原位置移动</div><div>&nbsp; &nbsp; 2 脱离文档流：</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>absolute：相对relative移动,会提升层级</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 脱离文档流而产生的高度塌陷 &amp; 相邻|垂直|内外边距重叠</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以通过添加块元素解决,清除因浮动产生的移动影响</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .clearfix:before,.clearfix:after</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {content:\"\";display:table;clear:both;}</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>float：会产生挤压</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>fixed：相对于可视界面移动,会提升层级</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span></div><div>*********************************************************************</div><div>常用的居中方式</div><div>&nbsp; &nbsp; 1 水平居中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; margin:0 auto&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (行内)text-align:center</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; justify-content: center;</div><div>&nbsp; &nbsp; 2 垂直居中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (单行内)line-height</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (多行)display:table-cell; vertical-align: middle;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; align-items: center;</div><div>&nbsp; &nbsp; 3 同时对齐</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ab+re定位：trbl:0; margin:auto;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; top/left：50%; transform(-50%,-50%)/margin-l/r:-50%;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; justify-content: center; align-items: center;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; (弹性盒)display: flex; margin:auto;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>*********************************************************************</div><div>弹性盒子</div><div><span style=\"white-space:pre\">\t</span>容器: flex/inline-flex</div><div><span style=\"white-space:pre\">\t\t</span>#. flex-direction: 设置主轴方向 row | row-reverse | column | column-reverse</div><div><span style=\"white-space:pre\">\t\t</span>#. flex-wrap: 换行 nowrap | wrap | wrap-reverse</div><div><span style=\"white-space:pre\">\t\t</span>1. flex-flow: 合并 flex-direction 和 flex-wrap</div><div><span style=\"white-space:pre\">\t\t</span>2. justify-content:&nbsp;</div><div><span style=\"white-space:pre\">\t\t\t</span>对齐方式 flex-start/flex-end/center | *space-between | *space-around</div><div><span style=\"white-space:pre\">\t\t</span>3. align-items:&nbsp;</div><div><span style=\"white-space:pre\">\t\t\t</span>纵轴对齐 flex-start/flex-end/center | *baseline | *stretch</div><div><span style=\"white-space:pre\">\t\t</span>4. (较少)align-content:&nbsp;</div><div><span style=\"white-space:pre\">\t\t\t</span>多行纵轴对齐 flex-start/flex-end/center | *space-between | *space-around | *stretch</div><div><span style=\"white-space:pre\">\t\t</span># 子元素 float/clear/vertical-align 会失效</div><div><span style=\"white-space:pre\">\t</span>项目</div><div><span style=\"white-space:pre\">\t\t</span>1. order: 值越小越靠前/默认 0</div><div><span style=\"white-space:pre\">\t\t</span>2. flex: (占比) none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</div><div><span style=\"white-space:pre\">\t\t</span>3. align-self: 单独设置 align-items 个性的对齐</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>4. margin-?:auto 会获取剩余所有空白</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span></div><div>*********************************************************************</div><div>移动端适配&nbsp;</div><div># 响应式布局: 主要以@media为不同设备设计不同样式</div><div># 自适应布局: 以比例布局为主</div><div><span style=\"white-space:pre\">\t</span>1.定义默认宽度</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 所有浏览器都有默认宽度,但是每个设备宽度都不一样</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 所以用这个meta定义了浏览器宽度 = 设备宽度</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &lt;meta name='viewport' content= 'width=device-width, initial-scale=1.0'&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>*********************************************************************</div><div>百分比布局</div><div><span style=\"white-space:pre\">\t</span>- 为不同设备编写不同的CSS样式文件</div><div><span style=\"white-space:pre\">\t</span>- 在头部 &lt;link @media='screen/speech'/(min-width:500px)(if)..&gt;</div><div><span style=\"white-space:pre\">\t</span>- 这样根据不同的条件 相关的样式就会加载/覆盖</div><div><span style=\"white-space:pre\">\t</span>- 宽度默认 100%; - 但是字体可能会模糊</div><div><span style=\"white-space:pre\">\t</span>@import 'common/mobile/pc.css'</div><div><span style=\"white-space:pre\">\t</span></div><div>*********************************************************************</div><div>rem布局</div><div><span style=\"white-space:pre\">\t</span># 像素设备比 -DPR -表示1个css像素对应（覆盖）的物理像素个数</div><div><span style=\"white-space:pre\">\t</span># HTML 默认font-size:16px / 下面动态设置HTML字体</div><div>&nbsp; &nbsp; (function(doc, win) {</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>let html = doc.getElementsByTagName(\"html\")[0],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // orientationchange-&gt; 手机屏幕转屏</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // resize -&gt; 页面大小被缩放了</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>window.reEvt = \"orientationchange\" in win ? \"orientationchange\" : \"resize\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; let reFontSize = function() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var clientW = doc.documentElement.clientWidth || doc.body.clientWidth;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(!clientW) {return;}</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span>html.style.fontSize = 100 * (clientW / 375) + \"px\";}</div><div>&nbsp; &nbsp; &nbsp; &nbsp; win.addEventListener(reEvt, reFontSize);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // DOMContentLoaded-&gt;dom加载完就执行,onload要dom/css/js都加载完才执行</div><div>&nbsp; &nbsp; &nbsp; &nbsp; doc.addEventListener(\"DOMContentLoaded\", reFontSize);</div><div>&nbsp; &nbsp; })(document, window);</div>"
    },
    "eqEz5GlpB": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "eqEz5GlpB",
      "name": "加载过程",
      "content": "<div>JS执行过程</div><div><span style=\"white-space:pre\">\t</span>1.语法检查</div><div><span style=\"white-space:pre\">\t</span>2.预编译</div><div><span style=\"white-space:pre\">\t\t</span>1.进入全局/函数环境，创建相应的执行上下文，形成执行上下文优先加载栈</div><div><span style=\"white-space:pre\">\t\t</span>2.创建执行上下文</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 变量提升 (undefined)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 建立作用域链 : 可以访问/查找父级内存</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 确定this的指向</div><div>&nbsp; &nbsp; 3.代码执行:按顺序(单线程)变量赋值/函数执行</div><div><span style=\"white-space:pre\">\t\t</span>1.主线程执行(耗时任务放入回调队列:异步非阻塞)</div><div><span style=\"white-space:pre\">\t\t</span>2.辅助线程初始化(相关回调代码放入回调队列)</div><div><span style=\"white-space:pre\">\t\t</span>- 如初始化定时器，绑定监听动作，发送AJAX</div><div><span style=\"white-space:pre\">\t\t</span>3.主线程执行完毕，查看是否有需要执行的回调代码再进入主线程(循环队列)</div>"
    },
    "0z_SNdTrY": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "0z_SNdTrY",
      "name": "数据类型",
      "content": "<div>1.数据结构</div><div>&nbsp; &nbsp; 基本数据(值)类型：本质是内存代表的值保存在栈中</div><div>&nbsp; &nbsp; 1.undefined : undefined，代表未赋值的变量(var a)默认指向唯一实例</div><div>&nbsp; &nbsp; 2.null : Object</div><div>&nbsp; &nbsp; 3.Number</div><div>&nbsp; &nbsp; 4.String</div><div>&nbsp; &nbsp; 5.Boolean</div><div>Number</div><div><span style=\"white-space:pre\">\t</span>变为数字: Number(str): Number</div><div><span style=\"white-space:pre\">\t</span>parseInt/Float(): 先转换成字符串: 从头逐字符取出有效数字并返回数字</div><div>typeof a</div><div><span style=\"white-space:pre\">\t</span>返回a的所属具体对象字符串，如具体构造函数名:string)</div><div><span style=\"white-space:pre\">\t</span>无法判断null:obj(语言bug)和Array:obj</div><div>a instanceof Obj</div><div><span style=\"white-space:pre\">\t</span>返回a是否是B构造函数的实例：判断对象</div><div># 用 if 判断值为 undefined/null/'' 效果与 false 相同</div><div><br></div><div>**** ES6 ****</div><div><br></div><div><div>Symbol</div><div><span style=\"white-space:pre\">\t</span># 标识唯一的值 - 解决：字符串不具有唯一性</div><div><span style=\"white-space:pre\">\t</span>应用1.常量声明 const NAME = Symbol('name')</div><div><span style=\"white-space:pre\">\t</span>应用2.键声明</div><div>Symbol.for('tar'):全局搜索/若无则新建</div><div>Symbol.keyFor('tar'):全局键搜索</div><div>***********************************************************************************</div><div>迭代器</div><div><span style=\"white-space:pre\">\t</span>Symbol.iterator()</div></div><div><br></div><div><div>Object - key只能是 Symbol/String</div><div><span style=\"white-space:pre\">\t</span>增加1/修改/查询 obj.key = new</div><div><span style=\"white-space:pre\">\t</span>增加2 Object.assign(target, source) // 潜拷贝/拷贝了引用</div><div><span style=\"white-space:pre\">\t</span>删除 delete obj.key</div><div><span style=\"white-space:pre\">\t</span>--------------------------</div><div><span style=\"white-space:pre\">\t</span>数组 Object.keys(obj)</div><div><span style=\"white-space:pre\">\t</span>键数组 Object.keys(obj)</div><div><span style=\"white-space:pre\">\t</span>值数组 Object.values(obj)</div><div><span style=\"white-space:pre\">\t</span>值键对二维数组 Object.entries(obj)</div><div><span style=\"white-space:pre\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span># 由于不同的浏览器引擎采用的规范可能不同，所以输出的顺序也就不一样</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>for(let e in obj){ console.log(obj[e]) }</div><div><span style=\"white-space:pre\">\t</span>--------------------------</div><div><span style=\"white-space:pre\">\t</span># 判断对象为空 JSON.stringfy()==={} || Object.keys(obj).length===0</div><div>***********************************************************************************</div><div>Map - key 是任意类型</div><div><span style=\"white-space:pre\">\t</span>新建 new Map(二维数组)</div><div><span style=\"white-space:pre\">\t</span>增加 map.set(key,value)</div><div><span style=\"white-space:pre\">\t</span>删除 map.delete(key)</div><div><span style=\"white-space:pre\">\t</span>克隆/合并 new Map(oldMap)</div><div><span style=\"white-space:pre\">\t</span>长度 size</div><div><span style=\"white-space:pre\">\t</span>--------------------------</div><div><span style=\"white-space:pre\">\t</span>键数组 map.keys(map)</div><div><span style=\"white-space:pre\">\t</span>值数组 map.values(map)</div><div><span style=\"white-space:pre\">\t</span>值键对二维数组 Array.from(map)</div><div><span style=\"white-space:pre\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span># 按插入顺序输出</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>for(let [key, value] of map){}</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>forEach( function(value,key){}, map)</div></div><div><br></div><div>***********************************************************************************<br></div><div><div>Array</div><div>&nbsp; &nbsp; shift()<span style=\"white-space:pre\">\t</span>删除并返回数组的第一个元素</div><div>&nbsp; &nbsp; pop()<span style=\"white-space:pre\">\t</span>删除并返回数组的最后一个元素</div><div>&nbsp; &nbsp; push()<span style=\"white-space:pre\">\t</span>向数组的末尾添加一个或更多元素，并返回新的长度</div><div><span style=\"white-space:pre\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 合并：A.concat(B)</div><div>&nbsp; &nbsp; 截取 slice(start, end之前)</div><div>&nbsp; &nbsp; 替换 splice(start, 删除num个数, '新元素')</div><div>&nbsp; &nbsp; 带分隔符的字符串：join(分隔符)</div><div><span style=\"white-space:pre\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 排序：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; reverse()<span style=\"white-space:pre\">\t</span>颠倒数组中元素的顺序</div><div>&nbsp; &nbsp; &nbsp; &nbsp; sort(compare) 默认排序顺序是根据字符串UniCode码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 需要传参 function compare(start,end){ return start-end // 升序 }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 对象排序</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function compare(e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return function(start,end){ return start[e]-end[e] }}</div><div><span style=\"white-space:pre\">\t</span>--------------------------</div><div>&nbsp; &nbsp; 遍历</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>arr.forEach(function(item,index,thisArr){ console.log(item) })</div><div>***********************************************************************************</div><div>Set - 值唯一/任意类型</div><div><span style=\"white-space:pre\">\t</span>新建 new Set(Array/String) // 数组去重</div><div><span style=\"white-space:pre\">\t</span>增加 set.add(value)</div><div><span style=\"white-space:pre\">\t</span>长度 size</div><div><span style=\"white-space:pre\">\t</span>--------------------------</div><div><span style=\"white-space:pre\">\t</span>数组 let arr = [...set]</div><div><span style=\"white-space:pre\">\t</span>--------------------------</div><div><span style=\"white-space:pre\">\t</span>并集 new Set([...a, ...b])</div><div><span style=\"white-space:pre\">\t</span>交集 new Set([...a].filter(x =&gt; b.has(x)))</div><div><span style=\"white-space:pre\">\t</span>差集 new Set([...a].filter(x =&gt; !b.has(x)))</div><div>***********************************************************************************</div><div>String</div><div>&nbsp; &nbsp; 合并：concat()</div><div>&nbsp; &nbsp; 截取</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>slice(statr, end之前)</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>substring(statr, end之前)</div><div>&nbsp; &nbsp; 首个下标：indexOf()/lastIndexOf()</div><div>&nbsp; &nbsp; 指定下标：charAt()</div><div>&nbsp; &nbsp; #</div><div>&nbsp; &nbsp; 新字符串：String(ins): String</div><div>&nbsp; &nbsp; 新字符串：Object.toString(): 返回新字符串, undefined/null 报错</div><div>&nbsp; &nbsp; 带分隔符的数组<span style=\"white-space:pre\">\t</span>split(分隔符)</div><div><span style=\"white-space:pre\">\t</span>#</div><div>&nbsp; &nbsp; match()<span style=\"white-space:pre\">\t</span>找到一个或多个正则表达式的匹配。</div><div>&nbsp; &nbsp; replace()<span style=\"white-space:pre\">\t</span>替换与正则表达式匹配的子串。</div><div>&nbsp; &nbsp; search()<span style=\"white-space:pre\">\t</span>检索与正则表达式相匹配的值。</div></div>"
    },
    "ZAV3VLkS2": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "ZAV3VLkS2",
      "name": "创建对象",
      "content": "<div>声明：function name(){}</div><div>&nbsp; &nbsp; # 赋值：button.onclick/var x = function(){};</div><div>&nbsp; &nbsp; # 直接return;等于直接退出函数</div><div>&nbsp; &nbsp; # 立即调用匿名函数(function(){})();//目的是为了隐藏实现</div><div>&nbsp; &nbsp; - arguments伪数组来保存参数</div><div>&nbsp; &nbsp; - arguments.callee来保存当前执行的函数对象</div><div>创建对象</div><div><span style=\"white-space:pre\">\t</span>声明对象</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 通过大写函数首字母：表明这是对象的构造方法</div><div><span style=\"white-space:pre\">\t</span>&nbsp; &nbsp; 回调函数：自定义/由其他途径执行的函数;</div><div>&nbsp; &nbsp; 创建对象</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //不推荐：直接创建：var o = {};</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //工厂不推荐：通过函数返回一个内存，但是本质都是Object类型</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 构造函数：var o = new O();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>1.new后立即划分新对象内存</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.将构造函数的this属性指向新对象</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.逐行执行构造函数</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.将新对象作为返回值返回</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 把公共数据放到对象的原型(公共区)里面</div><div>&nbsp; &nbsp; 遍历对象：for(var x in object){}</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 访问对象属性A：.a 或者 A[a]</div><div><span style=\"white-space:pre\">\t</span># 对象分类</div><div><span style=\"white-space:pre\">\t\t</span>1.内建对象(Function/Array)</div><div><span style=\"white-space:pre\">\t\t</span>2.宿主对象(由运行环境'浏览器'提供的对象)：DOM/BOM</div><div><span style=\"white-space:pre\">\t\t</span>3.自定义对象(Object衍生</div><div>***********************************************************************************</div><div>原型/构造链</div><div><span style=\"white-space:pre\">\t</span>公共Object</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 公共Object：.prototype = null</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 公共Object：.construct = 公共Function</div><div><span style=\"white-space:pre\">\t</span>A的公共(空)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; A的公共：.__proto__ = 公共Object</div><div>&nbsp; &nbsp; &nbsp; &nbsp; A的公共：.construct(本体是Function) = 内存A</div><div>&nbsp; &nbsp; 内存A</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 内存A：.prototype = A的公共(空)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 内存A：.construct = 公共Function</div><div>&nbsp; &nbsp; 实例a</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>实例a：.__proto__ = A的公共</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>实例a：.construct(继承) = 内存A</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>******************************</div><div>&nbsp; &nbsp; # hasOwnProperty(\"查找属性\")：查找自身是否有某属性</div><div>&nbsp; &nbsp; # 继承</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. AA.prototype = new A(); //容易修改父对象</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. AA(){&nbsp; A.call(this)&nbsp; };//复制了父对象，不会被修改，但是内存消耗大</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 结合两者：需要复用的地方放入A.prototype，其他的复制到AA上</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 注意aa.prototype.construct是A而不是AA，应该修改</div><div>***********************************************************************************</div><div>闭包产生</div><div><span style=\"white-space:pre\">\t</span>1.有嵌套的内部函数</div><div><span style=\"white-space:pre\">\t</span>2.内部函数调用了外部函数的变量</div><div><span style=\"white-space:pre\">\t</span>3.内部函数被外部变量引用</div><div><span style=\"white-space:pre\">\t</span>3.外部变量执行，即内部函数执行(闭包产生)</div><div><span style=\"white-space:pre\">\t</span># 闭包就是外部函数执行结束前，调用的变量集合</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 闭包不被销毁的根本原因是</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 外部变量没被销毁=内部函数没被销毁=外部函数没被销毁</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 外部变量是在内部函数预加载时被引用的 = 闭包产生</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 预加载的原因是因为内存执行</div><div>&nbsp; &nbsp; 闭包用途</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.匿名函数自调用,把相关数据暴露给window.模块名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.可以根据模块名直接使用相关数据</div><div>&nbsp; &nbsp; &nbsp; &nbsp; function foo() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>var x = 3;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function a(){return x++;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>return a;</div><div><span style=\"white-space:pre\">\t\t</span>}</div><div><span style=\"white-space:pre\">\t\t</span>var m = foo();</div><div><span style=\"white-space:pre\">\t\t</span># 全局引用foo(已经执行)/导致函数a不消失/导致变量x不消失</div><div>***********************************************************************************</div><div>函数防抖</div><div><span style=\"white-space:pre\">\t</span>短时间内连续触发事件，回调只能执行最后一次。</div><div><span style=\"white-space:pre\">\t</span>const debounce = (func, wait) =&gt; {</div><div><span style=\"white-space:pre\">\t\t</span>let timer;</div><div><span style=\"white-space:pre\">\t\t</span>return () =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clearTimeout(timer);//触发事件会先清空计时器,再重新启动</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timer = setTimeout(func, wait);};};//所以只有wait秒后才执行回调</div><div>函数节流</div><div><span style=\"white-space:pre\">\t</span>事件触发后,执行回调，一定时间后才能继续触发</div><div><span style=\"white-space:pre\">\t</span>const throttle = (func, wait) =&gt; {</div><div><span style=\"white-space:pre\">\t\t</span>let timer;</div><div><span style=\"white-space:pre\">\t\t</span>return () =&gt; {</div><div><span style=\"white-space:pre\">\t\t\t</span>if (timer) {return;}//连续触发事件判断计时器是否执行</div><div><span style=\"white-space:pre\">\t\t\t</span>timer = setTimeout(()=&gt;{</div><div><span style=\"white-space:pre\">\t\t\t\t</span>func();</div><div><span style=\"white-space:pre\">\t\t\t\t</span>timer = null;</div><div><span style=\"white-space:pre\">\t\t\t</span>}, wait);};};//wait秒后执行回调</div>"
    },
    "VHe__CRq-": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "VHe__CRq-",
      "name": "DOM-API",
      "content": "<div>基本常识</div><div><span style=\"white-space:pre\">\t</span>页面以结点Node为基本组成单位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; → 文档结点(document)：9&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; → 元素结点(标签)：1</div><div>&nbsp; &nbsp; &nbsp; &nbsp; → Attribute属性结点：2</div><div>&nbsp; &nbsp; &nbsp; &nbsp; → TextNode文字结点：3</div><div>&nbsp; &nbsp; document.element可以直接调用结点的基本属性</div><div>&nbsp; &nbsp; document.element.nodeName/nodeType/nodeValue:元素基本值</div><div>&nbsp; &nbsp; # innerHTML返回串中含标签/innerText不含标签</div><div>增加结点</div><div><span style=\"white-space:pre\">\t</span>createElement(\"\")</div><div><span style=\"white-space:pre\">\t</span>appendChild</div><div><span style=\"white-space:pre\">\t</span>insertBefore(新，旧)</div><div>&nbsp; &nbsp; 删除：e.parentNode.removeChild(e)：需要找出父元素</div><div>&nbsp; &nbsp; 修改：replaceChild</div><div>任意结点</div><div><span style=\"white-space:pre\">\t</span>getElementById()</div><div><span style=\"white-space:pre\">\t</span>getElementsByName/ClassName/TagName()：集合</div><div><span style=\"white-space:pre\">\t</span># 必须在document下进行查找(TagName除外)</div><div>&nbsp; &nbsp; querySelector(“css字符串”)：只会返回第一个符合结点</div><div>&nbsp; &nbsp; querySelectorAll(“css字符串”)：返回数组</div><div>&nbsp; &nbsp; 父节点：parentNode</div><div>&nbsp; &nbsp; 子结点：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; first/last/parentElementChild</div><div>&nbsp; &nbsp; &nbsp; &nbsp; previous/nextElementSibling</div><div>&nbsp; &nbsp; &nbsp; &nbsp; children：集合</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hasChildNodes()</div><div>&nbsp; &nbsp; # 以下查询有可能返回字符结点(如空白字符)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; first/last/parentChild</div><div>&nbsp; &nbsp; &nbsp; &nbsp; previous/nextSibling</div><div>&nbsp; &nbsp; &nbsp; &nbsp; childNodes</div><div>&nbsp; &nbsp;&nbsp;</div><div>***********************************************************************************</div><div>BOM</div><div>&nbsp; &nbsp; 1.window：窗口/网页全局对象</div><div>&nbsp; &nbsp; &nbsp; window.定时器&nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; setTimeout(expression,time)：单次延迟执行</div><div>&nbsp; &nbsp; &nbsp; &nbsp; setInterval(expression,time)：永续延迟执行</div><div>&nbsp; &nbsp; &nbsp; &nbsp; clearTimeout/Interval(name)：清除定时器</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 通过变量的返回数字来区分定时器</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 多次调用定时器函数=多个定时器同时在启动（所以在开启前关闭）</div>"
    },
    "rgW3oAy4y": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "rgW3oAy4y",
      "name": "DOM-事件",
      "content": "<div>***********************************************************************************</div><div>结点具有事件属性</div><div><span style=\"white-space:pre\">\t</span> # onclick / onscroll / onmouseover / onmousewheel(wheelDelta:滚动方向 )</div><div><span style=\"white-space:pre\">\t</span> # 可以为DOM事件设置监听函数</div><div><span style=\"white-space:pre\">\t</span> <span style=\"white-space:pre\">\t</span>1. e.click = function(event){}</div><div><span style=\"white-space:pre\">\t</span> <span style=\"white-space:pre\">\t</span>2. dom.addEventListener(\"click\",fun,是否在捕获阶段触发//0)</div><div><span style=\"white-space:pre\">\t</span> # 默认存在event参数保存所有事件信息，如：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. event.clientX/Y(鼠标可视坐标)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. event.pageX/Y(鼠标页面实际坐标)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. event.target = 触发事件的DOM结点</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>***********************************************************************************</div><div>事件冒泡</div><div><span style=\"white-space:pre\">\t</span>子元素的事件触发，也会导致所有祖先元素绑定的相同事件触发</div><div><span style=\"white-space:pre\">\t</span>取消：在子元素的事件对象中.cancelBubble = true;</div><div>事件委派：</div><div><span style=\"white-space:pre\">\t</span># 利用事件冒泡,只绑定一次监听函数</div><div>&nbsp; &nbsp; 1.在共同父元素上设置响应函数</div><div>&nbsp; &nbsp; - 由于子元素和父元素有共同的响应事件，所以不用循环为子元素绑定监听函数</div><div>&nbsp; &nbsp; 2.if(event.target.class==\"目标\"){监听函数}</div><div><br></div><div>// 样式</div><div><div>获取目前样式</div><div><span style=\"white-space:pre\">\t</span>1.</div><div><span style=\"white-space:pre\">\t\t</span>Window.getComputedStyle(node,null) : obj : 只读</div><div><span style=\"white-space:pre\">\t\t</span>e.currentStyle.样式//仅仅IE支持</div><div>&nbsp; &nbsp; 2.</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>实际宽高</div><div>&nbsp; &nbsp; &nbsp; &nbsp; e.clientWidth/Height（ content+padding ）</div><div>&nbsp; &nbsp; 3.</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>相对于视觉父元素的量</div><div>&nbsp; &nbsp; &nbsp; &nbsp; e.offsetParent：视觉父元素对象</div><div>&nbsp; &nbsp; &nbsp; &nbsp; e.offsetWidth/Height/Left/Top（ box ）</div><div>&nbsp; &nbsp; 4.</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>可滚动的实际宽高</div><div>&nbsp; &nbsp; &nbsp; &nbsp; scrollWidth/Height/Left/Top：获取滚动条滚动的距离</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span># scrollHeight-scrollTop=clientHeight：滚动到底了</div><div>批量修改样式</div><div><span style=\"white-space:pre\">\t</span>.style.cssText = {display:bolck;...}</div></div>"
    },
    "Ffk8nfvgC": {
      "blockId": "D2S51gJkH",
      "shelfId": "Ovrt1kT5d",
      "bookId": "Ffk8nfvgC",
      "name": "ES6",
      "content": "<div>0.箭头函数</div><div>&nbsp; &nbsp; var x = function(a1){ return a1();};</div><div>&nbsp; &nbsp; var x a1 =&gt; a1( //this);</div><div>&nbsp; &nbsp; 箭头函数中的this仅仅指向本级别</div><div>&nbsp; &nbsp; 1.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 用 var 声明的变量，在全局范围内有效</div><div>&nbsp; &nbsp; &nbsp; &nbsp; let 声明的变量</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 只在 let 命令所在的代码块内有效</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 不存在预处理:会产生报错</div><div>&nbsp; &nbsp; &nbsp; &nbsp; const 声明一个只读的常量，一旦声明，常量的值就不能改变。</div><div>&nbsp; &nbsp; 2.新增原始数据类型</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 表示独一无二的值，最大的用法是用来定义对象的唯一属性名。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; let sy = Symbol(\"objName\");</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 查询/创建:let sy = Symbol.for(\"objName\");</div><div>&nbsp; &nbsp; 3.新增数据结构</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Map</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - Set(唯一Key)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Object的key只能是string/symbols</div><div>&nbsp; &nbsp; 4.迭代器</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Symbol.iterator</div><div>&nbsp; &nbsp; 5.模块化</div><div>&nbsp; &nbsp; 6.Promise：表示一个异步操作</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span># 异步请求的数据进行return,可能会返回undefined,需要回调函数返回结果</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span># 异步回调函数需要顺序执行，这时候会造成回调地狱</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>解决：</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span>event : retutn&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new Promise(function(resolve,reject){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //0.Promise只要被创建就会立即执行</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let res = aFun();//1.立即执行异步操作-需要时间-此时执行then</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(res) return reject(err);//2.失败回调</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return resolve(res)<span style=\"white-space:pre\">\t</span>//2.成功回调</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span>event() //异步请求1开始</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t\t</span>.then(function(成功回调){</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t\t\t</span>return event();//异步请求2开始})//返回新Promise</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t\t</span>.then(function(成功回调){});</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t\t</span>.catch(异常捕获)//如果失败会终止回调队列进行报错</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span># 主线程快于异步操作: then先执行→创建回调内存→异步操作执行</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span># .then的第二个参数是失败回调-可以省略</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t\t</span># 在顺序异步时,可以在reject中返回Promise,防止整个.then顺序全部不执行</div>"
    },
    "KqmE746O6": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "bookId": "KqmE746O6",
      "name": "VUE",
      "content": "生命周期<div>&nbsp; &nbsp; beforeCreate =&gt; 初始化事件/生命周期</div><div><span style=\"white-space:pre\">\t\t</span>created&nbsp;</div><div><span style=\"white-space:pre\">\t\t\t</span>=&gt; 根据el:#app调用 vm.$mount(\"#app\")</div><div><span style=\"white-space:pre\">\t\t\t</span>=&gt; 根据template编译到 vm.render 中</div><div><span style=\"white-space:pre\">\t\t</span>beforeMount =&gt; vm.$el = DOM</div><div><span style=\"white-space:pre\">\t\t</span>mounted =&gt; beforeUpdate &lt;=&gt; update =&gt; vm.$destroy()</div><div><span style=\"white-space:pre\">\t\t</span>destroyed</div><div><br></div><div>VUE实例</div>"
    },
    "cvuzjh6fr": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "bookId": "cvuzjh6fr",
      "name": "Webpack",
      "content": "浏览器的限制<div>&nbsp; &nbsp; # 介绍</div><div>&nbsp; &nbsp; 目前的浏览器(内嵌渲染引擎/JS引擎)只支持 HTML/CSS/JavaScript 为基础的页面</div><div>&nbsp; &nbsp; - JS引擎有语法标准(ECMAScript)，而高级语法需要转译</div><div>&nbsp; &nbsp; * 模块化需求</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>原生HTML通过直接引用CSS/图片/JS代码形式无法适应大规模开发</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>于是通过模块化把一个复杂的系统分解到多个模块以方便编码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.CommonJS规范 - require同步加载/modules.exports暴露接口</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.AMD规范 - 需要第三方库requireJS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.ES6 / import/export 目前无法直接运行在大部分 JavaScript 运行环境下</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>目前的模块化方案都需要工具转译为 HTML/CSS/JavaScript</div><div>&nbsp; &nbsp; * 框架语法需要转译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; React JSX 语法需要转译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Vue 组件系统包含大量新语法 需要转译</div><div>&nbsp; &nbsp; * 新语言需要转译</div><div>&nbsp; &nbsp; <span style=\"white-space:pre\">\t</span>TypeScript/SCSS 无法直接执行</div><div><br></div><div>使用说明</div><div><br></div><div><div># 介绍</div><div>&nbsp; &nbsp; 不断出现的 模块化/新语言/新框架 需求</div><div>&nbsp; &nbsp; 我们需要构建工具，在编写完代码后生成能在线上运行的代码</div><div><br></div><div># 目标</div><div>&nbsp; &nbsp; 模块合并：通过构建功能一次HTTP请求完所有需要的图片/等资源(bundle.js)</div><div>&nbsp; &nbsp; 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</div><div>&nbsp; &nbsp; 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</div><div>&nbsp; &nbsp; 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</div><div>&nbsp; &nbsp; 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</div><div>&nbsp; &nbsp; 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</div><div>&nbsp; &nbsp; 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</div><div><br></div><div># /dist/index.html( &lt;= bundle script) # Step 3 后不需要</div><div># /src/index.js</div><div># webpack-config.js</div><div># package.json</div><div><span style=\"white-space:pre\">\t</span>\"start\": \"webpack-dev-server --open\"</div><div><span style=\"white-space:pre\">\t</span>\"build\": \"webpack\" 或 \"webpack --config webpack-config.js\"</div></div><div><br></div><div>webpack.config.js</div><div><br></div><div><div>const path = require(\"path\");</div><div>const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); # Step 3</div><div>const CleanWebpackPlugin = require(\"clean-webpack-plugin\"); # Step 4</div><div><br></div><div>module.exports = {</div><div>&nbsp; &nbsp; # Step 1 基础功能 ======================================================</div><div>&nbsp; &nbsp; # 补充</div><div>&nbsp; &nbsp; mode: \"development\", // * 打包模式</div><div>&nbsp; &nbsp; devtool: \"inline-source-map\", // * 错误定位</div><div>&nbsp; &nbsp; # 打包路径</div><div>&nbsp; &nbsp; entry: \"./src/index.js\",</div><div>&nbsp; &nbsp; output: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; filename: \"bundle.js\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; path: path.resolve(__dirname, \"dist\")</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # Step 5 服务器模式：能够重新进行build加载（刷新了页面）</div><div>&nbsp; &nbsp; devServer: {</div><div>&nbsp; &nbsp;&nbsp;<span style=\"white-space: pre;\">\t</span>contentBase: { \"./dist\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; port: 8080,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; hot: true, // * 局部刷新时需要开起</div><div>&nbsp; &nbsp; },</div><div>&nbsp; &nbsp; # 打包内容</div><div>&nbsp; &nbsp; module: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; rules: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Step 2 加载样式/图片 ==========================================</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的样式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 打包导入的图片</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - url-loader 依赖于 file-loader 用于图片优化/base64</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // - base64 &lt;= options.limit(bit) &lt;=&nbsp; Img // 8192bit = 1024b = 1kb</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.(png|svg|jpg|gif)$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"file-loader\" },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { loader: \"url-loader\", options: { limit: 8192 } }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><span style=\"white-space: pre;\">\t\t</span>]</div><div><span style=\"white-space: pre;\">\t</span>},</div><div>&nbsp; &nbsp; # 外部插件</div><div>&nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 3 自动生成 dist/Html 入口文件 ==================================</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new HtmlWebpackPlugin({</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: \"MyLib\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; template: \"./src/packTemplate.html\" // 导出的模板</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // favicon: \"path/to/yourfile.ico\" // Link图标</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # Step 4 打包前清空 dist 目录 =========================================</div><div>&nbsp; &nbsp; &nbsp; &nbsp; new CleanWebpackPlugin()</div><div>&nbsp; &nbsp; ]</div><div>};</div></div>"
    },
    "lkGMAIN6p": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "bookId": "lkGMAIN6p",
      "name": "Git",
      "content": "<div>1.在代码托管区创建远程仓库</div><div>&nbsp; &nbsp; - 局域网: GitLab</div><div>&nbsp; &nbsp; - 外网: Github/码云</div><div>&nbsp; &nbsp;&nbsp;</div><div>2.获取</div><div><span style=\"white-space:pre\">\t</span>- 创建本地仓库</div><div><span style=\"white-space:pre\">\t\t</span>$ git init</div><div><span style=\"white-space:pre\">\t</span>- 通过远程仓库提供的 URL 克隆代码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - HTTPS: 需要手动输入服务器账号密码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - SSH: 需要本地生成/服务器设置SSH keys</div><div><span style=\"white-space:pre\">\t\t</span>$ git clone [url]</div><div>&nbsp; &nbsp; - 查看这个项目对应的远程仓库</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git remote -v</div><div><span style=\"white-space:pre\">\t</span>- 获取最新代码</div><div><span style=\"white-space:pre\">\t\t</span>$ git pull</div><div><span style=\"white-space:pre\">\t\t</span>- git fetch: 获取远程代码</div><div><span style=\"white-space:pre\">\t\t</span>- git merge: 和本地库合并</div><div><span style=\"white-space:pre\">\t</span></div><div>3.本地更改</div><div><span style=\"white-space:pre\">\t</span>- 工作区 → 暂存区</div><div>&nbsp; &nbsp; $ git add readme.txt</div><div>&nbsp; &nbsp; - 暂存区 → 本地库</div><div>&nbsp; &nbsp; $ git commit -m \"description\"</div><div>&nbsp; &nbsp;&nbsp;</div><div>4.查看本地版本</div><div><span style=\"white-space:pre\">\t</span>- 查看工作区及暂存区的状态</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git status</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on branch master</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no commits yet</div><div><span style=\"white-space:pre\">\t</span>- 想知道历史提交 /空格翻页/b向上/q退出</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git log -pretty=oneline 或 git reflog // 获取索引值</div><div>&nbsp; &nbsp; - 本地回退版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 通过对 HEAD 指针来决定本地版本</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reflog // 获取索引值</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git reset --hard 'key' // 设置 HEAD 指针</div><div>&nbsp; &nbsp; - 比较</div><div>&nbsp; &nbsp; &nbsp; &nbsp; git 以ROW为比较单位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git diff [(或)文件名/版本] // 查看明细</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>==========================================================================</div><div>&nbsp; &nbsp; 生成本地 SSH keys 用于提供远程仓库访问权限</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1.生成本地SSH目录</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ ssh-keygen -t rsa -C '邮箱/账号'</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2.查看生成的SSH keys</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ cat id_rsa.pub</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3.在托管服务器上设置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 添加 SSH keys&nbsp;</div><div>==========================================================================</div><div><span style=\"white-space:pre\">\t</span># 外包</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ git fork 关联复制</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ pull request 分支发起请求</div><div>&nbsp; &nbsp; &nbsp; &nbsp; $ merge 同意请求并合并</div><div>==========================================================================</div><div>&nbsp; &nbsp; 配置签名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 提交时用于标识开发人员身份/与服务器账号密码无关</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 项目级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.name</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config user.email</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 系统级别</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.name \"Your Name\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ git config --global user.email \"email@example.com\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; - 这些信息会保存到 .git/config 中</div>"
    },
    "O8aVEB4yB": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "bookId": "O8aVEB4yB",
      "name": "Node-NPM",
      "content": "NPM<div>&nbsp; &nbsp; 淘宝镜像</div><div><span style=\"white-space: pre;\">\t</span>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div><br></div><div>初始化包管理文件</div><div><span style=\"white-space: pre;\">\t</span>$ npm init -y // 产生 package.json</div><div><span style=\"white-space: pre;\">\t</span></div><div>搜索模块</div><div><span style=\"white-space: pre;\">\t</span>$ npm search</div><div><span style=\"white-space: pre;\">\t</span></div><div>安装</div><div><span style=\"white-space: pre;\">\t</span>$ npm install moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -g moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到全局，不会在项目node_modules目录中保存模块包。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 不会将模块依赖写入devDependencies或dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时不会下载模块。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入dependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; $ npm install -save-dev moduleName 命令</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1. 安装模块到项目node_modules目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2. 会将模块依赖写入devDependencies 节点。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4. 运行npm install --production</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>删除包</div><div><span style=\"white-space: pre;\">\t</span>$ npm uninstall/remove name</div><div><span style=\"white-space: pre;\">\t</span></div><div>当导入一个包时：require('vue')</div><div>&nbsp; &nbsp; 1.找到对应的 node_modules</div><div>&nbsp; &nbsp; 2.找到require的包文件夹</div><div>&nbsp; &nbsp; 3.根据package.json找到需要的JS库文件</div>"
    },
    "h_VQcYYGJ": {
      "blockId": "D2S51gJkH",
      "shelfId": "UKfQP2D2P",
      "bookId": "h_VQcYYGJ",
      "name": "VS Code",
      "content": "<div>prettier.config.js<br></div><div>{</div><div>&nbsp; &nbsp; // ***************** 必备 *****************</div><div>&nbsp; &nbsp; // 自动格式化</div><div>&nbsp; &nbsp; \"editor.formatOnSave\": true,</div><div><br></div><div>&nbsp; &nbsp; // Tab缩进为4个空格</div><div>&nbsp; &nbsp; \"prettier.tabWidth\": 4,</div><div><br></div><div>&nbsp; &nbsp; // 统一使用单引号</div><div>&nbsp; &nbsp; \"prettier.singleQuote\": true,</div><div><br></div><div>&nbsp; &nbsp; // ***************** 其他 *****************</div><div>&nbsp; &nbsp; // 是否自动添加分号</div><div>&nbsp; &nbsp; \"prettier.semi\": false,</div><div><br></div><div>&nbsp; &nbsp; // { / }两侧必须有空格</div><div>&nbsp; &nbsp; \"prettier.bracketSpacing\": true,</div><div><br></div><div>&nbsp; &nbsp; // 单参数箭头函数 总是带()</div><div>&nbsp; &nbsp; \"prettier.arrowParens\": \"always\",</div><div><br></div><div>&nbsp; &nbsp; // vue 模板/样式的缩进</div><div>&nbsp; &nbsp; \"prettier.vueIndentScriptAndStyle\": true</div><div>}</div><div><br></div>"
    }
  }
}