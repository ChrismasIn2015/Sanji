# Html

```
# HTTP传输原理
	一台计算机希望通过HTTP发送数据
        - 浏览器解析域名 → 封装出HTTP请求包 (主机名/端口...)
        - TCP建立连接 : 封装TCP请求包，根据IP规则传输请求包
        - 浏览器发送HTTP正文
        - 服务器接受返回HTTP正文
        - 服务器关闭TCP连接
    HTTP正报文
    	状态行 : POST /URL HTTP/1.1 (方法 地址 协议)
    	请求/响应头
            Host: localhost（...数据规则...）
            Content-Type：(MIME:信息类型)
            	表单 : application/x-www-form-urlencoded 
            	二进制 : multipart/form-data
            	文本 : text/html; charset=utf-8
        请求/响应正文 (封装进Request)
            username=aa&password=1234 (正文)
***********************************************************************************
浏览器渲染过程
    1.用HTML分析器，分析HTML元素，构建一颗DOM树
    	- onload函数触发
    2.用CSS分析器，分析CSS文件和元素样式，生成页面的样式表。
    3.将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。
        每个DOM节点都有attach方法，接受样式信息，返回一个render对象。
        这些render对象最终会被构建成一颗Render树。
    4.有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。
    5.Render树和节点显示坐标都有了，就调用每个节点paint方法，把它们绘制出来。 
    # 构建DOM数是一个渐进过程，为达到更好用户体验，渲染引擎会尽快将内容显示在屏幕上。
    # 它不必等到整个HTML文档解析完毕之后才开始构建render数和布局。
***********************************************************************************
	rel : 关系 : icon/stylesheet
	href : 连接 : #顶部/#id/javascript/url
	
    网页图标 : <link rel="icon" src="logo.png" sizes="32x32">
    图片连接 : <a href><img src="URL" alt="替换文本"></a>
    文字区域 : <textarea> disabled="disabled"禁止拖动

    表单 : <form action="url" method="post">
        样式
            表单长度 : size
            底部文字 : placeholder
            内容长度 : maxlength
            内容选取 : name/value
        (type)
            内容text/复选checkbox/单选radio
            重置reset/下拉select+option
```

# CSS

### 通用

```
1.优先级
	行内> #ID选择器 > .类+伪类选择器/属性选择器 > 元素选择器 > *通用 > 继承
2.选择器语法
	多选择器：A，B，C
    a -/+/~ b : 前/后/后所有
	A > a(仅仅子)
3.伪类
    A[属性=值]
    :link 未访问
    :active 长按
    :visited 已访问
    :focus 文本框输入时
    :selection 文本鼠标选中时候
    :before/after 文字前/后&标签之间
    content："" 添加内容
4.参数
    p:first-child
    p:nth-child(num):任意位置子元素
    p:first-of-type:第一个p
	非选择器not(选择器)
*********************************************************************
基本样式
	内联元素 : 宽高无效
背景属性
	图像：background-image:url(../img/a.jpg):会自动XY充填铺满
	充填：background-repeat:是否自动充填
		repeat-x/y
		no repeat
	位置：background-position
	铺满屏幕：background-size:cover/num%
	固定背景：background-attachment: fixed;

display:inline-block
	水平对齐 : vertical-align:top;
	产生的空白可以在父元素中使用font-size:0解决

Overflow
	visible	默认值。内容不会被修剪，会呈现在元素框之外。
    hidden	内容会被修剪，并且其余内容是不可见的。
    scroll	内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。
    auto	如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。
    
背景透明：
	opacity：0~1：所有
	rgba(x,y,z,0~1)：单独
```

### 通用 - JavaScript

```
获取目前样式
	1.
		Window.getComputedStyle(node,null) : obj : 只读
		e.currentStyle.样式//仅仅IE支持
    2.
    	实际宽高
        e.clientWidth/Height（ content+padding ）
    3.
    	相对于视觉父元素的量
        e.offsetParent：视觉父元素对象
        e.offsetWidth/Height/Left/Top（ box ）
    4.
    	可滚动的实际宽高
        scrollWidth/Height/Left/Top：获取滚动条滚动的距离
    	# scrollHeight-scrollTop=clientHeight：滚动到底了
批量修改样式
	.style.cssText = {display:bolck;...}
```

### 动画

```
-transform-
    平移：transform: translate(X,Y)
    旋转：transform-origin:x y：旋转基点
          transform: rotate(30deg)
    放缩：transform: scale(X,Y);//倍数
    3D旋转：transform: rotateX/Y(120deg);
*********************************************************************
-transition-
    1.为指定属性(时长)添加过渡效果：transition: width 2s,height 1s...
    2.指定属性绑定事件监听：div：hover{width...height...}
    # transition: all 1s + css组合
*********************************************************************
复杂
    1.animation:name 1s 时间函数 开始时间 次数();
    	ease:慢快慢/linear:匀速
    2.@keyframes name
        {0%   {background:red;}
        25%  {background:yellow;}
        50%  {background:blue;}
        100% {background:green;}}
支持
	-webkit- Chrome:IOS/-moz- firefox/
```

### 布局

```
定位
    1 文档流：
    	relative：相对于原位置移动
    2 脱离文档流：
    	float：会产生挤压
    	fixed：相对于可视界面移动,会提升层级
    	absolute：相对relative移动,会提升层级
            脱离文档流而产生的高度塌陷 & 相邻|垂直|内外边距重叠
            可以通过添加块元素解决,清除因浮动产生的移动影响
            .clearfix:before,.clearfix:after
            {content:"";display:table;clear:both;}
    3 水平对齐
        margin:0 auto
        (行内)text-align:center
        (弹性盒)display: flex;justify-content: center;
    4 垂直对齐
        (单行内)line-height
        (多行)display:table-cell;vertical-align: middle;
        (弹性盒)display: flex; align-items: center;
    5 同时对齐
        ab+re定位：trbl:0; margin:auto;
        top/left：50%; transform(-50%,-50%)/margin-l/r:-50%;
        (弹性盒)display: flex; justify-content: center; align-items: center;
        (弹性盒)display: flex; margin:auto;
*********************************************************************
弹性盒子
    外部:display: flex/inline-flex;
        1.排序: flex-direction
        	row | row-reverse | column | column-reverse
        2.换行: flex-wrap
        	nowrap | wrap | wrap-reverse | initial | inherit
        # 分布方式
            justify-content : 水平
            align-items : 垂直
            flex-start | flex-end | center | space-between | space-around
    内部
    	1.order:int (数值小的会排列在前)
    	2.margin:auto: 会获取剩余所有空白:所以导致了完全居中
        3.align-self : 单独的垂直定位
        	auto | flex-start | flex-end | center | baseline | stretch
        4.flex:num:单独宽度占比
*********************************************************************
移动端适配 
# 响应式布局: 主要以@media为不同设备设计不同样式
# 自适应布局: 以比例布局为主
	1.定义默认宽度
        # 所有浏览器都有默认宽度,但是每个设备宽度都不一样
        # 所以用这个meta定义了浏览器宽度 = 设备宽度
        <meta name='viewport' content=
            'width=device-width, initial-scale=1.0'>
*********************************************************************
	百分比布局
    	- 为不同设备编写不同的CSS样式文件
    	- 在头部 <link @media='screen/speech'/(min-width:500px)(if)..>
    	- 这样根据不同的条件 相关的样式就会加载/覆盖
    	- 宽度默认 100%; - 但是字体可能会模糊
    	@import 'common/mobile/pc.css'
*********************************************************************
rem布局
	# 像素设备比 -DPR -表示1个css像素对应（覆盖）的物理像素个数
	# HTML 默认font-size:16px / 下面动态设置HTML字体
    (function(doc, win) {
    	let html = doc.getElementsByTagName("html")[0],
        // orientationchange-> 手机屏幕转屏
        // resize -> 页面大小被缩放了
    	window.reEvt = "orientationchange" in win ? "orientationchange" : "resize",
        let reFontSize = function() {
            var clientW = doc.documentElement.clientWidth || doc.body.clientWidth;
            if(!clientW) {return;}
    		html.style.fontSize = 100 * (clientW / 375) + "px";}
        win.addEventListener(reEvt, reFontSize);
        // DOMContentLoaded->dom加载完就执行,onload要dom/css/js都加载完才执行
        doc.addEventListener("DOMContentLoaded", reFontSize);
    })(document, window);
```

# JavaScript

## 加载过程

```
JS执行过程
	1.语法检查
	2.预编译
		1.进入全局/函数环境，创建相应的执行上下文，形成执行上下文优先加载栈
		2.创建执行上下文
            变量提升 (undefined)
            建立作用域链 : 可以访问/查找父级内存
            确定this的指向
    3.代码执行:按顺序(单线程)变量赋值/函数执行
		1.主线程执行(耗时任务放入回调队列:异步非阻塞)
		2.辅助线程初始化(相关回调代码放入回调队列)
		- 如初始化定时器，绑定监听动作，发送AJAX
		3.主线程执行完毕，查看是否有需要执行的回调代码再进入主线程(循环队列)
```

## 数据类型

```
1.数据结构
        基本数据(值)类型：本质是内存代表的值保存在栈中
            1.undefined : undefined，代表未赋值的变量(var a)默认指向唯一实例
            2.Number
            3.String
            4.Boolean
            5.null
        对象数据(引用)类型：本质是内存
        	 1.Object
			2.Function(可以执行的object)
               Array(有序的有下标的object)
                   	创建：new Array(num);[num];
                    添加：arr[arr.length]=value; //动态添加数组元素
                    遍历：arr.forEach(function(e,i,arr){});
                    # 浏览器默认在回调函数中传递三个函数
                    （1.元素，2.索引下标，3.正在遍历的数组对象）
                    查找:indexOf/match
# typeof a
	返回a的所属具体对象字符串，如具体构造函数名:String)
	无法判断null:obj(语言bug)和Array:obj
# a instanceof Obj
	返回a是否是B构造函数的实例：判断对象
***********************************************************************************
# 强制数据类型转换
	我想要字符串
		1.调用被转换数据类型的toString():返回新字符串，12报错
		2.调用静态方法String(ins)：返回新字符串，无报错
	我想要数字
		1.parseInt/Float()：(先转换成字符串)从头逐字符取出有效数字并返回数字
		2.调用静态方法Number()：返回新数字，无报错
		# 非数字：NaN/空格：0
	截取字符串：substring(下标，个数:无则是全部)
	执行字符串：eval(str)
```

## 创建对象

```
声明：function name(){}
    # 赋值：button.onclick/var x = function(){};
    # 直接return;等于直接退出函数
    # 立即调用匿名函数(function(){})();//目的是为了隐藏实现
    - arguments伪数组来保存参数
    - arguments.callee来保存当前执行的函数对象
创建对象
	声明对象
        通过大写函数首字母：表明这是对象的构造方法
	    回调函数：自定义/由其他途径执行的函数;
    创建对象
        //不推荐：直接创建：var o = {};
        //工厂不推荐：通过函数返回一个内存，但是本质都是Object类型
        构造函数：var o = new O();
        	1.new后立即划分新对象内存
            2.将构造函数的this属性指向新对象
            3.逐行执行构造函数
            4.将新对象作为返回值返回
        把公共数据放到对象的原型(公共区)里面
    遍历对象：for(var x in object){}
        访问对象属性A：.a 或者 A[a]
	# 对象分类
		1.内建对象(Function/Array)
		2.宿主对象(由运行环境'浏览器'提供的对象)：DOM/BOM
		3.自定义对象(Object衍生
***********************************************************************************
原型/构造链
	公共Object
        公共Object：.prototype = null
        公共Object：.construct = 公共Function
	A的公共(空)
        A的公共：.__proto__ = 公共Object
        A的公共：.construct(本体是Function) = 内存A
    内存A
        内存A：.prototype = A的公共(空)
        内存A：.construct = 公共Function
    实例a
    	实例a：.__proto__ = A的公共
    	实例a：.construct(继承) = 内存A
    	******************************
    # hasOwnProperty("查找属性")：查找自身是否有某属性
    # 继承
        1. AA.prototype = new A(); //容易修改父对象
        2. AA(){  A.call(this)  };//复制了父对象，不会被修改，但是内存消耗大
        3. 结合两者：需要复用的地方放入A.prototype，其他的复制到AA上
        # 注意aa.prototype.construct是A而不是AA，应该修改
***********************************************************************************
闭包产生
	1.有嵌套的内部函数
	2.内部函数调用了外部函数的变量
	3.内部函数被外部变量引用
	3.外部变量执行，即内部函数执行(闭包产生)
	# 闭包就是外部函数执行结束前，调用的变量集合
        - 闭包不被销毁的根本原因是
            外部变量没被销毁=内部函数没被销毁=外部函数没被销毁
        - 外部变量是在内部函数预加载时被引用的 = 闭包产生
        - 预加载的原因是因为内存执行
    闭包用途
        1.匿名函数自调用,把相关数据暴露给window.模块名
        2.可以根据模块名直接使用相关数据
        function foo() {
        	var x = 3;
            function a(){return x++;}
        	return a;
		}
		var m = foo();
		# 全局引用foo(已经执行)/导致函数a不消失/导致变量x不消失
***********************************************************************************
函数防抖
	短时间内连续触发事件，回调只能执行最后一次。
	const debounce = (func, wait) => {
		let timer;
		return () => {
            clearTimeout(timer);//触发事件会先清空计时器,再重新启动
            timer = setTimeout(func, wait);};};//所以只有wait秒后才执行回调
函数节流
	事件触发后,执行回调，一定时间后才能继续触发
	const throttle = (func, wait) => {
		let timer;
		return () => {
			if (timer) {return;}//连续触发事件判断计时器是否执行
			timer = setTimeout(()=>{
				func();
				timer = null;
			}, wait);};};//wait秒后执行回调
```

### JSON

```
JSON    
    JS对象无法被其他语言识别
    JSON是一种特殊的字符串，可以被任意语言识别
    
    # JS为我们提供了工具类JSON来操作服务器传回的JSON字符串
        1.获取JS对象
            JSON.parse(s)：object
        2.转换为字符串给服务器
            JSON.stringify(obj)：string

```

## DOM - JavaScript 

```
基本常识
	页面以结点Node为基本组成单位
        → 文档结点(document)：9 
        → 元素结点(标签)：1
        → Attribute属性结点：2
        → TextNode文字结点：3
    document.element可以直接调用结点的基本属性
    document.element.nodeName/nodeType/nodeValue:元素基本值
    # innerHTML返回串中含标签/innerText不含标签
增加结点
	createElement("")
	appendChild
	insertBefore(新，旧)
    删除：e.parentNode.removeChild(e)：需要找出父元素
    修改：replaceChild
任意结点
	getElementById()
	getElementsByName/ClassName/TagName()：集合
	# 必须在document下进行查找(TagName除外)
    querySelector(“css字符串”)：只会返回第一个符合结点
    querySelectorAll(“css字符串”)：返回数组
    父节点：parentNode
    子结点：
        first/last/parentElementChild
        previous/nextElementSibling
        children：集合
        hasChildNodes()
    # 以下查询有可能返回字符结点(如空白字符)
        first/last/parentChild
        previous/nextSibling
        childNodes
***********************************************************************************
DOM结点具有事件属性
	点击：onclick
	滚动条滚动事件：onscroll
	鼠标：onmouseover
	滚轮：onmousewheel(wheelDelta:滚动方向 )
***********************************************************************************
1.js可以为DOM事件设置监听函数
	方法1：
		e.click = function(event){}
	方法2：
		# 可以绑定多个事件
		dom.addEventListener("click",fun,是否在捕获阶段触发//0)
		IE8:从后到前触发事件
		dom.attachEvent("onclick",fun,是否在捕获阶段触发//0)
    # 默认存在event参数保存所有事件信息，如：
        1：event.clientX/Y(鼠标可视坐标)
        2：event.pageX/Y(鼠标页面实际坐标)  
    # event.target = 触发事件的DOM结点
    # ie8不传事件对象，而是保存在全局变量(window.event)
***********************************************************************************
2.事件冒泡
	子元素的事件触发，也会导致所有祖先元素绑定的相同事件触发
	取消：在子元素的事件对象中.cancelBubble = true;
***********************************************************************************
3.事件委派：
	# 利用事件冒泡,只绑定一次监听函数
    1.在共同父元素上设置响应函数
    - 由于子元素和父元素有共同的响应事件，所以不用循环为子元素绑定监听函数
    2.if(event.target.class=="目标"){监听函数}
***********************************************************************************
BOM
    1.window：窗口/网页全局对象
      window.定时器    
        setTimeout(expression,time)：单次延迟执行
        setInterval(expression,time)：永续延迟执行
        clearTimeout/Interval(name)：清除定时器
        # 通过变量的返回数字来区分定时器
        # 多次调用定时器函数=多个定时器同时在启动（所以在开启前关闭）
```

# ES6

```
0.箭头函数
    var x = function(a1){ return a1();};
    var x a1 => a1( //this);
    箭头函数中的this仅仅指向本级别
    1.
        用 var 声明的变量，在全局范围内有效
        let 声明的变量
            - 只在 let 命令所在的代码块内有效
            - 不存在预处理:会产生报错
        const 声明一个只读的常量，一旦声明，常量的值就不能改变。
    2.新增原始数据类型
        # 表示独一无二的值，最大的用法是用来定义对象的唯一属性名。
        let sy = Symbol("objName");
        查询/创建:let sy = Symbol.for("objName");
    3.新增数据结构
        - Map
        - Set(唯一Key)
        # Object的key只能是string/symbols
    4.迭代器
        Symbol.iterator
    5.模块化
    6.Promise：表示一个异步操作
    	# 异步请求的数据进行return,可能会返回undefined,需要回调函数返回结果
    	# 异步回调函数需要顺序执行，这时候会造成回调地狱
    	解决：
    		event : retutn 
                new Promise(function(resolve,reject){
                    //0.Promise只要被创建就会立即执行
                    let res = aFun();//1.立即执行异步操作-需要时间-此时执行then
                    if(res) return reject(err);//2.失败回调
                    return resolve(res)	//2.成功回调
                })
    		event() //异步请求1开始
    			.then(function(成功回调){
    				return event();//异步请求2开始})//返回新Promise
    			.then(function(成功回调){});
    			.catch(异常捕获)//如果失败会终止回调队列进行报错
    		# 主线程快于异步操作: then先执行→创建回调内存→异步操作执行
    		# .then的第二个参数是失败回调-可以省略
    		# 在顺序异步时,可以在reject中返回Promise,防止整个.then顺序全部不执行
```

# Node.js

## NPM - 安装框架

```
常用命令
0.npm search：联网搜索
1.初始化目标包目录:	nmp init -y
2.安装: npm i/nstall name：
    - g 全局:将安装包放在 /usr/local 下或者你 node 的安装目录/可以直接在命令行里使用。
    - d/空 本地:将安装包放在 ./node_modules 下
    - s 更新到package.json
3.当导入一个Vue包时：require('vue')
        1.找到项目文件夹的: node_modules
        2.找到Vue文件夹
        3.找到需要的库	
        	package.json -"main" : "?/vue.js"
4.删除包: npm /uninstall/r/emove name
    package.json : 描述文件（必须）
    	- 全局命令	"scripts"键
    	- 项目依赖	"dependencies"键
```

## Webpack - 打包获得项目

```
# JS模块化
	Node语法:	commonJS/module.exports/require
	ES6语法: exports/require(异步模块加载)
	Babel库: 转译高级JS语法/浏览器能识别的JS语法
# 依赖管理/代码合并
	通常和 Babel库 配合使用
	在唯一入口中,引入各种(资源),打包,输出最简化的项目Dist
      # webpack 无法打包其他类型的文件/需要第三方loader
      		webpack.config.json
      		安装对应npm包(css-loader等等)
      		,module:{rules:['test':/\.css$/,use:['css-loader']]}
***********************************************************************************
使用步骤
	1.安装webpack库 : npm i -g webpack
	2.创建项目 project
		webpack.congig.js : webpack配置文件
		dist : 最终产品
		src 服务Index.html
			- main.js (webpack入口文件)
			- index.html (加载mainJS就等于加载了所有资源)
***********************************************************************************
    导入Ⅰ：
        物理引用<srcipt src='../dist/bundle.js'> 
        方法1. webpack './src/main.js' './dist/bundle.js' 
        方法2. 设置webpack.congig.js
            const path = require('path')
            module.export = { 
            entry: path.join(__dirname,'./src/main.js'),
            output: {
            path.join(__dirname,'./dist),
            filename: 'bundle.js'}}
***********************************************************************************
	导入Ⅱ：
		引用内存中的资源文件<srcipt src='bundle.js'> 
    	# 需要webpack-dev-serve(npm -d)
    	1.改变输出方式
            # 方法一(修改package.json/npm)
                ,'scripts':{
                'dev':'webpack-dev-server contentBase src ---port 8080'}
            # 方法二(修改webpack.config.json)
                //也需要全局添加命令'dev':'webpack-dev-server'
                ,devServe:{
                open:true, (是否自动打开浏览器)
                port:8080,
                contentBase:'src', (指mainJS需要的资源都在这)}
    	2.使用serve库进行打包	npm run dev (运行新打包方式webpack-dev-server)
    	3.每次src保存 → 打包出新bundle内存
***********************************************************************************
	导入Ⅲ：热更新
         	# 根据模板动态生成HTML文件
         	# 需要html-webpack-plugin(npm -d)	插件
         	1.先进行webpack-dev-serve(npm -d)配置:bundle.js内存
         	2.修改webpack.config.json
         		const htmlWebpackPlugins = require('html-webpack-plugin')
         		,plugins:[
         			new htmlWebpackPlugins({
         				template: path.join(__dirname,'./src/index.html'),
         				filename: 'index.html'})]
         	3.页面不需要引用标签文件/自动加载bundle内存
***********************************************************************************
      4.创建运行环境(Dist目录)
      	测试: npm run dev
      	打包: npm run build
```

## Vue-cli

```
安装 Node.exe
全局安装
	vue i @vue/cli -g
	依赖 @vue/cli-service 进行配置/拓展
传统生成项目
	1.vue create name
	2.public/index.html 文件是一个会被 html-webpack-plugin 处理的模板
	
	# 调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象：
	// vue.config.js
    module.exports = {
      configureWebpack: {
        plugins: [
          new MyAwesomeWebpackPlugin()]}}
项目本地测试
	npm run serve (vue-cli-service serve)
	命令会启动一个开发服务器 (基于 webpack-dev-server) 
	可以使用 vue.config.js 里的 devServer 字段配置开发服务器。
项目打包
	npm run serve (vue-cli-service build)
	会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，
```

# Vue

```
主要优点
	- 响应式数据绑定
	- 组件化开发
***********************************************************************************
传统MVC开发模式
	后台 M：model：含数据的CRUD操作：根据输入返回数据
	后台 C：controller：负责业务逻辑，根据输入调用M给予输出
	前端 V：view：负责视图的操作：根据输入变换视图
		# Vue使用了MVVM开发模式
		M：单纯的数据
		V：图形化代码：HTML
		VM：分割了M和V，Vue通过VM组合不同的M和V，提供了双向绑定
		# VM 就是视图和数据的控制台，能自动更新DOM
```

## 基础

```
    data: {msg...},
    methods: {fun},
    computed: {fun对}: 计算属性(本质是返回复杂return会产生复用缓存),
    watch: { "data.msg":fun } : 监听data，路由$route.path...
***********************************************************************************
    v-bind/:class="i"/{style:boolean}
    v-on/@click.prevent="fun"
        //阻止(点击a刷新页面)默认行为.prevent//阻止冒泡.stop
    v-if/v-show="i(boolean)"
    v-model="i"(双向数据绑定)
***********************************************************************************
    v-for="i in data/methods/整数"
    v-for="(value,index) in item/数组"
    v-for="(value,key,index) in item/对象"
	# 使用:key="a.id" 保证数据唯一性
	
# 在vm实例中想获取data/methods等其他模块必须通过this.a/$data.a来进行访问
# 可以通过vm.$refs.name获取DOM元素(绑定了ref属性),也可以获得其中的数据/方法
***********************************************************************************
v-model 自动更新原理
	# 工具: 为target对象设置访问器对象属性(里面保存了仅访问器使用的数据)
		Object.defineProperty(target, name, {get:fun,set(val):fun})
		# 赋值 target.name="" 就是调用set方法(赋的值是参数)
		# get/set的this指向target对象
	# 工具: 劫持DOM
		DocumentFragment.append(dom)
		当DOM.appendChild(DocumentFragment)时,会删除原来的DOM
		我们只需要获取含有'v-model'的结点就可以了
	2.初始化
		- 创建Vue对象,初始化VM.data
			# 为VM设置访问器/将data设置为访问器属性
		- 遍历DOM,遍历出所有v-model子节点,进行劫持返回新DOM
		- v-model子节点.value = VM.data(触发了访问器get方法)
	3.视图更新(事件触发)-data更新
		- 遍历DOM,遍历出所有v-model子节点,进行劫持返回新DOM
		# 劫持时绑定事件
		# 触发事件：VM.data = v-model子节点.value(触发了访问器set方法)
			- set方法 1.更新data 2.作为发布者通知更新
	4.发布者通知更新
		- 遍历DOM,遍历出所有v-model子节点,进行劫持返回新DOM
		# 劫持时初始化一个订阅者对象
			- 在构造方法中从VM.data获取数据(触发了访问器get方法)
			- 在构造方法中有更新方法通过.nodeValue更新视图
			# 触发get方法时把这个订阅者放入订阅者队列
			# 触发set方法时触发订阅者队列中所有订阅者的更新方法
```

## 组件 - component

```
VM生命周期
        1.创建一个Vue实例
        2.初始化一个空对象/默认事件/函数 
    → beforeCreate 启动
        3.初始化我们的data/methods
    → created 启动
        4.开始编译模板<template>放到内存中(虚拟DOM)
    → beforeMount 启动
        5.把内存中编译好的模板<template>中(虚拟DOM)替换到浏览器中(需要el:'#id')
    → mounted 页面渲染完毕
    → beforeUpdate 启动
        6.数据更新:页面根据data已经进行了变换(不一定要v-model)
    → update 启动
    → destory 启动
***********************************************************************************
VUE虚拟DOM
    原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。
    用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，
    操作内存中的JS对象的速度显然要更快，
    等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。
***********************************************************************************
1.创建模板
	<template id="#"><div>只能有一个根结点</div></template>
2.新建组件对象
	# var name = {template:"#id"}
	# export default {}
3.注册组件
    全局: Vue.component("nameX",name)
	局部: import name/component:{ "nameX":name, ...}
4.使用组件
	<name-X></name-X>
***********************************************************************************
# 使用父组件数据
    子组件对象中添加 props:["中间变量"]
    实际<name-x v-bind:中间变量=父数据>
# 使用子组件数据
	1.父组件直接使用 this.$refs.name.fun/data + 实际<name-x ref='name'>
	2.子组件改变父组件数据
        <template v-on:click="子方法">
        methods:{子方法:function(){this.$emit("中间变量"，参数1...);}}
        实际<name-x v-on:"中间变量"=父方法>
# 兄弟组件：创建一个新Vue的实例，让各个兄弟共用同一个事件机制
	创建空模板：export default new Vue()
    接收数据:
    	import emptyVue
    	mounted(){//数据渲染完毕
            emptyVue.$on("中间变量",(参数)=>{回调})}//注册事件
	发送数据：
    	import emptyVue
        <template v-on:click="子方法">
        methods:{子方法:function(){emptyVue.$emit("中间变量"，参数...);}}//触发事件
```

## 函数组件 - render

```
# 通常使用HTML语言来创建模板语法
# 函数式模板-render函数通过传入函数,返回一个createElement函数的调用结果,创建虚拟DOM
var vm = new Vue({
    el:"#app",
    render:function(cE){
    	return cE('tag',tag属性集合{ class:..,style:..,});
    }
    # 返回一个虚拟DOM树替换VM
    # 简写:render: c => c(...);
});
```

## 路由 - router

```
# 路由能根据路径的不同而在VM机中展示不同的组件
1.导入 
	npm i vue-router
2.创建路由对象
	Vue.use(VueRouter);
	var rou = new VueRouter({
		routes:[
			规则1	{
				path:'/'',redirect:"/index",component:组件,
				children:[{path:'a1', component:目标组件}, ...]},
				# children会被渲染到/index的router-view中
			规则2	{path:'/', component:?},
			规则3	{path:'/', component:?}]})
3.APP注册: router:路由对象,
4.使用路由
	JS访问: 
		<router-link :to="{ name:'user', params:{userId: 123} }">
		this.$router.push({ name:'user', params:{userId: 123} });
	获得参数: 
		this.$router.query.id/name
		this.$router.params.id/name
		this.$route.params.name //当前路由
***********************************************************************************
```

## 状态管理 - vuex

```
公共数据管理 
1.创建仓库
	Vue.use(Vuex);
	const store = new Vuex.Store({
      state: {name:...},//数据库
      getters: { nameDel : state=>{}}//计算属性
      mutations: {//同步方法库
      	nameAdd(state,其他参数){},...}
      }),\
2.使用仓库
	导入 import store.js
	根组件注册 store:store,
	子组件访问数据: this.$store.state.name //一般在组件computed中访问store
	更改数据: store.commit('nameAdd')
3.异步方法库
	注册 actions:{ nameSet({ commit }){commit('nameAdd')},... }//可以是异步方法
	使用 store.dispatch('nameSet')//因为异步所以可以批量分发
4.多个仓库管理
	const store = new Vuex.Store({
		modules:{
			storeA,....}})
```

# 工作工具

```
git
	1.exe安装
Github Pages
	1.在 vue.config.js 中设置正确的 publicPath
        如果打算将项目部署到 https://<USERNAME>.github.io/ 上 , 
        publicPath 将默认被设为 "/"，你可以忽略这个参数。

        如果打算将项目部署到 https://<USERNAME>.github.io/<REPO>/ 上, 
        将 publicPath 设为 "/myPages/" 。 
        module.exports = {
          publicPath: process.env.NODE_ENV === 'production'
            ? '/myPages/'
            : '/'}
```

